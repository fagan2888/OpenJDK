--- old/src/java.security.jgss/share/classes/javax/security/auth/kerberos/ServicePermission.java	2019-10-21 14:15:11.600512152 -0500
+++ new/src/java.security.jgss/share/classes/javax/security/auth/kerberos/ServicePermission.java	2019-10-21 14:15:11.604512102 -0500
@@ -214,10 +214,57 @@
 
 
     boolean impliesIgnoreMask(ServicePermission p) {
-        return ((this.getName().equals("*")) ||
-                this.getName().equals(p.getName()) ||
-                (p.getName().startsWith("@") &&
-                        this.getName().endsWith(p.getName())));
+        String pName = p.getName();
+
+        if ((this.getName().equals("*")) ||
+	     this.getName().equals(p.getName()) ||
+	     (pName.startsWith("@") &&
+	             this.getName().endsWith(pName)))
+            return true;
+
+        /*
+         * Empty realm in this or p is a wild-card.  This is needed to support
+         * non-Kerberos ServicePermissions for GSS (a band-aid until we can
+         * implement a proper GssAcceptorPermission class), but also because
+         * users may not know and might not care what realm the service is in,
+         * especially when they are using a keytab.
+         *
+         * If the user is using a password, then the realm matters more.  An
+         * untrusted actor could cause KDCs for a realm they control to see
+         * material they could attack offline, but that was already the case
+         * anyways, and the answer is the same in all cases: use stronger
+         * passwords, use randomized keys in a keytab, or let us implement
+         * SPAKE or similar alternatives to the venerable PA-ENC-TIMESTAMP.
+         */
+        if ((this.getName().equals("krbtgt/@") &&
+             pName.startsWith("krbtgt/")) ||
+            (pName.equals("krbtgt/@") &&
+             this.getName().startsWith("krbtgt/")))
+            return true;
+
+        String s = this.getName();
+        int n = s.length();
+        int i;
+        for (i = 0; i < n; i++) {
+            if (s.charAt(i) == '\\') {
+                i++;
+                continue;
+            }
+            if (s.charAt(i) == '@') {
+                /*
+                 * This is the same as:
+                 *
+                 *  String s = s.substring(0, i);
+                 *  return (p.getName().startsWith(s) &&
+                 *      (p.getName().equals(s) || this.getName().equals(s)));
+                 */
+                return (pName.regionMatches(0, s, 0, i + 1) &&
+                    (pName.length() == i + 1 || s.length() == i + 1));
+            }
+        }
+
+        // No realm, not even empty -> fail
+        return false;
     }
 
     /**
--- old/src/java.security.jgss/share/classes/org/ietf/jgss/GSSCredential.java	2019-10-21 14:15:11.716510694 -0500
+++ new/src/java.security.jgss/share/classes/org/ietf/jgss/GSSCredential.java	2019-10-21 14:15:11.720510644 -0500
@@ -25,6 +25,8 @@
 
 package org.ietf.jgss;
 
+import java.util.Map;
+
 /**
  * This interface encapsulates the GSS-API credentials for an entity.  A
  * credential contains all the necessary cryptographic information to
@@ -350,6 +352,26 @@
                     Oid mech, int usage) throws GSSException;
 
     /**
+     * Stores a credential element into an external credential store.
+     *
+     * @param usage The credential usage to store.
+     * @param mech The mechanism element of the credential to store.
+     * @param overwrite Whether to overwrite any existing credentials in
+     * the external store.
+     * @param defaultCred Whether to make the credential to be stored
+     * also be the default credential in the external store.
+     * @param store A description of the external store.  Common keys
+     * supported by platform-native GSS-API providers include:
+     * {@code ccache} and {@code keytab}, with the values being
+     * typically file paths.  Consult the documentation for your
+     * platform's native GSS-API providers.  The Java-native Krb5
+     * provider does not support this method at this time.
+     */
+    public void storeInto(int usage, Oid mech,
+                          boolean overwrite, boolean defaultCred,
+                          Map<String,String> store) throws GSSException;
+
+    /**
      * Tests if this GSSCredential asserts the same entity as the supplied
      * object.  The two credentials must be acquired over the same
      * mechanisms and must refer to the same principal.
--- old/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java	2019-10-21 14:15:11.828509286 -0500
+++ new/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java	2019-10-21 14:15:11.836509185 -0500
@@ -25,6 +25,7 @@
 
 package org.ietf.jgss;
 
+import java.util.Map;
 import java.security.Provider;
 
 /**
@@ -424,6 +425,117 @@
         throws GSSException;
 
     /**
+     * Factory method for acquiring a single mechanism credential with a
+     * password.<p>
+     *
+     * GSS-API mechanism providers must impose a local access-control
+     * policy on callers to prevent unauthorized callers from acquiring
+     * credentials to which they are not entitled. The kinds of permissions
+     * needed by different mechanism providers will be documented on a
+     * per-mechanism basis. A failed permission check might cause a {@link
+     * java.lang.SecurityException SecurityException} to be thrown from
+     * this method. <p>
+     *
+     * Non-default values for lifetime cannot always be honored by the
+     * underlying mechanisms, thus applications should be prepared to call
+     * {@link GSSCredential#getRemainingLifetime() getRemainingLifetime}
+     * on the returned credential.<p>
+     *
+     * @param name the name of the principal for whom this credential is to be
+     * acquired.  Use <code>null</code> to specify the default principal.
+     * @param password The password for the principal.
+     * @param lifetime The number of seconds that credentials should remain
+     * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
+     * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
+     * have the maximum permitted lifetime.  Use {@link
+     * GSSCredential#DEFAULT_LIFETIME GSSCredential.DEFAULT_LIFETIME} to
+     * request default credential lifetime.
+     * @param mech the Oid of the desired mechanism.  Use <code>(Oid) null
+     * </code> to request the default mechanism.
+     * @param usage The intended usage for this credential object. The value
+     * of this parameter must be one of:
+     * {@link GSSCredential#INITIATE_AND_ACCEPT
+     * GSSCredential.INITIATE_AND_ACCEPT},
+     * {@link GSSCredential#ACCEPT_ONLY GSSCredential.ACCEPT_ONLY}, and
+     * {@link GSSCredential#INITIATE_ONLY GSSCredential.INITIATE_ONLY}.
+     * @return a GSSCredential of the requested type.
+     *
+     * @see GSSCredential
+     *
+     * @throws GSSException containing the following
+     * major error codes:
+     *    {@link GSSException#BAD_MECH GSSException.BAD_MECH},
+     *    {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
+     *    {@link GSSException#BAD_NAME GSSException.BAD_NAME},
+     *    {@link GSSException#CREDENTIALS_EXPIRED
+     *                                   GSSException.CREDENTIALS_EXPIRED},
+     *    {@link GSSException#NO_CRED GSSException.NO_CRED},
+     *    {@link GSSException#FAILURE GSSException.FAILURE}
+     */
+    public abstract GSSCredential createCredential (GSSName name,
+                                  String password, int lifetime, Oid mech,
+                                  int usage)
+        throws GSSException;
+
+    /**
+     * Factory method for acquiring a single mechanism credential from
+     * an external credential store.<p>
+     *
+     * GSS-API mechanism providers must impose a local access-control
+     * policy on callers to prevent unauthorized callers from acquiring
+     * credentials to which they are not entitled. The kinds of permissions
+     * needed by different mechanism providers will be documented on a
+     * per-mechanism basis. A failed permission check might cause a {@link
+     * java.lang.SecurityException SecurityException} to be thrown from
+     * this method. <p>
+     *
+     * Non-default values for lifetime cannot always be honored by the
+     * underlying mechanisms, thus applications should be prepared to call
+     * {@link GSSCredential#getRemainingLifetime() getRemainingLifetime}
+     * on the returned credential.<p>
+     *
+     * @param name the name of the principal for whom this credential is to be
+     * acquired.  Use <code>null</code> to specify the default principal.
+     * @param store A description of an external credential store.
+     * Common keys supported by platform-native GSS-API providers
+     * include: {@code ccache} and {@code keytab}, with the values being
+     * typically file paths.  Consult the documentation for your
+     * platform's native GSS-API providers.  The Java-native Krb5
+     * provider does not support this method at this time.
+     * @param lifetime The number of seconds that credentials should remain
+     * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
+     * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
+     * have the maximum permitted lifetime.  Use {@link
+     * GSSCredential#DEFAULT_LIFETIME GSSCredential.DEFAULT_LIFETIME} to
+     * request default credential lifetime.
+     * @param mech the Oid of the desired mechanism.  Use <code>(Oid) null
+     * </code> to request the default mechanism.
+     * @param usage The intended usage for this credential object. The value
+     * of this parameter must be one of:
+     * {@link GSSCredential#INITIATE_AND_ACCEPT
+     * GSSCredential.INITIATE_AND_ACCEPT},
+     * {@link GSSCredential#ACCEPT_ONLY GSSCredential.ACCEPT_ONLY}, and
+     * {@link GSSCredential#INITIATE_ONLY GSSCredential.INITIATE_ONLY}.
+     * @return a GSSCredential of the requested type.
+     *
+     * @see GSSCredential
+     *
+     * @throws GSSException containing the following
+     * major error codes:
+     *    {@link GSSException#BAD_MECH GSSException.BAD_MECH},
+     *    {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
+     *    {@link GSSException#BAD_NAME GSSException.BAD_NAME},
+     *    {@link GSSException#CREDENTIALS_EXPIRED
+     *                                   GSSException.CREDENTIALS_EXPIRED},
+     *    {@link GSSException#NO_CRED GSSException.NO_CRED},
+     *    {@link GSSException#FAILURE GSSException.FAILURE}
+     */
+    public abstract GSSCredential createCredential (GSSName name,
+                                  Map<String,String> store, int lifetime,
+                                  Oid mech, int usage)
+        throws GSSException;
+
+    /**
      * Factory method for acquiring credentials over a set of
      * mechanisms. This method attempts to acquire credentials for
      * each of the mechanisms specified in the array called mechs.  To
@@ -481,6 +593,127 @@
         throws GSSException;
 
     /**
+     * Factory method for acquiring credentials with a password over a set of
+     * mechanisms. This method attempts to acquire credentials for
+     * each of the mechanisms specified in the array called mechs.  To
+     * determine the list of mechanisms for which the acquisition of
+     * credentials succeeded, the caller should use the {@link
+     * GSSCredential#getMechs() GSSCredential.getMechs} method.<p>
+     *
+     * GSS-API mechanism providers must impose a local access-control
+     * policy on callers to prevent unauthorized callers from acquiring
+     * credentials to which they are not entitled. The kinds of permissions
+     * needed by different mechanism providers will be documented on a
+     * per-mechanism basis. A failed permission check might cause a {@link
+     * java.lang.SecurityException SecurityException} to be thrown from
+     * this method.<p>
+     *
+     * Non-default values for lifetime cannot always be honored by the
+     * underlying mechanisms, thus applications should be prepared to call
+     * {@link GSSCredential#getRemainingLifetime() getRemainingLifetime}
+     * on the returned credential.<p>
+     *
+     * @param name the name of the principal for whom this credential is to
+     * be acquired.  Use <code>null</code> to specify the default
+     * principal.
+     * @param password The password for the principal.
+     * @param lifetime The number of seconds that credentials should remain
+     * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
+     * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
+     * have the maximum permitted lifetime.  Use {@link
+     * GSSCredential#DEFAULT_LIFETIME GSSCredential.DEFAULT_LIFETIME} to
+     * request default credential lifetime.
+     * @param mechs an array of Oid's indicating the mechanisms over which
+     * the credential is to be acquired.  Use <code>(Oid[]) null</code> for
+     * requesting a system specific default set of mechanisms.
+     * @param usage The intended usage for this credential object. The value
+     * of this parameter must be one of:
+     * {@link GSSCredential#INITIATE_AND_ACCEPT
+     * GSSCredential.INITIATE_AND_ACCEPT},
+     * {@link GSSCredential#ACCEPT_ONLY GSSCredential.ACCEPT_ONLY}, and
+     * {@link GSSCredential#INITIATE_ONLY GSSCredential.INITIATE_ONLY}.
+     * @return a GSSCredential of the requested type.
+     *
+     * @see GSSCredential
+     *
+     * @throws GSSException containing the following
+     * major error codes:
+     *    {@link GSSException#BAD_MECH GSSException.BAD_MECH},
+     *    {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
+     *    {@link GSSException#BAD_NAME GSSException.BAD_NAME},
+     *    {@link GSSException#CREDENTIALS_EXPIRED
+     *                                   GSSException.CREDENTIALS_EXPIRED},
+     *    {@link GSSException#NO_CRED GSSException.NO_CRED},
+     *    {@link GSSException#FAILURE GSSException.FAILURE}
+     */
+    public abstract GSSCredential createCredential(GSSName name,
+                                      String password, int lifetime,
+                                      Oid mechs[], int usage)
+        throws GSSException;
+
+    /**
+     * Factory method for acquiring credentials with a "credential
+     * store" over a set of mechanisms. This method attempts to acquire
+     * credentials for each of the mechanisms specified in the array
+     * called mechs.  To determine the list of mechanisms for which the
+     * acquisition of credentials succeeded, the caller should use the
+     * {@link GSSCredential#getMechs() GSSCredential.getMechs}
+     * method.<p>
+     *
+     * GSS-API mechanism providers must impose a local access-control
+     * policy on callers to prevent unauthorized callers from acquiring
+     * credentials to which they are not entitled. The kinds of permissions
+     * needed by different mechanism providers will be documented on a
+     * per-mechanism basis. A failed permission check might cause a {@link
+     * java.lang.SecurityException SecurityException} to be thrown from
+     * this method.<p>
+     *
+     * Non-default values for lifetime cannot always be honored by the
+     * underlying mechanisms, thus applications should be prepared to call
+     * {@link GSSCredential#getRemainingLifetime() getRemainingLifetime}
+     * on the returned credential.<p>
+     *
+     * @param name the name of the principal for whom this credential is to
+     * be acquired.  Use <code>null</code> to specify the default
+     * principal.
+     * @param store Map of string key and values describing how to
+     * acquire the credential. Consult the documentation for the various
+     * GSS mechanisms.
+     * @param lifetime The number of seconds that credentials should remain
+     * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
+     * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
+     * have the maximum permitted lifetime.  Use {@link
+     * GSSCredential#DEFAULT_LIFETIME GSSCredential.DEFAULT_LIFETIME} to
+     * request default credential lifetime.
+     * @param mechs an array of Oid's indicating the mechanisms over which
+     * the credential is to be acquired.  Use <code>(Oid[]) null</code> for
+     * requesting a system specific default set of mechanisms.
+     * @param usage The intended usage for this credential object. The value
+     * of this parameter must be one of:
+     * {@link GSSCredential#INITIATE_AND_ACCEPT
+     * GSSCredential.INITIATE_AND_ACCEPT},
+     * {@link GSSCredential#ACCEPT_ONLY GSSCredential.ACCEPT_ONLY}, and
+     * {@link GSSCredential#INITIATE_ONLY GSSCredential.INITIATE_ONLY}.
+     * @return a GSSCredential of the requested type.
+     *
+     * @see GSSCredential
+     *
+     * @throws GSSException containing the following
+     * major error codes:
+     *    {@link GSSException#BAD_MECH GSSException.BAD_MECH},
+     *    {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
+     *    {@link GSSException#BAD_NAME GSSException.BAD_NAME},
+     *    {@link GSSException#CREDENTIALS_EXPIRED
+     *                                   GSSException.CREDENTIALS_EXPIRED},
+     *    {@link GSSException#NO_CRED GSSException.NO_CRED},
+     *    {@link GSSException#FAILURE GSSException.FAILURE}
+     */
+    public abstract GSSCredential createCredential(GSSName name,
+                                      Map<String,String> store, int lifetime,
+                                      Oid mechs[], int usage)
+        throws GSSException;
+
+    /**
      * Factory method for creating a context on the initiator's
      * side.
      *
--- old/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java	2019-10-21 14:15:11.960507627 -0500
+++ new/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java	2019-10-21 14:15:11.964507576 -0500
@@ -24,6 +24,7 @@
  */
 
 package org.ietf.jgss;
+import java.security.Principal;
 
 /**
  * This interface encapsulates a single GSS-API principal entity. The
@@ -102,7 +103,7 @@
  * @author Mayank Upadhyay
  * @since 1.4
  */
-public interface GSSName {
+public interface GSSName extends Principal {
 
     /**
      * Oid indicating a host-based service name form.  It is used to
@@ -262,6 +263,16 @@
     public byte[] export() throws GSSException;
 
     /**
+     * Returns a local username form of a mechanism name, if available.
+     */
+    public String getLocalName() throws GSSException;
+
+    /**
+     * Returns a local username form of a mechanism name, if available.
+     */
+    public String getLocalName(Oid mech) throws GSSException;
+
+    /**
      * Returns a textual representation of the <code>GSSName</code> object.  To retrieve
      * the printed name format, which determines the syntax of the returned
      * string, use the {@link #getStringNameType() getStringNameType}
@@ -272,6 +283,26 @@
     public String toString();
 
     /**
+     * Returns a textual representation of the <code>GSSName</code> object.
+     *
+     * If <code>this</code> is not an MN then the returned name should be the
+     * same as the generic name used to construct it.  Otherwise the returned
+     * name may be a mechanism-specific name string.
+     *
+     * @return a String representing this name in printable form.
+     */
+    public String getName();
+
+    /**
+     * Returns a textual representation of the <code>GSSName</code> object
+     * element corresponding to the given <code>mech</code>.  This will be a
+     * mechanism-specific representation of <code>this</code.
+     *
+     * @return a String representing this name in printable form.
+     */
+    public String getName(Oid mech) throws GSSException;
+
+    /**
      * Returns the name type of the printable
      * representation of this name that can be obtained from the <code>
      * toString</code> method.
--- old/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java	2019-10-21 14:15:12.080506118 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java	2019-10-21 14:15:12.084506068 -0500
@@ -66,17 +66,70 @@
     }
 
     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
-                             int lifetime, Oid mech, int usage)
+                      int lifetime, Oid mech, int usage)
         throws GSSException {
         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 
         init(gssManager);
-        add(name, lifetime, lifetime, mech, usage);
+        String password = null;
+        add(name, password, lifetime, lifetime, mech, usage);
+    }
+
+    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
+                      Map<String,String> store, int lifetime, Oid mech,
+                      int usage)
+        throws GSSException {
+        if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
+
+        init(gssManager);
+        add(name, store, lifetime, lifetime, mech, usage);
+    }
+
+    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name, String password,
+                      int lifetime, Oid mech, int usage)
+        throws GSSException {
+        if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
+
+        init(gssManager);
+        add(name, password, lifetime, lifetime, mech, usage);
     }
 
     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
                       int lifetime, Oid[] mechs, int usage)
         throws GSSException {
+        this(gssManager, name, (String)null, lifetime, mechs, usage);
+    }
+
+    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
+                      Map<String,String> store, int lifetime,
+                      Oid mechs[], int usage)
+        throws GSSException {
+        init(gssManager);
+        boolean defaultList = false;
+        if (mechs == null) {
+            mechs = gssManager.getMechs();
+            defaultList = true;
+        }
+
+        for (int i = 0; i < mechs.length; i++) {
+            try {
+                add(name, store, lifetime, lifetime, mechs[i], usage);
+            } catch (GSSException e) {
+                if (defaultList) {
+                    // Try the next mechanism
+                    GSSUtil.debug("Ignore " + e + " while acquring cred for "
+                        + mechs[i]);
+                    //e.printStackTrace();
+                } else throw e; // else try the next mechanism
+            }
+        }
+        if ((hashtable.size() == 0) || (usage != getUsage()))
+            throw new GSSException(GSSException.NO_CRED);
+    }
+
+    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
+                      String password, int lifetime, Oid mechs[], int usage)
+        throws GSSException {
         init(gssManager);
         boolean defaultList = false;
         if (mechs == null) {
@@ -86,7 +139,7 @@
 
         for (int i = 0; i < mechs.length; i++) {
             try {
-                add(name, lifetime, lifetime, mechs[i], usage);
+                add(name, password, lifetime, lifetime, mechs[i], usage);
             } catch (GSSException e) {
                 if (defaultList) {
                     // Try the next mechanism
@@ -417,6 +470,27 @@
 
     public void add(GSSName name, int initLifetime, int acceptLifetime,
                     Oid mech, int usage) throws GSSException {
+        String password = null;
+        add(name, password, initLifetime, acceptLifetime, mech, usage);
+    }
+
+    public void add(GSSName name, Map<String,String> store, int initLifetime,
+                    int acceptLifetime, Oid mech, int usage)
+                    throws GSSException {
+        add(name, (String)null, store, initLifetime, acceptLifetime,
+            mech, usage);
+    }
+
+    public void add(GSSName name, String password, int initLifetime,
+                    int acceptLifetime, Oid mech, int usage)
+                    throws GSSException {
+        add(name, password, (Map<String,String>)null, initLifetime,
+            acceptLifetime, mech, usage);
+    }
+
+    private void add(GSSName name, String password, Map<String,String> store,
+                    int initLifetime, int acceptLifetime, Oid mech, int usage)
+                    throws GSSException {
 
         if (destroyed) {
             throw new IllegalStateException("This credential is " +
@@ -436,11 +510,27 @@
         GSSNameSpi nameElement = (name == null ? null :
                                   ((GSSNameImpl)name).getElement(mech));
 
-        tempCred = gssManager.getCredentialElement(nameElement,
-                                                   initLifetime,
-                                                   acceptLifetime,
-                                                   mech,
-                                                   usage);
+        if (password == null && store == null) {
+            tempCred = gssManager.getCredentialElement(nameElement,
+                                                       initLifetime,
+                                                       acceptLifetime,
+                                                       mech,
+                                                       usage);
+        } else if (password != null) {
+            tempCred = gssManager.getCredentialElement(nameElement,
+                                                       password,
+                                                       initLifetime,
+                                                       acceptLifetime,
+                                                       mech,
+                                                       usage);
+        } else {
+            tempCred = gssManager.getCredentialElement(nameElement,
+                                                       store,
+                                                       initLifetime,
+                                                       acceptLifetime,
+                                                       mech,
+                                                       usage);
+        }
         /*
          * Not all mechanisms support the concept of one credential element
          * that can be used for both initiating and accepting a context. In
@@ -474,11 +564,27 @@
                 key = new SearchKey(mech, currentUsage);
                 hashtable.put(key, tempCred);
 
-                tempCred = gssManager.getCredentialElement(nameElement,
-                                                        initLifetime,
-                                                        acceptLifetime,
-                                                        mech,
-                                                        desiredUsage);
+                if (store == null && password == null) {
+                    tempCred = gssManager.getCredentialElement(nameElement,
+                                                               initLifetime,
+                                                               acceptLifetime,
+                                                               mech,
+                                                               desiredUsage);
+                } else if (password != null) {
+                    tempCred = gssManager.getCredentialElement(nameElement,
+                                                               password,
+                                                               initLifetime,
+                                                               acceptLifetime,
+                                                               mech,
+                                                               desiredUsage);
+                } else {
+                    tempCred = gssManager.getCredentialElement(nameElement,
+                                                               store,
+                                                               initLifetime,
+                                                               acceptLifetime,
+                                                               mech,
+                                                               desiredUsage);
+                }
 
                 key = new SearchKey(mech, desiredUsage);
                 hashtable.put(key, tempCred);
@@ -640,6 +746,31 @@
         return displayString;
     }
 
+    public void storeInto(int usage, Oid mech,
+                          boolean overwrite, boolean defaultCred,
+                          Map<String,String> store) throws GSSException {
+        if (destroyed) {
+            throw new IllegalStateException("This credential is " +
+                                            "no longer valid");
+        }
+
+        SearchKey key = null;
+        GSSCredentialSpi element = null;
+
+        if (mech == null) {
+            mech = ProviderList.DEFAULT_MECH_OID;
+        }
+
+        key = new SearchKey(mech, usage);
+        element = hashtable.get(key);
+        if (element == null) {
+            throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
+        }
+
+        element.storeInto(usage, overwrite, defaultCred, store);
+    }
+
+
     public String toString() {
 
         if (destroyed) {
--- old/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java	2019-10-21 14:15:12.212504458 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java	2019-10-21 14:15:12.216504408 -0500
@@ -25,6 +25,7 @@
 
 package sun.security.jgss;
 
+import java.util.Map;
 import org.ietf.jgss.*;
 import sun.security.action.GetBooleanAction;
 import sun.security.jgss.spi.*;
@@ -136,11 +137,41 @@
     }
 
     public GSSCredential createCredential(GSSName aName,
+                                          Map<String,String> store,
+                                          int lifetime, Oid mech, int usage)
+        throws GSSException {
+        return new GSSCredentialImpl(this, aName, store, lifetime, mech,
+            usage);
+    }
+
+    public GSSCredential createCredential(GSSName aName, String password,
+                                          int lifetime, Oid mech, int usage)
+        throws GSSException {
+        return new GSSCredentialImpl(this, aName, password,
+                lifetime, mech, usage);
+    }
+
+    public GSSCredential createCredential(GSSName aName,
                                           int lifetime, Oid[] mechs, int usage)
         throws GSSException {
         return wrap(new GSSCredentialImpl(this, aName, lifetime, mechs, usage));
     }
 
+    public GSSCredential createCredential(GSSName aName, String password,
+                                          int lifetime, Oid mechs[], int usage)
+        throws GSSException {
+        return new GSSCredentialImpl(this, aName, password,
+                lifetime, mechs, usage);
+    }
+
+    public GSSCredential createCredential(GSSName aName,
+                                          Map<String,String> store,
+                                          int lifetime, Oid mechs[], int usage)
+        throws GSSException {
+        return new GSSCredentialImpl(this, aName, store,
+                lifetime, mechs, usage);
+    }
+
     public GSSContext createContext(GSSName peer, Oid mech,
                                     GSSCredential myCred, int lifetime)
         throws GSSException {
@@ -175,6 +206,28 @@
                                             acceptLifetime, usage);
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 String password,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 Oid mech, int usage)
+        throws GSSException {
+        MechanismFactory factory = list.getMechFactory(mech);
+        return factory.getCredentialElement(name, password, initLifetime,
+                                            acceptLifetime, usage);
+    }
+
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 Map<String,String> store,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 Oid mech, int usage)
+        throws GSSException {
+        MechanismFactory factory = list.getMechFactory(mech);
+        return factory.getCredentialElement(name, store, initLifetime,
+                                            acceptLifetime, usage);
+    }
+
     // Used by java SPNEGO impl
     public GSSNameSpi getNameElement(String name, Oid nameType, Oid mech)
         throws GSSException {
--- old/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java	2019-10-21 14:15:12.336502900 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java	2019-10-21 14:15:12.340502849 -0500
@@ -447,8 +447,57 @@
     }
 
     public String toString() {
-         return printableName;
+        return printableName;
+    }
+
+    public String getName() {
+        return printableName;
+    }
+
+    public String getName(Oid mech) throws GSSException {
+        GSSNameSpi element = elements.get(mech);
+        if (element == null) {
+            throw new GSSExceptionImpl(GSSException.UNAVAILABLE,
+                    "GSSName object does not have an element for the " +
+                    "given mechanism");
+        }
+        return element.toString();
+    }
+
+    public String getLocalName() throws GSSException {
+        String lname = null;
+        Oid mech = null;
+        Oid mech2 = null;
+
+        for (GSSNameSpi v : elements.values()) {
+            String mname = v.getLocalName();
+            if (mname == null)
+                continue;
+            if (lname == null) {
+                mech = v.getMechanism();
+                lname = mname;
+                continue;
+            }
+            if (!lname.equals(mname)) {
+                mech2 = v.getMechanism();
+                break;
+            }
+        }
+        if (mech2 == null)
+            return lname;
+        throw new GSSExceptionImpl(GSSException.UNAVAILABLE,
+                "Localname conflict between mechanisms " +
+                mech + " and " + mech2);
+    }
 
+    public String getLocalName(Oid mech) throws GSSException {
+        GSSNameSpi element = elements.get(mech);
+        if (element == null) {
+            throw new GSSExceptionImpl(GSSException.UNAVAILABLE,
+                    "GSSName object does not have an element for the " +
+                    "given mechanism");
+        }
+        return element.getLocalName();
     }
 
     public Oid getStringNameType() throws GSSException {
--- old/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java	2019-10-21 14:15:12.456501391 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java	2019-10-21 14:15:12.464501290 -0500
@@ -120,43 +120,26 @@
                                      GSSCredential creds) {
 
         HashSet<Object> privCredentials = null;
-        HashSet<Object> pubCredentials = new HashSet<Object>(); // empty Set
+        HashSet<Object> pubCredentials = new HashSet<>(); // empty Set
 
         Set<GSSCredentialSpi> gssCredentials = null;
 
-        Set<KerberosPrincipal> krb5Principals =
-                                new HashSet<KerberosPrincipal>();
-
-        if (name instanceof GSSNameImpl) {
-            try {
-                GSSNameSpi ne = ((GSSNameImpl) name).getElement
-                    (GSS_KRB5_MECH_OID);
-                String krbName = ne.toString();
-                if (ne instanceof Krb5NameElement) {
-                    krbName =
-                        ((Krb5NameElement) ne).getKrb5PrincipalName().getName();
-                }
-                KerberosPrincipal krbPrinc = new KerberosPrincipal(krbName);
-                krb5Principals.add(krbPrinc);
-            } catch (GSSException ge) {
-                debug("Skipped name " + name + " due to " + ge);
-            }
-        }
+        Set<GSSName> names = new HashSet<>();
+        names.add(name);
 
         if (creds instanceof GSSCredentialImpl) {
             gssCredentials = ((GSSCredentialImpl) creds).getElements();
-            privCredentials = new HashSet<Object>(gssCredentials.size());
+            privCredentials = new HashSet<>(gssCredentials.size());
             populateCredentials(privCredentials, gssCredentials);
         } else {
-            privCredentials = new HashSet<Object>(); // empty Set
+            privCredentials = new HashSet<>(); // empty Set
         }
         debug("Created Subject with the following");
-        debug("principals=" + krb5Principals);
+        debug("principals=" + names);
         debug("public creds=" + pubCredentials);
         debug("private creds=" + privCredentials);
 
-        return new Subject(false, krb5Principals, pubCredentials,
-                           privCredentials);
+        return new Subject(false, names, pubCredentials, privCredentials);
 
     }
 
@@ -172,12 +155,7 @@
     private static void populateCredentials(Set<Object> credentials,
                                             Set<?> gssCredentials) {
 
-        Object cred;
-
-        Iterator<?> elements = gssCredentials.iterator();
-        while (elements.hasNext()) {
-
-            cred = elements.next();
+        for (Object cred : gssCredentials) {
 
             // Retrieve the internal cred out of SpNegoCredElement
             if (cred instanceof SpNegoCredElement) {
@@ -321,30 +299,41 @@
                     public Vector<T> run() throws Exception {
                         Subject accSubj = Subject.getSubject(acc);
                         Vector<T> result = null;
-                        if (accSubj != null) {
-                            result = new Vector<T>();
-                            Iterator<GSSCredentialImpl> iterator =
-                                accSubj.getPrivateCredentials
-                                (GSSCredentialImpl.class).iterator();
-                            while (iterator.hasNext()) {
-                                GSSCredentialImpl cred = iterator.next();
-                                debug("...Found cred" + cred);
-                                try {
-                                    GSSCredentialSpi ce =
-                                        cred.getElement(mech, initiate);
-                                    debug("......Found element: " + ce);
-                                    if (ce.getClass().equals(credCls) &&
-                                        (name == null ||
-                                         name.equals((Object) ce.getName()))) {
+                        if (accSubj == null) {
+                            debug("No Subject");
+                            return result;
+                        }
+
+                        result = new Vector<T>();
+                        for (GSSCredentialImpl cred : accSubj.getPrivateCredentials
+                                                      (GSSCredentialImpl.class)) {
+                            debug("...Found cred" + cred);
+                            try {
+                                GSSCredentialSpi ce =
+                                    cred.getElement(mech, initiate);
+                                debug("......Found element: " + ce);
+                                if (!ce.getClass().equals(credCls)) {
+                                    debug("......Discard element (class mismatch)");
+                                } else if (name == null) {
+                                    /*
+                                     * If the caller doesn't care about
+                                     * the specific name, then prefer
+                                     * default credentials to
+                                     * non-default credentials.
+                                     */
+                                    if (ce.isDefaultCredential())
+                                        result.add(0, credCls.cast(ce));
+                                    else
                                         result.add(credCls.cast(ce));
-                                    } else {
-                                        debug("......Discard element");
-                                    }
-                                } catch (GSSException ge) {
-                                    debug("...Discard cred (" + ge + ")");
+                                } else if (name.equals((Object) ce.getName())) {
+                                    result.add(credCls.cast(ce));
+                                } else {
+                                    debug("......Discard element (name mismatch)");
                                 }
+                            } catch (GSSException ge) {
+                                debug("...Discard cred (exception: " + ge + ")");
                             }
-                        } else debug("No Subject");
+                        }
                         return result;
                     }
                 });
--- old/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java	2019-10-21 14:15:12.596499631 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java	2019-10-21 14:15:12.600499581 -0500
@@ -42,6 +42,7 @@
     private final Configuration config;
     private final GSSCaller caller;
     private final String mechName;
+    private final boolean useNative;
     private static final sun.security.util.Debug debug =
         sun.security.util.Debug.getInstance("gssloginconfig", "\t[GSS LoginConfigImpl]");
 
@@ -65,8 +66,17 @@
 
         this.caller = caller;
 
-        if (mech.equals(GSSUtil.GSS_KRB5_MECH_OID)) {
+        useNative = "true".equalsIgnoreCase(
+                System.getProperty("sun.security.jgss.native"));
+
+        if (mech.equals(GSSUtil.GSS_KRB5_MECH_OID) ||
+                mech.equals(GSSUtil.GSS_KRB5_MECH_OID2) ||
+                mech.equals(GSSUtil.GSS_KRB5_MECH_OID_MS)) {
             mechName = "krb5";
+        } else if (useNative) {
+            // We don't really need a mechName, nor do we have any sort of
+            // standard notion of mechanism name (other than OIDs).
+            mechName = mech.toString();
         } else {
             throw new IllegalArgumentException(mech.toString() + " not supported");
         }
@@ -98,7 +108,7 @@
         // For the 4 old callers, old entry names will be used if the new
         // entry name is not provided.
 
-        if ("krb5".equals(mechName)) {
+        if ("krb5".equals(mechName) || useNative) {
             if (caller == GSSCaller.CALLER_INITIATE) {
                 alts = new String[] {
                     "com.sun.security.jgss.krb5.initiate",
@@ -118,7 +128,7 @@
             }
         } else {
             throw new IllegalArgumentException(mechName + " not supported");
-            // No other mech at the moment, maybe --
+            // No other Java-coded mech at the moment, maybe --
             /*
             switch (caller) {
             case GSSUtil.CALLER_INITIATE:
@@ -165,30 +175,42 @@
      * the system-wide Configuration object.
      */
     private AppConfigurationEntry[] getDefaultConfigurationEntry() {
-        HashMap <String, String> options = new HashMap <String, String> (2);
+        HashMap <String, String> gssOptions = new HashMap <String, String> (2);
+        HashMap <String, String> krb5Options = new HashMap <String, String> (2);
 
-        if (mechName == null || mechName.equals("krb5")) {
+        if (mechName == null || mechName.equals("krb5") || useNative) {
             if (isServerSide(caller)) {
+                gssOptions.put("useDefaultCreds", "true");
+                gssOptions.put("doNotPrompt", "true");
+                gssOptions.put("accept", "true");
                 // Assuming the keytab file can be found through
                 // krb5 config file or under user home directory
-                options.put("useKeyTab", "true");
-                options.put("storeKey", "true");
-                options.put("doNotPrompt", "true");
-                options.put("principal", "*");
-                options.put("isInitiator", "false");
+                krb5Options.put("useKeyTab", "true");
+                krb5Options.put("storeKey", "true");
+                krb5Options.put("doNotPrompt", "true");
+                krb5Options.put("principal", "*");
+                krb5Options.put("isInitiator", "false");
             } else {
                 if (caller instanceof HttpCaller && !HTTP_USE_GLOBAL_CREDS) {
-                    options.put("useTicketCache", "false");
+                    gssOptions.put("tryDefaultCreds", "false");
+                    krb5Options.put("useTicketCache", "false");
                 } else {
-                    options.put("useTicketCache", "true");
+                    gssOptions.put("tryDefaultCreds", "true");
+                    krb5Options.put("useTicketCache", "true");
                 }
-                options.put("doNotPrompt", "false");
+                gssOptions.put("initiate", "true");
+                gssOptions.put("doNotPrompt", "false");
+                krb5Options.put("doNotPrompt", "false");
             }
             return new AppConfigurationEntry[] {
                 new AppConfigurationEntry(
-                        "com.sun.security.auth.module.Krb5LoginModule",
+                        "com.sun.security.auth.module.GssLoginModule",
                         AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,
-                        options)
+                        gssOptions),
+                new AppConfigurationEntry(
+                        "com.sun.security.auth.module.Krb5LoginModule",
+                        AppConfigurationEntry.LoginModuleControlFlag.SUFFICIENT,
+                        krb5Options)
             };
         }
         return null;
--- old/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5AcceptCredential.java	2019-10-21 14:15:12.712498173 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5AcceptCredential.java	2019-10-21 14:15:12.716498122 -0500
@@ -47,6 +47,7 @@
 
     private final Krb5NameElement name;
     private final ServiceCreds screds;
+    private boolean isDefCred = false;
 
     private Krb5AcceptCredential(Krb5NameElement name, ServiceCreds creds) {
         /*
@@ -57,6 +58,8 @@
 
         this.name = name;
         this.screds = creds;
+        if (name == null)
+            isDefCred = true;
     }
 
     static Krb5AcceptCredential getInstance(final GSSCaller caller, Krb5NameElement name)
@@ -148,6 +151,15 @@
         return Krb5MechFactory.GSS_KRB5_MECH_OID;
     }
 
+    /**
+     * Returns true if the credential is a default credential.
+     *
+     * @return true if the credential is a default credential, else false.
+     */
+    public boolean isDefaultCredential() {
+        return isDefCred;
+    }
+
     public final java.security.Provider getProvider() {
         return Krb5MechFactory.PROVIDER;
     }
--- old/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5InitCredential.java	2019-10-21 14:15:12.820496815 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5InitCredential.java	2019-10-21 14:15:12.824496765 -0500
@@ -56,6 +56,7 @@
     private Krb5NameElement name;
     private Credentials krb5Credentials;
     public KerberosTicket proxyTicket;
+    private boolean isDefCred;
 
     private Krb5InitCredential(Krb5NameElement name,
                                byte[] asn1Encoding,
@@ -88,6 +89,8 @@
         KerberosSecrets.getJavaxSecurityAuthKerberosAccess()
                 .kerberosTicketSetServerAlias(this, serverAlias);
         this.name = name;
+        if (name == null)
+            isDefCred = true;
 
         try {
             // Cache this for later use by the sun.security.krb5 package.
@@ -149,7 +152,8 @@
                 .kerberosTicketSetServerAlias(this, serverAlias);
         this.name = name;
         // A delegated cred does not have all fields set. So do not try to
-        // creat new Credentials out of the delegatedCred.
+        // creat new Credentials out of the delegatedCred.  Also, a delegated
+        // credential is not a default credential.
         this.krb5Credentials = delegatedCred;
     }
 
@@ -311,6 +315,15 @@
         return Krb5MechFactory.GSS_KRB5_MECH_OID;
     }
 
+    /**
+     * Returns true if the credential is a default credential.
+     *
+     * @return true if the credential is a default credential, else false.
+     */
+    public boolean isDefaultCredential() {
+        return isDefCred;
+    }
+
     public final java.security.Provider getProvider() {
         return Krb5MechFactory.PROVIDER;
     }
--- old/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java	2019-10-21 14:15:12.936495357 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java	2019-10-21 14:15:12.940495306 -0500
@@ -32,6 +32,7 @@
 import javax.security.auth.kerberos.ServicePermission;
 import java.security.Provider;
 import java.util.Vector;
+import java.util.Map;
 
 /**
  * Krb5 Mechanism plug in for JGSS
@@ -108,9 +109,17 @@
     }
 
     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
-           int initLifetime, int acceptLifetime,
+           String password, int initLifetime, int acceptLifetime,
            int usage) throws GSSException {
 
+        if (password != null) {
+            // XXX Implement!  Shouldn't be too hard...
+            throw new GSSException(GSSException.UNAVAILABLE, -1,
+                    "The Kerberos mechanism Java implementation does not " +
+                    "currently support acquiring GSS credentials handle " +
+                    "elements with a password");
+        }
+
         if (name != null && !(name instanceof Krb5NameElement)) {
             name = Krb5NameElement.getInstance(name.toString(),
                                        name.getStringNameType());
@@ -141,6 +150,62 @@
         return credElement;
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+           Map<String,String> store, int initLifetime, int acceptLifetime,
+           int usage) throws GSSException {
+
+        if (store != null) {
+            // XXX Implement!  Shouldn't be too hard...
+            throw new GSSException(GSSException.UNAVAILABLE, -1,
+                    "The Kerberos mechanism Java implementation does not " +
+                    "currently support acquiring GSS credentials handle " +
+                    "elements using a \"credential store\"");
+        }
+
+        if (name != null && !(name instanceof Krb5NameElement)) {
+            name = Krb5NameElement.getInstance(name.toString(),
+                                       name.getStringNameType());
+        }
+
+        Krb5CredElement credElement = getCredFromSubject
+            (name, (usage != GSSCredential.ACCEPT_ONLY));
+
+        if (credElement == null) {
+            if (usage == GSSCredential.INITIATE_ONLY ||
+                usage == GSSCredential.INITIATE_AND_ACCEPT) {
+                credElement = Krb5InitCredential.getInstance
+                    (caller, (Krb5NameElement) name, initLifetime);
+                checkInitCredPermission
+                    ((Krb5NameElement) credElement.getName());
+            } else if (usage == GSSCredential.ACCEPT_ONLY) {
+                credElement =
+                    Krb5AcceptCredential.getInstance(caller,
+                                                     (Krb5NameElement) name);
+                checkAcceptCredPermission
+                    ((Krb5NameElement) credElement.getName(), name);
+            } else
+                throw new GSSException(GSSException.FAILURE, -1,
+                                       "Unknown usage mode requested");
+        }
+        return credElement;
+    }
+
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+            int initLifetime, int acceptLifetime, int usage)
+        throws GSSException {
+        return getCredentialElement(name, initLifetime, acceptLifetime,
+            usage);
+    }
+
+    public void storeCredInto(GSSCredentialSpi cred, int usage,
+                              boolean overwrite, boolean defaultCred,
+                              Map<String,String> store) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "The Kerberos mechanism Java implementation does not " +
+                "currently support storing GSS credentials handle " +
+                "elements into a \"credential store\"");
+    }
+
     public static void checkInitCredPermission(Krb5NameElement name) {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
@@ -153,7 +218,7 @@
                 sm.checkPermission(perm);
             } catch (SecurityException e) {
                 if (DEBUG) {
-                    System.out.println("Permission to initiate" +
+                    System.out.println("Permission to initiate " +
                         "kerberos init credential" + e.getMessage());
                 }
                 throw e;
--- old/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java	2019-10-21 14:15:13.056493848 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java	2019-10-21 14:15:13.060493798 -0500
@@ -317,6 +317,32 @@
     }
 
     /**
+     * Returns a local username (platform-specific) corresponding to the
+     * principal name, and may return null when no username is known for the
+     * principal name.
+     *
+     * @return username corresponding to this principal name, if any
+     */
+    public String getLocalName() throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "Mapping Kerberos principal names to usernames is not " +
+                "currently supported");
+    }
+
+    /**
+     * Returns a local username (platform-specific) corresponding to the
+     * principal name, and may return null when no username is known for the
+     * principal name.
+     *
+     * @return username corresponding to this principal name, if any
+     */
+    public String getLocalName(Oid mech) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "Mapping Kerberos principal names to usernames is not " +
+                "currently supported");
+    }
+
+    /**
      * Returns the name type oid.
      */
     public Oid getGSSNameType() {
@@ -341,6 +367,10 @@
         return (gssNameType.equals(GSSName.NT_ANONYMOUS));
     }
 
+    public boolean isDefaultCredentialName() {
+        return false;
+    }
+
     public Provider getProvider() {
         return Krb5MechFactory.PROVIDER;
     }
--- old/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5ProxyCredential.java	2019-10-21 14:15:13.168492440 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5ProxyCredential.java	2019-10-21 14:15:13.172492390 -0500
@@ -92,6 +92,11 @@
     }
 
     @Override
+    public final boolean isDefaultCredential() {
+        return false;
+    }
+
+    @Override
     public final Oid getMechanism() {
         return Krb5MechFactory.GSS_KRB5_MECH_OID;
     }
--- old/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java	2019-10-21 14:15:13.280491032 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java	2019-10-21 14:15:13.284490982 -0500
@@ -27,6 +27,7 @@
 
 import org.ietf.jgss.*;
 import java.security.Provider;
+import java.util.Map;
 
 /**
  * This interface is implemented by a mechanism specific credential
@@ -88,6 +89,13 @@
      */
     public boolean isAcceptorCredential() throws GSSException;
 
+     /**
+      * Returns true if the credential is a default credential.
+      *
+      * @return true if the credential is a default credential, else false.
+      */
+     public boolean isDefaultCredential();
+
     /**
      * Returns the oid representing the underlying credential
      * mechanism oid.
@@ -98,6 +106,26 @@
     public Oid getMechanism();
 
     /**
+     * Stores a credential in the location specified by the store
+     * argument.
+     *
+     * @param usage The credential usage to store.
+     * @param overwrite Whether to overwrite any credential found at the
+     * given store location.
+     * @param defaultCred Whether to make the credential the default
+     * credential in the store at the given location.
+     * @param store A map of string keys and values specifying a store
+     * location.
+     */
+    default void storeInto(int usage, boolean overwrite, boolean defaultCred,
+                           Map<String,String> store) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "The " + getMechanism() + "mechanism does not " +
+                "currently support storing GSS credentials handle " +
+                "elements into a \"credential store\"");
+    }
+
+    /**
      * Impersonates another client.
      *
      * @param name the client to impersonate
--- old/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java	2019-10-21 14:15:13.396489574 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java	2019-10-21 14:15:13.400489523 -0500
@@ -100,6 +100,23 @@
      */
     public String toString();
 
+    /**
+     * Returns a local username (platform-specific) corresponding to the
+     * principal name, and may return null when no username is known for the
+     * principal name.
+     *
+     * @return username corresponding to this name, if any
+     */
+    public String getLocalName() throws GSSException;
+
+    /**
+     * Returns a local username (platform-specific) corresponding to the
+     * principal name, and may return null when no username is known for the
+     * principal name.
+     *
+     * @return username corresponding to this name, if any
+     */
+    public String getLocalName(Oid mech) throws GSSException;
 
     /**
      * Returns the oid describing the format of the printable name.
@@ -112,4 +129,10 @@
      * Indicates if this name object represents an Anonymous name.
      */
     public boolean isAnonymousName();
+
+    /**
+     * Indicates whether this name object refers to whatever name(s) the
+     * default credentials respond to.
+     */
+    public boolean isDefaultCredentialName();
 }
--- old/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java	2019-10-21 14:15:13.512488115 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java	2019-10-21 14:15:13.516488065 -0500
@@ -27,6 +27,7 @@
 
 import org.ietf.jgss.*;
 import java.security.Provider;
+import java.util.Map;
 
 /**
  * This interface is implemented by the factory class for every
@@ -119,6 +120,135 @@
       int initLifetime, int acceptLifetime, int usage) throws GSSException;
 
     /**
+     * Creates a credential element using a password for this mechanism to be
+     * included as part of a GSSCredential implementation. A GSSCredential is
+     * conceptually a container class of several credential elements from
+     * different mechanisms. A GSS-API credential can be used either for
+     * initiating GSS security contexts or for accepting them. This method
+     * also accepts parameters that indicate what usage is expected and how
+     * long the life of the credential should be. It is not necessary that
+     * the mechanism honor the request for lifetime. An application will
+     * always query an acquired GSSCredential to determine what lifetime it
+     * got back.<p>
+     *
+     * <b>Not all mechanisms support the concept of one credential element
+     * that can be used for both initiating and accepting a context. In the
+     * event that an application requests usage INITIATE_AND_ACCEPT for a
+     * credential from such a mechanism, the GSS framework will need to
+     * obtain two different credential elements from the mechanism, one
+     * that will have usage INITIATE_ONLY and another that will have usage
+     * ACCEPT_ONLY. The mechanism will help the GSS-API realize this by
+     * returning a credential element with usage INITIATE_ONLY or
+     * ACCEPT_ONLY prompting it to make another call to
+     * getCredentialElement, this time with the other usage mode. The
+     * mechanism indicates the missing mode by returning a 0 lifetime for
+     * it.</b>
+     *
+     * @param name the mechanism level name element for the entity whose
+     * credential is desired. A null value indicates that a mechanism
+     * dependent default choice is to be made.
+     * @param password is the password for the entity whose credential
+     * is desired.
+     * @param initLifetime indicates the lifetime (in seconds) that is
+     * requested for this credential to be used at the context initiator's
+     * end. This value should be ignored if the usage is
+     * ACCEPT_ONLY. Predefined contants are available in the
+     * org.ietf.jgss.GSSCredential interface.
+     * @param acceptLifetime indicates the lifetime (in seconds) that is
+     * requested for this credential to be used at the context acceptor's
+     * end. This value should be ignored if the usage is
+     * INITIATE_ONLY. Predefined contants are available in the
+     * org.ietf.jgss.GSSCredential interface.
+     * @param usage One of the values GSSCredential.INIATE_ONLY,
+     * GSSCredential.ACCEPT_ONLY, and GSSCredential.INITIATE_AND_ACCEPT.
+     * @see org.ietf.jgss.GSSCredential
+     * @throws GSSException if one of the error situations described in RFC
+     * 2743 with the GSS_Acquire_Cred or GSS_Add_Cred calls occurs.
+     */
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+      String password, int initLifetime, int acceptLifetime, int usage)
+        throws GSSException;
+
+    /**
+     * Creates a credential element using a "credential store" for this
+     * mechanism to be included as part of a GSSCredential
+     * implementation. A GSSCredential is conceptually a container class
+     * of several credential elements from different mechanisms. A
+     * GSS-API credential can be used either for initiating GSS security
+     * contexts or for accepting them. This method also accepts
+     * parameters that indicate what usage is expected and how long the
+     * life of the credential should be. It is not necessary that the
+     * mechanism honor the request for lifetime. An application will
+     * always query an acquired GSSCredential to determine what lifetime
+     * it got back.<p>
+     *
+     * <b>Not all mechanisms support the concept of one credential element
+     * that can be used for both initiating and accepting a context. In the
+     * event that an application requests usage INITIATE_AND_ACCEPT for a
+     * credential from such a mechanism, the GSS framework will need to
+     * obtain two different credential elements from the mechanism, one
+     * that will have usage INITIATE_ONLY and another that will have usage
+     * ACCEPT_ONLY. The mechanism will help the GSS-API realize this by
+     * returning a credential element with usage INITIATE_ONLY or
+     * ACCEPT_ONLY prompting it to make another call to
+     * getCredentialElement, this time with the other usage mode. The
+     * mechanism indicates the missing mode by returning a 0 lifetime for
+     * it.</b>
+     *
+     * @param name the mechanism level name element for the entity whose
+     * credential is desired. A null value indicates that a mechanism
+     * dependent default choice is to be made.
+     * @param store is an array of even length whose elements at even
+     * indices are keys, and whose elements at any odd index are the
+     * values for the preceding keys. Keys supported by mechanisms
+     * vary. This is mostly intended for use with the platform's native
+     * GSS-API providers. Common keys include "keytab", "client_keytab",
+     * "ccache", and "rcache". Consult the documentation for the
+     * platform's native GSS-API providers.
+     * @param initLifetime indicates the lifetime (in seconds) that is
+     * requested for this credential to be used at the context initiator's
+     * end. This value should be ignored if the usage is
+     * ACCEPT_ONLY. Predefined contants are available in the
+     * org.ietf.jgss.GSSCredential interface.
+     * @param acceptLifetime indicates the lifetime (in seconds) that is
+     * requested for this credential to be used at the context acceptor's
+     * end. This value should be ignored if the usage is
+     * INITIATE_ONLY. Predefined contants are available in the
+     * org.ietf.jgss.GSSCredential interface.
+     * @param usage One of the values GSSCredential.INIATE_ONLY,
+     * GSSCredential.ACCEPT_ONLY, and GSSCredential.INITIATE_AND_ACCEPT.
+     * @see org.ietf.jgss.GSSCredential
+     * @throws GSSException if one of the error situations described in RFC
+     * 2743 with the GSS_Acquire_Cred or GSS_Add_Cred calls occurs.
+     */
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 Map<String,String> store,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 int usage)
+        throws GSSException;
+
+    /**
+     * Stores a credential element into a specified location.
+     *
+     * @param cred The credential element to store.
+     * @param usage The credential usage to store.
+     * @param overwrite Whether to overwrite credentials found at the specified
+     * location.
+     * @param @defaultCred Whether to store the credentials as the default
+     * credentials in the specified location.
+     * @param store The location into which to store the credentials.
+     */
+    default void storeCredInto(GSSCredentialSpi cred, int usage,
+                              boolean overwrite, boolean defaultCred,
+                              Map<String,String> store) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "The " + getMechanismOid() + "mechanism does not " +
+                "currently support storing GSS credentials handle " +
+                "elements into a \"credential store\"");
+    }
+
+    /**
      * Creates a name element for this mechanism to be included as part of
      * a GSSName implementation. A GSSName is conceptually a container
      * class of several name elements from different mechanisms. A GSSName
--- old/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoCredElement.java	2019-10-21 14:15:13.624486707 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoCredElement.java	2019-10-21 14:15:13.628486657 -0500
@@ -91,4 +91,8 @@
     public GSSCredentialSpi impersonate(GSSNameSpi name) throws GSSException {
         return cred.impersonate(name);
     }
+
+    public boolean isDefaultCredential() {
+        return cred.isDefaultCredential();
+    }
 }
--- old/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java	2019-10-21 14:15:13.736485299 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java	2019-10-21 14:15:13.740485249 -0500
@@ -34,6 +34,7 @@
 import sun.security.jgss.krb5.Krb5NameElement;
 import java.security.Provider;
 import java.util.Vector;
+import java.util.Map;
 
 /**
  * SpNego Mechanism plug in for JGSS
@@ -79,6 +80,10 @@
                                     null : creds.firstElement());
 
         // Force permission check before returning the cred to caller
+        //
+        // FIXME This code assumes that the Kerberos mechanism is Java-coded,
+        // whereas it should be possible to mix Java-coded SPNEGO with a native
+        // (C-coded) mechanism.  For now this assumption stands.
         if (result != null) {
             GSSCredentialSpi cred = result.getInternalCred();
             if (GSSUtil.isKerberosMech(cred.getMechanism())) {
@@ -149,6 +154,47 @@
         return credElement;
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+           String password, int initLifetime, int acceptLifetime,
+           int usage) throws GSSException {
+
+        SpNegoCredElement credElement = getCredFromSubject
+            (name, (usage != GSSCredential.ACCEPT_ONLY));
+
+        if (credElement == null) {
+            // get CredElement for the default Mechanism
+            credElement = new SpNegoCredElement
+                (manager.getCredentialElement(name, password, initLifetime,
+                acceptLifetime, null, usage));
+        }
+        return credElement;
+    }
+
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+           Map<String,String> store, int initLifetime, int acceptLifetime,
+           int usage) throws GSSException {
+
+        SpNegoCredElement credElement = getCredFromSubject
+            (name, (usage != GSSCredential.ACCEPT_ONLY));
+
+        if (credElement == null) {
+            // get CredElement for the default Mechanism
+            credElement = new SpNegoCredElement
+                (manager.getCredentialElement(name, store, initLifetime,
+                acceptLifetime, null, usage));
+        }
+        return credElement;
+    }
+
+    public void storeCredInto(GSSCredentialSpi cred, int usage,
+                              boolean overwrite, boolean defaultCred,
+                              Map<String,String> store) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "The SpNego mechanism does not " +
+                "currently support storing GSS credentials handle " +
+                "elements into a \"credential store\"");
+    }
+
     public GSSContextSpi getMechanismContext(GSSNameSpi peer,
                              GSSCredentialSpi myInitiatorCred, int lifetime)
         throws GSSException {
--- old/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java	2019-10-21 14:15:13.848483891 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java	2019-10-21 14:15:13.852483841 -0500
@@ -26,6 +26,9 @@
 
 import org.ietf.jgss.*;
 import java.security.Provider;
+import java.util.Map;
+import java.util.List;
+import java.util.ArrayList;
 import sun.security.jgss.GSSUtil;
 import sun.security.jgss.spi.GSSCredentialSpi;
 import sun.security.jgss.spi.GSSNameSpi;
@@ -42,9 +45,14 @@
     long pCred; // Pointer to the gss_cred_id_t structure
     private GSSNameElement name = null;
     private GSSLibStub cStub;
+    public boolean isDefCred;
 
     // Perform the necessary ServicePermission check on this cred
+    // FIXME Don't use any Krb5-specific code here.
     void doServicePermCheck() throws GSSException {
+        // FIXME We need only do this check in initSecContext() and
+        // acceptSecContext(), so gut this here, and never ever do the
+        // Krb5Util.getTGSName(name) check.
         if (GSSUtil.isKerberosMech(cStub.getMech())) {
             if (System.getSecurityManager() != null) {
                 if (isInitiatorCredential()) {
@@ -69,22 +77,49 @@
         name = srcName;
     }
 
-    GSSCredElement(GSSNameElement name, int lifetime, int usage,
-                   GSSLibStub stub) throws GSSException {
+    private GSSCredElement(GSSNameElement name, String password,
+                           Map<String,String> store, int lifetime, int usage,
+                           GSSLibStub stub) throws GSSException {
         cStub = stub;
         this.usage = usage;
 
         if (name != null) { // Could be GSSNameElement.DEF_ACCEPTOR
             this.name = name;
             doServicePermCheck();
-            pCred = cStub.acquireCred(this.name.pName, lifetime, usage);
+            pCred = cStub.acquireCred(this.name.pName, password, store,
+                lifetime, usage);
+            if (name == GSSNameElement.DEF_ACCEPTOR)
+                isDefCred = true;
         } else {
-            pCred = cStub.acquireCred(0, lifetime, usage);
-            this.name = new GSSNameElement(cStub.getCredName(pCred), cStub);
+            pCred = cStub.acquireCred(0, password, store, lifetime, usage);
+            this.name = new GSSNameElement(cStub.getCredName(pCred), cStub.getMech(), cStub);
             doServicePermCheck();
+            isDefCred = true;
         }
     }
 
+    GSSCredElement(GSSNameElement name, Map<String,String> store, int lifetime,
+                   int usage, GSSLibStub stub) throws GSSException {
+        this(name, (String)null, store, lifetime, usage, stub);
+    }
+
+    GSSCredElement(GSSNameElement name, String password, int lifetime,
+                   int usage, GSSLibStub stub) throws GSSException {
+        this(name, password, (Map<String,String>)null, lifetime, usage, stub);
+    }
+
+    GSSCredElement(GSSNameElement name, int lifetime, int usage,
+                   GSSLibStub stub) throws GSSException {
+        this(name, (String)null, lifetime, usage, stub);
+    }
+
+    public void storeInto(int usage, boolean overwrite, boolean defaultCred,
+                          Map<String,String> store)
+            throws GSSException {
+        cStub.storeCred(pCred, usage, getMechanism(), overwrite,
+                        defaultCred, store);
+    }
+
     public Provider getProvider() {
         return SunNativeProvider.INSTANCE;
     }
@@ -125,6 +160,10 @@
         return cStub.getMech();
     }
 
+    public boolean isDefaultCredential() {
+        return isDefCred;
+    }
+
     public String toString() {
         // No hex bytes available for native impl
         return "N/A";
--- old/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java	2019-10-21 14:15:13.968482383 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java	2019-10-21 14:15:13.972482333 -0500
@@ -25,6 +25,8 @@
 
 package sun.security.jgss.wrapper;
 
+import java.util.Map;
+import java.util.ArrayList;
 import java.util.Hashtable;
 import org.ietf.jgss.Oid;
 import org.ietf.jgss.GSSName;
@@ -65,11 +67,15 @@
     native boolean compareName(long pName1, long pName2);
     native long canonicalizeName(long pName);
     native byte[] exportName(long pName) throws GSSException;
+    native String localName(long pName, Oid mech) throws GSSException;
     native Object[] displayName(long pName) throws GSSException;
 
     // Credential related routines
-    native long acquireCred(long pName, int lifetime, int usage)
-                                        throws GSSException;
+    native long acquireCred(long pName, String password, String[] store,
+                            int lifetime, int usage) throws GSSException;
+    native long storeCred(long pCred, int usage, Oid mech,
+                          boolean overwrite, boolean defaultCred,
+                          String[] store) throws GSSException;
     native long releaseCred(long pCred);
     native long getCredName(long pCred);
     native int getCredTime(long pCred);
@@ -110,6 +116,27 @@
         this.mech = mech;
         this.pMech = getMechPtr(mech.getDER());
     }
+    private static String[] map2array(Map<String,String> m) {
+        if (m == null)
+            return null;
+        ArrayList<String> l = new ArrayList<String>();
+        for (var e : m.entrySet()) {
+            l.add(e.getKey());
+            l.add(e.getValue());
+        }
+        return l.toArray(new String[0]);
+    }
+    public long acquireCred(long pName, String password,
+                            Map<String,String> store,
+                            int lifetime, int usage) throws GSSException {
+        return acquireCred(pName, password, map2array(store), lifetime, usage);
+    }
+    public long storeCred(long pCred, int usage, Oid mech,
+                          boolean overwrite, boolean defaultCred,
+                          Map<String,String> store) throws GSSException {
+        return storeCred(pCred, usage, mech, overwrite, defaultCred,
+            map2array(store));
+    }
     public boolean equals(Object obj) {
         if (obj == this) return true;
         if (!(obj instanceof GSSLibStub)) {
--- old/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java	2019-10-21 14:15:14.080480975 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java	2019-10-21 14:15:14.084480925 -0500
@@ -53,6 +53,7 @@
     long pName = 0; // Pointer to the gss_name_t structure
     private String printableName;
     private Oid printableType;
+    private Oid mech;
     private GSSLibStub cStub;
 
     static final GSSNameElement DEF_ACCEPTOR = new GSSNameElement();
@@ -97,13 +98,14 @@
         printableName = "<DEFAULT ACCEPTOR>";
     }
 
-    GSSNameElement(long pNativeName, GSSLibStub stub) throws GSSException {
+    GSSNameElement(long pNativeName, Oid mech, GSSLibStub stub) throws GSSException {
         assert(stub != null);
         if (pNativeName == 0) {
             throw new GSSException(GSSException.BAD_NAME);
         }
         // Note: pNativeName is assumed to be a MN.
         pName = pNativeName;
+        this.mech = mech;
         cStub = stub;
         setPrintables();
     }
@@ -116,6 +118,7 @@
         }
         cStub = stub;
         byte[] name = nameBytes;
+        mech = cStub.getMech();
 
         if (nameType != null) {
             // Special handling the specified name type if
@@ -128,7 +131,6 @@
                 // method) for "NT_EXPORT_NAME"
                 byte[] mechBytes = null;
                 DerOutputStream dout = new DerOutputStream();
-                Oid mech = cStub.getMech();
                 try {
                     dout.putOID(new ObjectIdentifier(mech.toString()));
                 } catch (IOException e) {
@@ -195,7 +197,28 @@
     public String getKrbName() throws GSSException {
         long mName = 0;
         GSSLibStub stub = cStub;
-        if (!GSSUtil.isKerberosMech(cStub.getMech())) {
+        if (!GSSUtil.isKerberosMech(mech)) {
+            // XXX We can't expect this to work generally.  We should
+            // generalize the permission checks so that they can deal
+            // with name forms other than those of Kerberos.
+            //
+            // Alternatively we could have a method in GSSLibStub for
+            // mapping a non-Kerberos MN to a Kerberos MN, but depending
+            // on the specifics of the non-Kerberos mechanism we would
+            // either end up needing new conventions for Kerberos naming
+            // or else having cases where we can end up failing to
+            // support unconventional name forms.
+            //
+            // Consider a SAML assertion with a variety of identifying
+            // attributes and a variety of non-identifying attributes
+            // that are relevant to authorization.  How should a
+            // Kerberos-equivalent be constructed?  GSS does have
+            // extensions for decorating name objects with attributes,
+            // so that's not an issue, but if there are multiple
+            // identifying attributes then we'd have to pick one.  Now,
+            // suppose the identifying attribute has a form like
+            // <phone-number> -- we'd need a Kerberos convention for
+            // that, which might be PHONE/<number>@<ASSERTION-SIGNER>.
             stub = GSSLibStub.getInstance(GSSUtil.GSS_KRB5_MECH_OID);
         }
         mName = stub.canonicalizeName(pName);
@@ -267,13 +290,23 @@
     }
 
     public Oid getMechanism() {
-        return cStub.getMech();
+        return (mech != null) ? mech : cStub.getMech();
     }
 
     public String toString() {
         return printableName;
     }
 
+    public String getLocalName() throws GSSException {
+        return cStub.localName(pName, mech);
+    }
+
+    public String getLocalName(Oid mech) throws GSSException {
+        if (mech.equals(this.mech))
+            return cStub.localName(pName, mech);
+        throw new GSSException(GSSException.BAD_MECH);
+    }
+
     public Oid getStringNameType() {
         return printableType;
     }
@@ -282,6 +315,10 @@
         return (GSSName.NT_ANONYMOUS.equals(printableType));
     }
 
+    public boolean isDefaultCredentialName() {
+        return (this == DEF_ACCEPTOR);
+    }
+
     public void dispose() {
         if (pName != 0) {
             cStub.releaseName(pName);
--- old/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java	2019-10-21 14:15:14.212479315 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java	2019-10-21 14:15:14.216479265 -0500
@@ -75,8 +75,8 @@
     private int lifetime = GSSCredential.DEFAULT_LIFETIME;
     private final GSSLibStub cStub;
 
-    private boolean skipDelegPermCheck;
-    private boolean skipServicePermCheck;
+    private boolean skipDelegPermCheck = false;
+    private boolean skipServicePermCheck = false;
 
     // Retrieve the (preferred) mech out of SPNEGO tokens, i.e.
     // NegTokenInit & NegTokenTarg
@@ -111,26 +111,20 @@
     // Perform the Service permission check
     private void doServicePermCheck() throws GSSException {
         if (System.getSecurityManager() != null) {
-            String action = (isInitiator? "initiate" : "accept");
-            // Need to check Service permission for accessing
-            // initiator cred for SPNEGO during context establishment
-            if (GSSUtil.isSpNegoMech(cStub.getMech()) && isInitiator
-                && !isEstablished) {
-                if (srcName == null) {
-                    // Check by creating default initiator KRB5 cred
-                    GSSCredElement tempCred =
-                        new GSSCredElement(null, lifetime,
-                                           GSSCredential.INITIATE_ONLY,
-                                           GSSLibStub.getInstance(GSSUtil.GSS_KRB5_MECH_OID));
-                    tempCred.dispose();
-                } else {
+            try {
+                if (isInitiator && srcName != null) {
                     String tgsName = Krb5Util.getTGSName(srcName);
-                    Krb5Util.checkServicePermission(tgsName, action);
+                    Krb5Util.checkServicePermission(tgsName, "initiate");
+                    skipServicePermCheck = true;
+                } else if (!isInitiator && targetName != null) {
+                    String targetStr = targetName.getKrbName();
+                    Krb5Util.checkServicePermission(targetStr, "accept");
+                    skipServicePermCheck = true;
                 }
+            } catch (GSSException ge) {
+                dispose();
+                throw ge;
             }
-            String targetStr = targetName.getKrbName();
-            Krb5Util.checkServicePermission(targetStr, action);
-            skipServicePermCheck = true;
         }
     }
 
@@ -138,6 +132,8 @@
     private void doDelegPermCheck() throws GSSException {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
+            if (targetName == null)
+                return;
             String targetStr = targetName.getKrbName();
             String tgsStr = Krb5Util.getTGSName(targetName);
             StringBuilder sb = new StringBuilder("\"");
@@ -200,13 +196,13 @@
         lifetime = time;
 
         if (GSSUtil.isKerberosMech(cStub.getMech())) {
-            doServicePermCheck();
             if (cred == null) {
                 disposeCred = cred =
                     new GSSCredElement(null, lifetime,
                             GSSCredential.INITIATE_ONLY, cStub);
             }
             srcName = cred.getName();
+            doServicePermCheck();
         }
     }
 
@@ -241,15 +237,22 @@
         if (info.length != NUM_OF_INQUIRE_VALUES) {
             throw new RuntimeException("Bug w/ GSSLibStub.inquireContext()");
         }
-        srcName = new GSSNameElement(info[0], cStub);
-        targetName = new GSSNameElement(info[1], cStub);
         isInitiator = (info[2] != 0);
         isEstablished = (info[3] != 0);
         flags = (int) info[4];
         lifetime = (int) info[5];
+        if (isEstablished) {
+            srcName = new GSSNameElement(info[0], actualMech, cStub);
+            targetName = new GSSNameElement(info[1], actualMech, cStub);
+        } else {
+            srcName = null;
+            targetName = null;
+        }
 
         // Do Service Permission check when importing SPNEGO context
-        // just to be safe
+        // just to be safe.  WAT, no.  If the caller has an exported sec
+        // context token, it's because someone gave it to it, therefore there's
+        // no need to do any further permission checking.  REMOVE!
         Oid mech = cStub.getMech();
         if (GSSUtil.isSpNegoMech(mech) || GSSUtil.isKerberosMech(mech)) {
             doServicePermCheck();
@@ -286,26 +289,40 @@
 
             // Only inspect the token when the permission check
             // has not been performed
-            if (GSSUtil.isSpNegoMech(cStub.getMech()) && outToken != null) {
+            if (!GSSUtil.isSpNegoMech(cStub.getMech())) {
+                actualMech = cStub.getMech();
+            } else if (actualMech == null && outToken != null) {
                 // WORKAROUND for SEAM bug#6287358
-                actualMech = getMechFromSpNegoToken(outToken, true);
-
-                if (GSSUtil.isKerberosMech(actualMech)) {
-                    if (!skipServicePermCheck) doServicePermCheck();
-                    if (!skipDelegPermCheck) doDelegPermCheck();
-                }
+                //
+                // This is where some C GSS SPNEGO implementations fail to make
+                // the real actual mechanism available.
+                // getMechFromSpNegoToken() does the horrible, no good, very
+                // bad thing its name says it does.  For now we retain this bit
+                // of evil.
+                //
+                // XXX Time to remove this workaround.  It's been 20
+                // years.
+                try {
+                    actualMech = getMechFromSpNegoToken(outToken, true);
+                } catch (GSSException e) { }
+            }
+
+            if (actualMech != null && GSSUtil.isKerberosMech(actualMech)) {
+                if (!skipServicePermCheck) doServicePermCheck();
+                if (!skipDelegPermCheck) doDelegPermCheck();
             }
 
             if (isEstablished) {
+                // XXX We should attempt to get actualMech from the cStub here,
+                // and take it even if we got a semblance of an actualMech from
+                // the SPNEGO token, as long as the one returned by the cStub
+                // isn't the SPNEGO OID.
                 if (srcName == null) {
                     srcName = new GSSNameElement
-                        (cStub.getContextName(pContext, true), cStub);
-                }
-                if (cred == null) {
-                    disposeCred = cred =
-                        new GSSCredElement(srcName, lifetime,
-                                GSSCredential.INITIATE_ONLY, cStub);
+                        (cStub.getContextName(pContext, true), actualMech,
+                         cStub);
                 }
+                if (!skipServicePermCheck) doServicePermCheck();
             }
         }
         return outToken;
@@ -324,27 +341,18 @@
             SunNativeProvider.debug("acceptSecContext=> outToken len=" +
                                     (outToken == null? 0 : outToken.length));
 
-            if (targetName == null) {
+            if (isEstablished && targetName == null) {
                 targetName = new GSSNameElement
-                    (cStub.getContextName(pContext, false), cStub);
-                // Replace the current default acceptor cred now that
-                // the context acceptor name is available
-                if (disposeCred != null) {
-                    disposeCred.dispose();
-                }
-                disposeCred = cred =
-                    new GSSCredElement(targetName, lifetime,
-                            GSSCredential.ACCEPT_ONLY, cStub);
+                    (cStub.getContextName(pContext, false), actualMech, cStub);
             }
-
-            // Only inspect token when the permission check has not
-            // been performed
-            if (GSSUtil.isSpNegoMech(cStub.getMech()) &&
-                (outToken != null) && !skipServicePermCheck) {
-                if (GSSUtil.isKerberosMech(getMechFromSpNegoToken
-                                           (outToken, false))) {
-                    doServicePermCheck();
-                }
+            if (GSSUtil.isSpNegoMech(cStub.getMech()) && outToken != null &&
+                actualMech == null) {
+                try {
+                    actualMech = getMechFromSpNegoToken(outToken, true);
+                } catch (GSSException e) { }
+            }
+            if (isEstablished && targetName != null && !skipServicePermCheck) {
+                doServicePermCheck();
             }
         }
         return outToken;
--- old/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java	2019-10-21 14:15:14.344477656 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java	2019-10-21 14:15:14.352477555 -0500
@@ -27,6 +27,7 @@
 
 import java.io.UnsupportedEncodingException;
 import java.security.Provider;
+import java.util.Map;
 import java.util.Vector;
 import org.ietf.jgss.*;
 import sun.security.jgss.GSSUtil;
@@ -96,6 +97,7 @@
     }
 
     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 String password,
                                                  int initLifetime,
                                                  int acceptLifetime,
                                                  int usage)
@@ -118,14 +120,78 @@
         if (credElement == null) {
             // No cred in the Subject
             if (usage == GSSCredential.INITIATE_ONLY) {
-                credElement = new GSSCredElement(nname, initLifetime,
-                                                 usage, cStub);
+                if (password == null) {
+                    credElement = new GSSCredElement(nname, initLifetime,
+                                                     usage, cStub);
+                } else {
+                    credElement = new GSSCredElement(nname, password,
+                                                     initLifetime,
+                                                     usage, cStub);
+                }
+            } else if (usage == GSSCredential.ACCEPT_ONLY) {
+                if (nname == null) {
+                    nname = GSSNameElement.DEF_ACCEPTOR;
+                }
+                if (password == null) {
+                    credElement = new GSSCredElement(nname, acceptLifetime,
+                                                     usage, cStub);
+                } else {
+                    credElement = new GSSCredElement(nname, password,
+                                                     acceptLifetime,
+                                                     usage, cStub);
+                }
+            } else {
+                throw new GSSException(GSSException.FAILURE, -1,
+                                       "Unknown usage mode requested");
+            }
+        }
+        return credElement;
+    }
+
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 Map<String,String> store,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 int usage)
+        throws GSSException {
+        GSSNameElement nname = null;
+        if (name != null && !(name instanceof GSSNameElement)) {
+            nname = (GSSNameElement)
+                getNameElement(name.toString(), name.getStringNameType());
+        } else nname = (GSSNameElement) name;
+
+        if (usage == GSSCredential.INITIATE_AND_ACCEPT) {
+            // Force separate acqusition of cred element since
+            // MIT's impl does not correctly report NO_CRED error.
+            usage = GSSCredential.INITIATE_ONLY;
+        }
+
+        GSSCredElement credElement =
+            getCredFromSubject(nname, (usage == GSSCredential.INITIATE_ONLY));
+
+        if (credElement == null) {
+            // No cred in the Subject
+            if (usage == GSSCredential.INITIATE_ONLY) {
+                if (store == null) {
+                    credElement = new GSSCredElement(nname, initLifetime,
+                                                     usage, cStub);
+                } else {
+                    credElement = new GSSCredElement(nname, store,
+                                                     initLifetime,
+                                                     usage, cStub);
+                }
             } else if (usage == GSSCredential.ACCEPT_ONLY) {
                 if (nname == null) {
                     nname = GSSNameElement.DEF_ACCEPTOR;
                 }
-                credElement = new GSSCredElement(nname, acceptLifetime,
-                                                 usage, cStub);
+                if (store == null) {
+                    credElement = new GSSCredElement(nname, acceptLifetime,
+                                                     usage, cStub);
+                } else {
+                    credElement = new GSSCredElement(nname, store,
+                                                     acceptLifetime,
+                                                     usage, cStub);
+                }
             } else {
                 throw new GSSException(GSSException.FAILURE, -1,
                                        "Unknown usage mode requested");
@@ -134,6 +200,15 @@
         return credElement;
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 int usage)
+        throws GSSException {
+        return getCredentialElement(name, (String)null, initLifetime,
+                                    acceptLifetime, usage);
+    }
+
     public GSSContextSpi getMechanismContext(GSSNameSpi peer,
                                              GSSCredentialSpi myCred,
                                              int lifetime)
--- old/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java	2019-10-21 14:15:14.472476047 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java	2019-10-21 14:15:14.476475997 -0500
@@ -109,7 +109,14 @@
                             if (GSSLibStub.init(libName, DEBUG)) {
                                 debug("Loaded GSS library: " + libName);
                                 Oid[] mechs = GSSLibStub.indicateMechs();
-                                HashMap<String,String> map = new HashMap<>();
+                                HashMap<String, String> map =
+                                            new HashMap<String, String>();
+                                // If the GSSLibStub does not support SPNEGO,
+                                // we could use ours, but ours has too much
+                                // knowledge of the Java Krb5 GSS mechanism, so
+                                // we can't, but if we could we'd do it thusly:
+                                //   map.put("GssApiMechanism.1.3.6.1.5.5.2",
+                                //           "sun.security.jgss.spnego.SpNegoMechFactory");
                                 for (int i = 0; i < mechs.length; i++) {
                                     debug("Native MF for " + mechs[i]);
                                     map.put("GssApiMechanism." + mechs[i],
--- old/src/java.security.jgss/share/classes/sun/security/krb5/KrbAsReqBuilder.java	2019-10-21 14:15:14.588474589 -0500
+++ new/src/java.security.jgss/share/classes/sun/security/krb5/KrbAsReqBuilder.java	2019-10-21 14:15:14.592474538 -0500
@@ -473,6 +473,9 @@
         }
     }
 
+    // XXX It'd be nice to implement AutoCloseable with a close() that calls
+    // destroy()
+
     /**
      * Checks if the current state is the specified one.
      * @param st the expected state
--- old/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c	2019-10-21 14:15:14.700473180 -0500
+++ new/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c	2019-10-21 14:15:14.708473080 -0500
@@ -149,21 +149,20 @@
  * Utility routine which releases the specified gss_channel_bindings_t
  * structure.
  */
-void deleteGSSCB(gss_channel_bindings_t cb) {
-
+static void deleteGSSCB(JNIEnv *env, gss_channel_bindings_t cb) {
   if (cb == GSS_C_NO_CHANNEL_BINDINGS) return;
 
   /* release initiator address */
   if (cb->initiator_addrtype != GSS_C_AF_NULLADDR) {
-    resetGSSBuffer(&(cb->initiator_address));
+    resetGSSBuffer(env, NULL, &(cb->initiator_address));
   }
   /* release acceptor address */
   if (cb->acceptor_addrtype != GSS_C_AF_NULLADDR) {
-    resetGSSBuffer(&(cb->acceptor_address));
+    resetGSSBuffer(env, NULL, &(cb->acceptor_address));
   }
   /* release application data */
-  if (cb->application_data.length != 0) {
-    resetGSSBuffer(&(cb->application_data));
+  if (cb->application_data.value != NULL) {
+    resetGSSBuffer(env, NULL, &(cb->application_data));
   }
   free(cb);
 }
@@ -188,9 +187,11 @@
     return NULL;
   }
 
-  // initialize addrtype in CB first
+  /* Fully initialize to a state safe for cleanup */
   cb->initiator_addrtype = GSS_C_AF_NULLADDR;
   cb->acceptor_addrtype = GSS_C_AF_NULLADDR;
+  cb->application_data.length = 0;
+  cb->application_data.value = NULL;
 
   // addresses needs to be initialized to empty
   memset(&cb->initiator_address, 0, sizeof(cb->initiator_address));
@@ -208,11 +209,11 @@
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
-    cb->initiator_addrtype = GSS_C_AF_INET;
-    initGSSBuffer(env, value, &(cb->initiator_address));
+    initGSSBuffer(env, value, &(cb->initiator_address), JNI_TRUE);
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
+    cb->initiator_addrtype = GSS_C_AF_INET;
   }
   /* set up acceptor address */
   jinetAddr = (*env)->CallObjectMethod(env, jcb,
@@ -226,11 +227,11 @@
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
-    cb->acceptor_addrtype = GSS_C_AF_INET;
-    initGSSBuffer(env, value, &(cb->acceptor_address));
+    initGSSBuffer(env, value, &(cb->acceptor_address), JNI_TRUE);
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
+    cb->acceptor_addrtype = GSS_C_AF_INET;
   }
   /* set up application data */
   value = (*env)->CallObjectMethod(env, jcb,
@@ -238,13 +239,13 @@
   if ((*env)->ExceptionCheck(env)) {
     goto cleanup;
   }
-  initGSSBuffer(env, value, &(cb->application_data));
+  initGSSBuffer(env, value, &(cb->application_data), JNI_TRUE);
   if ((*env)->ExceptionCheck(env)) {
     goto cleanup;
   }
   return cb;
 cleanup:
-  deleteGSSCB(cb);
+  deleteGSSCB(env, cb);
   return NULL;
 }
 
@@ -295,7 +296,7 @@
 Java_sun_security_jgss_wrapper_GSSLibStub_inquireNamesForMech(JNIEnv *env,
                                                               jobject jobj)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_OID mech;
   gss_OID_set nameTypes;
   jobjectArray result;
@@ -309,7 +310,7 @@
 
     /* release intermediate buffers before checking status */
     result = getJavaOIDArray(env, nameTypes);
-    deleteGSSOIDSet(nameTypes);
+    (*ftab->releaseOidSet)(&dummy, &nameTypes);
     if ((*env)->ExceptionCheck(env)) {
       return NULL;
     }
@@ -366,14 +367,14 @@
 
   TRACE0("[GSSLibStub_importName]");
 
-  initGSSBuffer(env, jnameVal, &nameVal);
+  initGSSBuffer(env, jnameVal, &nameVal, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
       return jlong_zero;
   }
 
   nameType = newGSSOID(env, jnameType);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&nameVal);
+    resetGSSBuffer(env, jnameVal, &nameVal);
     return jlong_zero;
   }
 
@@ -385,7 +386,7 @@
 
   /* release intermediate buffers */
   deleteGSSOID(nameType);
-  resetGSSBuffer(&nameVal);
+  resetGSSBuffer(env, jnameVal, &nameVal);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_importName]");
   if ((*env)->ExceptionCheck(env)) {
@@ -472,10 +473,9 @@
 Java_sun_security_jgss_wrapper_GSSLibStub_exportName(JNIEnv *env,
                                                      jobject jobj,
                                                      jlong pName) {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_name_t nameHdl, mNameHdl;
-  gss_buffer_desc outBuf;
-  jbyteArray jresult;
+  gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;
 
   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 
@@ -500,26 +500,79 @@
     }
 
     major = (*ftab->exportName)(&minor, mNameHdl, &outBuf);
-    Java_sun_security_jgss_wrapper_GSSLibStub_releaseName
-                                        (env, jobj, ptr_to_jlong(mNameHdl));
-    if ((*env)->ExceptionCheck(env)) {
-      /* release intermediate buffers */
-      (*ftab->releaseBuffer)(&minor, &outBuf);
-      return NULL;
-    }
+    (void) (*ftab->releaseName)(&dummy, &mNameHdl);
   }
 
-  /* release intermediate buffers before checking status */
-  jresult = getJavaBuffer(env, &outBuf);
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_exportName]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outBuf);
     return NULL;
   }
+  /* Map outBuf to byteArray result and release */
+  return getJavaBuffer(env, &outBuf, JNI_TRUE);
+}
 
-  checkStatus(env, jobj, major, minor, "[GSSLibStub_exportName]");
-  if ((*env)->ExceptionCheck(env)) {
+/*
+ * Class:     sun_security_jgss_wrapper_GSSLibStub
+ * Method:    localName
+ * Signature: (J)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_sun_security_jgss_wrapper_GSSLibStub_localName(JNIEnv *env,
+                                                    jobject jobj,
+                                                    jlong pName,
+                                                    jobject jOid)
+{
+  OM_uint32 minor, major, dummy;
+  gss_name_t nameHdl, mnNameHdl;
+  gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;
+  gss_OID mech;
+
+  nameHdl = (gss_name_t) jlong_to_ptr(pName);
+
+  if (ftab->localName == NULL) {
+    TRACE0("GSSLibStub_localName not supported by GSS provider");
+    checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,
+                "[GSSLibStub_localName]");
     return NULL;
   }
-  return jresult;
+  mech = newGSSOID(env, jOid);
+
+  /* gss_localname(...) => GSS_S_NAME_NOT_MN, GSS_S_BAD_NAMETYPE,
+     GSS_S_BAD_NAME */
+  major = (*ftab->localName)(&minor, nameHdl, mech, &outBuf);
+  if (major == GSS_S_COMPLETE) {
+    deleteGSSOID(mech);
+    return getJavaString(env, &outBuf);
+  }
+  (*ftab->releaseBuffer)(&minor, &outBuf);
+
+  if (major != GSS_S_NAME_NOT_MN) {
+    checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+    goto err;
+  }
+
+  /* canonicalize the internal name to MN and retry */
+  TRACE0("[GSSLibStub_localName] canonicalize and re-try");
+
+  major = (*ftab->canonicalizeName)(&minor, nameHdl, mech, &mnNameHdl);
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+  if ((*env)->ExceptionCheck(env))
+    goto err;
+
+  major = (*ftab->localName)(&minor, mnNameHdl, mech, &outBuf);
+  (void) (*ftab->releaseName)(&dummy, &mnNameHdl);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+  if ((*env)->ExceptionCheck(env) == JNI_FALSE && major == GSS_S_COMPLETE) {
+    deleteGSSOID(mech);
+    return getJavaString(env, &outBuf);
+  }
+  (*ftab->releaseBuffer)(&minor, &outBuf);
+
+err:
+  deleteGSSOID(mech);
+  return NULL;
 }
 
 /*
@@ -533,7 +586,7 @@
                                                       jlong pName) {
   OM_uint32 minor, major;
   gss_name_t nameHdl;
-  gss_buffer_desc outNameBuf;
+  gss_buffer_desc outNameBuf = GSS_C_EMPTY_BUFFER;
   gss_OID outNameType;
   jstring jname;
   jobject jtype;
@@ -588,17 +641,20 @@
 /*
  * Class:     sun_security_jgss_wrapper_GSSLibStub
  * Method:    acquireCred
- * Signature: (JII)J
+ * Signature: (JLjava/lang/String;[II)J
  */
 JNIEXPORT jlong JNICALL
 Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
                                                       jobject jobj,
                                                       jlong pName,
+                                                      jstring jPassword,
+                                                      jarray jCredStore,
                                                       jint reqTime,
                                                       jint usage)
 {
   OM_uint32 minor, major;
   gss_OID mech;
+  gss_OID_set_desc singleton;
   gss_OID_set mechs;
   gss_cred_usage_t credUsage;
   gss_name_t nameHdl;
@@ -608,7 +664,7 @@
   TRACE0("[GSSLibStub_acquireCred]");
 
   mech = (gss_OID) jlong_to_ptr((*env)->GetLongField(env, jobj, FID_GSSLibStub_pMech));
-  mechs = newGSSOIDSet(mech);
+  mechs = makeGSSOIDSet(&singleton, mech);
   credUsage = (gss_cred_usage_t) usage;
   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 
@@ -616,11 +672,52 @@
 
   /* gss_acquire_cred(...) => GSS_S_BAD_MECH, GSS_S_BAD_NAMETYPE,
      GSS_S_BAD_NAME, GSS_S_CREDENTIALS_EXPIRED, GSS_S_NO_CRED */
-  major =
-    (*ftab->acquireCred)(&minor, nameHdl, reqTime, mechs,
-                     credUsage, &credHdl, NULL, NULL);
-  /* release intermediate buffers */
-  deleteGSSOIDSet(mechs);
+  if (jPassword == NULL && jCredStore == NULL) {
+    major = (*ftab->acquireCred)(&minor, nameHdl, reqTime, mechs, credUsage,
+                                 &credHdl, NULL, NULL);
+  } else if (jPassword != NULL) {
+    gss_buffer_desc password;
+
+    if (ftab->acquireCredWithPassword == NULL) {
+      const char *msg = "GSSLibStub_acquireCred with password not supported "
+          "by GSS provider";
+
+      TRACE0(msg);
+      checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, msg);
+      return ptr_to_jlong(NULL);
+    }
+
+    initGSSBufferString(env, jPassword, &password);
+    if ((*env)->ExceptionCheck(env)) {
+      return jlong_zero;
+    }
+    major = (*ftab->acquireCredWithPassword)(&minor, nameHdl, &password,
+                                             reqTime, mechs, credUsage,
+                                             &credHdl, NULL, NULL);
+    resetGSSBufferString(env, jPassword, &password);
+  } else {
+    gss_key_value_set_desc credStore = {0, 0};
+
+    if (ftab->acquireCredFrom == NULL) {
+      const char *msg = "GSSLibStub_acquireCred from credential store not "
+          "supported by GSS provider";
+
+      TRACE0("[GSSLibStub_acquireCred] acquiring from a specific credential "
+             "store not supported by GSS provider");
+      checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,
+                  "[GSSLibStub_acquireCred]");
+      return ptr_to_jlong(NULL);
+    }
+
+    initGSSCredStore(env, jCredStore, &credStore);
+    if ((*env)->ExceptionCheck(env)) {
+      return jlong_zero;
+    }
+    major = (*ftab->acquireCredFrom)(&minor, nameHdl, reqTime, mechs,
+                                     credUsage, &credStore, &credHdl,
+                                     NULL, NULL);
+    resetGSSCredStore(env, jCredStore, &credStore);
+  }
 
   TRACE1("[GSSLibStub_acquireCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
 
@@ -633,6 +730,64 @@
 
 /*
  * Class:     sun_security_jgss_wrapper_GSSLibStub
+ * Method:    storeCred
+ * Signature: (JILorg/ietf/jgss/Oid;ZZ[)J
+ */
+JNIEXPORT jlong JNICALL
+Java_sun_security_jgss_wrapper_GSSLibStub_storeCred(JNIEnv *env,
+                                                    jobject jobj,
+                                                    jlong pCred,
+                                                    jint usage,
+                                                    jobject jmech,
+                                                    jboolean overwrite,
+                                                    jboolean defaultCred,
+                                                    jarray jCredStore)
+{
+  OM_uint32 minor, major;
+  gss_key_value_set_desc credStore;
+  gss_cred_usage_t credUsage;
+  gss_cred_id_t credHdl;
+  gss_OID mech;
+
+  TRACE0("[GSSLibStub_storeCred]");
+
+  credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
+  credUsage = (gss_cred_usage_t) usage;
+
+  mech = newGSSOID(env, jmech);
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+
+  TRACE2("[GSSLibStub_storeCred] pCred=%ld, usage=%d", (long)pCred, usage);
+
+  if (ftab->storeCredInto == NULL) {
+    TRACE0("[GSSLibStub_storeCred] GSSLibStub_storeCred not supported by "
+           "GSS provider");
+    checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, "[GSSLibStub_storeCred]");
+    return ptr_to_jlong(NULL);
+  }
+
+  initGSSCredStore(env, jCredStore, &credStore);
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+  major = (*ftab->storeCredInto)(&minor, credHdl, credUsage, mech,
+                                 overwrite, defaultCred, &credStore,
+                                 NULL, NULL);
+  resetGSSCredStore(env, jCredStore, &credStore);
+
+  TRACE1("[GSSLibStub_storeCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_storeCred]");
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+  return ptr_to_jlong(credHdl);
+}
+
+/*
+ * Class:     sun_security_jgss_wrapper_GSSLibStub
  * Method:    releaseCred
  * Signature: (J)J
  */
@@ -792,7 +947,7 @@
   TRACE0("[GSSLibStub_importContext]");
 
   contextHdl = GSS_C_NO_CONTEXT;
-  initGSSBuffer(env, jctxtToken, &ctxtToken);
+  initGSSBuffer(env, jctxtToken, &ctxtToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -804,7 +959,7 @@
   TRACE1("[GSSLibStub_importContext] pContext=%" PRIuPTR "", (uintptr_t) contextHdl);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&ctxtToken);
+  resetGSSBuffer(env, jctxtToken, &ctxtToken);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext]");
   /* return immediately if an exception has occurred */
@@ -834,7 +989,7 @@
   } else {
     /* mech mismatch - clean up then return null */
     major = (*ftab->deleteSecContext)(&minor, &contextHdl, GSS_C_NO_BUFFER);
-    checkStatus(env, jobj, major, minor,
+    checkStatus(env, jobj, GSS_S_FAILURE, minor,
         "[GSSLibStub_importContext] cleanup");
     return NULL;
   }
@@ -854,7 +1009,7 @@
                                                       jbyteArray jinToken,
                                                       jobject jcontextSpi)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_cred_id_t credHdl ;
   gss_ctx_id_t contextHdl, contextHdlSave;
   gss_name_t targetName;
@@ -863,12 +1018,9 @@
   OM_uint32 time, aTime;
   gss_channel_bindings_t cb;
   gss_buffer_desc inToken;
-  gss_buffer_desc outToken;
-  jbyteArray jresult;
-/* UNCOMMENT after SEAM bug#6287358 is backported to S10
+  gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
   gss_OID aMech;
   jobject jMech;
-*/
 
   TRACE0("[GSSLibStub_initContext]");
 
@@ -886,9 +1038,9 @@
     return NULL;
   }
 
-  initGSSBuffer(env, jinToken, &inToken);
+  initGSSBuffer(env, jinToken, &inToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
-    deleteGSSCB(cb);
+    deleteGSSCB(env, cb);
     return NULL;
   }
 
@@ -902,7 +1054,7 @@
      GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME(!), GSS_S_BAD_MECH */
   major = (*ftab->initSecContext)(&minor, credHdl,
                                  &contextHdl, targetName, mech,
-                                 flags, time, cb, &inToken, NULL /*aMech*/,
+                                 flags, time, cb, &inToken, &aMech,
                                  &outToken, &aFlags, &aTime);
 
   TRACE2("[GSSLibStub_initContext] after: pContext=%" PRIuPTR ", outToken len=%ld",
@@ -931,30 +1083,28 @@
                               FID_NativeGSSContext_isEstablished,
                               JNI_TRUE);
 
-/* UNCOMMENT after SEAM bug#6287358 is backported to S10
-      jMech = getJavaOID(env, aMech);
-      (*env)->SetObjectField(env, jcontextSpi,
-                             FID_NativeGSSContext_actualMech, jMech);
-*/
+      jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);
+      if (!(*env)->ExceptionCheck(env)) {
+        (*env)->SetObjectField(env, jcontextSpi,
+                               FID_NativeGSSContext_actualMech, jMech);
+      }
     } else if (major & GSS_S_CONTINUE_NEEDED) {
       TRACE0("[GSSLibStub_initContext] context not established");
-      major -= GSS_S_CONTINUE_NEEDED;
+      major &= ~GSS_S_CONTINUE_NEEDED;
     }
   }
 
   /* release intermediate buffers before checking status */
-  deleteGSSCB(cb);
-  resetGSSBuffer(&inToken);
-  jresult = getJavaBuffer(env, &outToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
+  deleteGSSCB(env, cb);
+  resetGSSBuffer(env, jinToken, &inToken);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_initContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outToken);
     return NULL;
   }
-  return jresult;
+  /* Map outToken to byteArray result and release */
+  return getJavaBuffer(env, &outToken, JNI_TRUE);
 }
 
 /*
@@ -970,23 +1120,23 @@
                                                         jbyteArray jinToken,
                                                         jobject jcontextSpi)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   OM_uint32 minor2, major2;
   gss_ctx_id_t contextHdl, contextHdlSave;
   gss_cred_id_t credHdl;
   gss_buffer_desc inToken;
   gss_channel_bindings_t cb;
-  gss_name_t srcName;
-  gss_buffer_desc outToken;
+  gss_name_t srcName = GSS_C_NO_NAME;
+  gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
   gss_OID aMech;
   OM_uint32 aFlags;
   OM_uint32 aTime;
-  gss_cred_id_t delCred;
+  gss_cred_id_t delCred = GSS_C_NO_CREDENTIAL;
   jobject jsrcName = NULL;
   jobject jdelCred;
-  jobject jMech;
+  jobject jMech = NULL;
   jboolean setTarget;
-  gss_name_t targetName;
+  gss_name_t targetName = GSS_C_NO_NAME;
   jobject jtargetName;
 
   TRACE0("[GSSLibStub_acceptContext]");
@@ -994,17 +1144,15 @@
   contextHdl = contextHdlSave = (gss_ctx_id_t)jlong_to_ptr(
     (*env)->GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
-  initGSSBuffer(env, jinToken, &inToken);
+  initGSSBuffer(env, jinToken, &inToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
   cb = newGSSCB(env, jcb);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&inToken);
+    resetGSSBuffer(env, jinToken, &inToken);
     return NULL;
   }
-  srcName = targetName = GSS_C_NO_NAME;
-  delCred = GSS_C_NO_CREDENTIAL;
   setTarget = (credHdl == GSS_C_NO_CREDENTIAL);
   aFlags = 0;
 
@@ -1022,8 +1170,8 @@
                            &aFlags, &aTime, &delCred);
   /* release intermediate buffers before checking status */
 
-  deleteGSSCB(cb);
-  resetGSSBuffer(&inToken);
+  deleteGSSCB(env, cb);
+  resetGSSBuffer(env, jinToken, &inToken);
 
   TRACE3("[GSSLibStub_acceptContext] after: pCred=%" PRIuPTR ", pContext=%" PRIuPTR ", pDelegCred=%" PRIuPTR "",
         (uintptr_t)credHdl, (uintptr_t)contextHdl, (uintptr_t) delCred);
@@ -1039,9 +1187,19 @@
 
   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
     /* update member values if needed */
-    // WORKAROUND for a Heimdal bug
+
+    jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);
+    if (!(*env)->ExceptionCheck(env)) {
+      (*env)->SetObjectField(env, jcontextSpi,
+                             FID_NativeGSSContext_actualMech, jMech);
+    }
+    if ((*env)->ExceptionCheck(env)) {
+      goto error;
+    }
+
+    /* WORKAROUND for an old Heimdal bug */
     if (delCred == GSS_C_NO_CREDENTIAL) {
-        aFlags &= 0xfffffffe;
+        aFlags &= ~GSS_C_DELEG_FLAG;
     }
     (*env)->SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
     TRACE1("[GSSLibStub_acceptContext] set flags=0x%x", aFlags);
@@ -1058,13 +1216,14 @@
 
       jtargetName = (*env)->NewObject(env, CLS_GSSNameElement,
                                 MID_GSSNameElement_ctor,
-                                ptr_to_jlong(targetName), jobj);
+                                ptr_to_jlong(targetName), jMech, jobj);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
 
       TRACE1("[GSSLibStub_acceptContext] set targetName=%" PRIuPTR "",
               (uintptr_t)targetName);
+      targetName = GSS_C_NO_NAME;
 
       (*env)->SetObjectField(env, jcontextSpi, FID_NativeGSSContext_targetName,
                              jtargetName);
@@ -1075,12 +1234,13 @@
     if (srcName != GSS_C_NO_NAME) {
       jsrcName = (*env)->NewObject(env, CLS_GSSNameElement,
                                    MID_GSSNameElement_ctor,
-                                   ptr_to_jlong(srcName), jobj);
+                                   ptr_to_jlong(srcName), jMech, jobj);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
 
       TRACE1("[GSSLibStub_acceptContext] set srcName=%" PRIuPTR "", (uintptr_t)srcName);
+      srcName = GSS_C_NO_NAME;
 
       (*env)->SetObjectField(env, jcontextSpi, FID_NativeGSSContext_srcName,
                              jsrcName);
@@ -1096,12 +1256,6 @@
       (*env)->SetBooleanField(env, jcontextSpi,
                               FID_NativeGSSContext_isEstablished,
                               JNI_TRUE);
-      jMech = getJavaOID(env, aMech);
-      if ((*env)->ExceptionCheck(env)) {
-        goto error;
-      }
-      (*env)->SetObjectField(env, jcontextSpi,
-                             FID_NativeGSSContext_actualMech, jMech);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
@@ -1112,11 +1266,12 @@
         if ((*env)->ExceptionCheck(env)) {
           goto error;
         }
+        TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",
+                (uintptr_t) delCred);
+        delCred = GSS_C_NO_CREDENTIAL;
         (*env)->SetObjectField(env, jcontextSpi,
                                FID_NativeGSSContext_delegatedCred,
                                jdelCred);
-        TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",
-                (uintptr_t) delCred);
 
         if ((*env)->ExceptionCheck(env)) {
           goto error;
@@ -1129,10 +1284,18 @@
         (*env)->SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
                             getJavaTime(aTime));
       }
-      major -= GSS_S_CONTINUE_NEEDED;
+      major &= ~GSS_S_CONTINUE_NEEDED;
     }
   }
-  return getJavaBuffer(env, &outToken);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_acceptContext]");
+  if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outToken);
+    return NULL;
+  }
+
+  /* Map outToken to byteArray result and release */
+  return getJavaBuffer(env, &outToken, JNI_TRUE);
 
 error:
   (*ftab->releaseBuffer)(&minor, &outToken);
@@ -1158,12 +1321,14 @@
                                                          jobject jobj,
                                                          jlong pContext)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
-  gss_name_t srcName, targetName;
-  OM_uint32 time;
-  OM_uint32 flags;
-  int isInitiator, isEstablished;
+  gss_name_t srcName = GSS_C_NO_NAME;
+  gss_name_t targetName = GSS_C_NO_NAME;
+  OM_uint32 time = 0;
+  OM_uint32 flags = 0;
+  int isInitiator = 0;
+  int isEstablished = 0;
   jlong result[6];
   jlongArray jresult;
 
@@ -1171,10 +1336,6 @@
 
   TRACE1("[GSSLibStub_inquireContext] %" PRIuPTR "", (uintptr_t)contextHdl);
 
-  srcName = targetName = GSS_C_NO_NAME;
-  time = 0;
-  flags = isInitiator = isEstablished = 0;
-
   /* gss_inquire_context(...) => GSS_S_NO_CONTEXT(!) */
   major = (*ftab->inquireContext)(&minor, contextHdl, &srcName,
                               &targetName, &time, NULL, &flags,
@@ -1185,6 +1346,8 @@
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseName)(&dummy, &srcName);
+    (void) (*ftab->releaseName)(&dummy, &targetName);
     return NULL;
   }
   result[0] = ptr_to_jlong(srcName);
@@ -1195,11 +1358,12 @@
   result[5] = (jlong) getJavaTime(time);
 
   jresult = (*env)->NewLongArray(env, 6);
-  if (jresult == NULL) {
-    return NULL;
+  if (jresult != NULL) {
+    (*env)->SetLongArrayRegion(env, jresult, 0, 6, result);
   }
-  (*env)->SetLongArrayRegion(env, jresult, 0, 6, result);
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseName)(&dummy, &srcName);
+    (void) (*ftab->releaseName)(&dummy, &targetName);
     return NULL;
   }
   return jresult;
@@ -1245,7 +1409,7 @@
   jobject jobj, jlong pContext, jboolean isSrc)
 {
   OM_uint32 minor, major;
-  gss_name_t nameHdl;
+  gss_name_t nameHdl = GSS_C_NO_NAME;
   gss_ctx_id_t contextHdl;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
@@ -1253,7 +1417,6 @@
   TRACE2("[GSSLibStub_getContextName] %" PRIuPTR ", isSrc=%d",
           (uintptr_t)contextHdl, isSrc);
 
-  nameHdl = GSS_C_NO_NAME;
   if (isSrc == JNI_TRUE) {
     major = (*ftab->inquireContext)(&minor, contextHdl, &nameHdl, NULL,
                                 NULL, NULL, NULL,  NULL, NULL);
@@ -1351,6 +1514,7 @@
   gss_ctx_id_t contextHdl;
   OM_uint32 outSize, maxInSize;
   gss_qop_t qop;
+  jint result;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1374,7 +1538,14 @@
   if ((*env)->ExceptionCheck(env)) {
     return 0;
   }
-  return (jint) maxInSize;
+
+  /* Right-shift maxInSize until it fits into jint */
+  result = (jint)maxInSize;
+  while (result < 0 || maxInSize != (OM_uint32)result) {
+    result = (jint)(maxInSize >>= 1);
+  }
+
+  return result;
 }
 
 /*
@@ -1387,10 +1558,9 @@
                                                         jobject jobj,
                                                         jlong pContext)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
-  gss_buffer_desc interProcToken;
-  jbyteArray jresult;
+  gss_buffer_desc interProcToken = GSS_C_EMPTY_BUFFER;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1406,17 +1576,14 @@
   major =
     (*ftab->exportSecContext)(&minor, &contextHdl, &interProcToken);
 
-  /* release intermediate buffers */
-  jresult = getJavaBuffer(env, &interProcToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &interProcToken);
     return NULL;
   }
 
-  return jresult;
+  /* Map interProcToken to byteArray result and release */
+  return getJavaBuffer(env, &interProcToken, JNI_TRUE);
 }
 
 /*
@@ -1429,12 +1596,11 @@
                                                  jlong pContext, jint jqop,
                                                  jbyteArray jmsg)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
   gss_qop_t qop;
   gss_buffer_desc msg;
-  gss_buffer_desc msgToken;
-  jbyteArray jresult;
+  gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1446,28 +1612,25 @@
     return NULL;
   }
   qop = (gss_qop_t) jqop;
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
 
   /* gss_get_mic(...) => GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
      GSS_S_BAD_QOP */
-  major =
-    (*ftab->getMic)(&minor, contextHdl, qop, &msg, &msgToken);
+  major = (*ftab->getMic)(&minor, contextHdl, qop, &msg, &msgToken);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
-  jresult = getJavaBuffer(env, &msgToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
+  resetGSSBuffer(env, jmsg, &msg);
   checkStatus(env, jobj, major, minor, "[GSSLibStub_getMic]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
     return NULL;
   }
 
-  return jresult;
+  /* Map msgToken to byteArray result and release */
+  return getJavaBuffer(env, &msgToken, JNI_TRUE);
 }
 
 /*
@@ -1503,12 +1666,12 @@
   qop = (gss_qop_t) (*env)->CallIntMethod(env, jprop, MID_MessageProp_getQOP);
   if ((*env)->ExceptionCheck(env)) { return; }
 
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) { return; }
 
-  initGSSBuffer(env, jmsgToken, &msgToken);
+  initGSSBuffer(env, jmsgToken, &msgToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&msg);
+    resetGSSBuffer(env, jmsg, &msg);
     return;
   }
 
@@ -1519,9 +1682,14 @@
     (*ftab->verifyMic)(&minor, contextHdl, &msg, &msgToken, &qop);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
-  resetGSSBuffer(&msgToken);
+  resetGSSBuffer(env, jmsg, &msg);
+  resetGSSBuffer(env, jmsgToken, &msgToken);
 
+  /*
+   * We don't throw on supplementary status codes here, instead we pass only
+   * GSS_ERROR(major) to checkStatus() and set the supplementary status in the
+   * message properties.
+   */
   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_verifyMic]");
   if ((*env)->ExceptionCheck(env)) {
     return;
@@ -1534,9 +1702,6 @@
 
   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
                        minor);
-  if ((*env)->ExceptionCheck(env)) {
-    return;
-  }
 }
 
 /*
@@ -1551,11 +1716,11 @@
                                                jbyteArray jmsg,
                                                jobject jprop)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   jboolean confFlag;
   gss_qop_t qop;
   gss_buffer_desc msg;
-  gss_buffer_desc msgToken;
+  gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;
   int confState;
   gss_ctx_id_t contextHdl;
   jbyteArray jresult;
@@ -1582,7 +1747,7 @@
     return NULL;
   }
 
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1593,13 +1758,16 @@
                    &msgToken);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
-  jresult = getJavaBuffer(env, &msgToken);
+  resetGSSBuffer(env, jmsg, &msg);
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
+
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
     return NULL;
   }
 
-  checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
+  /* Map msgToken to byteArray result and release */
+  jresult = getJavaBuffer(env, &msgToken, JNI_TRUE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1607,7 +1775,8 @@
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
                          (confState? JNI_TRUE:JNI_FALSE));
   if ((*env)->ExceptionCheck(env)) {
-    return NULL;
+    (*env)->DeleteLocalRef(env, jresult);
+    jresult = NULL;
   }
   return jresult;
 }
@@ -1624,10 +1793,10 @@
                                                  jbyteArray jmsgToken,
                                                  jobject jprop)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
   gss_buffer_desc msgToken;
-  gss_buffer_desc msg;
+  gss_buffer_desc msg = GSS_C_EMPTY_BUFFER;
   int confState;
   gss_qop_t qop;
   jbyteArray jresult;
@@ -1642,7 +1811,7 @@
     return NULL;
   }
 
-  initGSSBuffer(env, jmsgToken, &msgToken);
+  initGSSBuffer(env, jmsgToken, &msgToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1656,13 +1825,24 @@
     (*ftab->unwrap)(&minor, contextHdl, &msgToken, &msg, &confState, &qop);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msgToken);
-  jresult = getJavaBuffer(env, &msg);
+  resetGSSBuffer(env, jmsgToken, &msgToken);
+
+  /*
+   * We don't throw on supplementary status codes here, instead we pass only
+   * GSS_ERROR(major) to checkStatus() and set the supplementary status in the
+   * message properties.
+   */
+  checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msg);
     return NULL;
   }
 
-  checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");
+  /*
+   * Map msg to byteArray result and release, zero length msg maps to empty
+   * byte array, not null.
+   */
+  jresult = getJavaBuffer(env, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1671,15 +1851,18 @@
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
                          (confState != 0));
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
                          minor);
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
 
--- old/src/java.security.jgss/share/native/libj2gss/NativeFunc.c	2019-10-21 14:15:14.932470264 -0500
+++ new/src/java.security.jgss/share/native/libj2gss/NativeFunc.c	2019-10-21 14:15:14.940470163 -0500
@@ -34,7 +34,11 @@
 static const char CANONICALIZE_NAME[]           = "gss_canonicalize_name";
 static const char EXPORT_NAME[]                 = "gss_export_name";
 static const char DISPLAY_NAME[]                = "gss_display_name";
+static const char LOCAL_NAME[]                  = "gss_localname";
 static const char ACQUIRE_CRED[]                = "gss_acquire_cred";
+static const char ACQUIRE_CRED_WITH_PASSWORD[]  = "gss_acquire_cred_with_password";
+static const char ACQUIRE_CRED_FROM[]           = "gss_acquire_cred_from";
+static const char STORE_CRED_INTO[]             = "gss_store_cred_into";
 static const char RELEASE_CRED[]                = "gss_release_cred";
 static const char INQUIRE_CRED[]                = "gss_inquire_cred";
 static const char IMPORT_SEC_CONTEXT[]          = "gss_import_sec_context";
@@ -122,12 +126,29 @@
         goto out;
     }
 
+    /*
+     * This one may not be available for a given GSS library, as it's an
+     * extension, therefore we don't fail if it's missing.
+     */
+    ftab->localName = (LOCAL_NAME_FN_PTR)GETFUNC(gssLib, LOCAL_NAME);
+
     ftab->acquireCred = (ACQUIRE_CRED_FN_PTR)GETFUNC(gssLib, ACQUIRE_CRED);
     if (ftab->acquireCred == NULL) {
         failed = TRUE;
         goto out;
     }
 
+    /*
+     * These may not be available for a given GSS library, as they are
+     * extensions, therefore we don't fail if it's missing.
+     */
+    ftab->acquireCredWithPassword = (ACQUIRE_CRED_WITH_PASSWORD_FN_PTR)
+                        GETFUNC(gssLib, ACQUIRE_CRED_WITH_PASSWORD);
+    ftab->acquireCredFrom = (ACQUIRE_CRED_FROM_FN_PTR)
+                        GETFUNC(gssLib, ACQUIRE_CRED_FROM);
+    ftab->storeCredInto = (STORE_CRED_INTO_FN_PTR)
+                        GETFUNC(gssLib, STORE_CRED_INTO);
+
     ftab->releaseCred = (RELEASE_CRED_FN_PTR)GETFUNC(gssLib, RELEASE_CRED);
     if (ftab->releaseCred == NULL) {
         failed = TRUE;
--- old/src/java.security.jgss/share/native/libj2gss/NativeFunc.h	2019-10-21 14:15:15.056468705 -0500
+++ new/src/java.security.jgss/share/native/libj2gss/NativeFunc.h	2019-10-21 14:15:15.060468655 -0500
@@ -84,6 +84,12 @@
                                 gss_buffer_t output_name_buffer,
                                 gss_OID *output_name_type);
 
+typedef OM_uint32 (*LOCAL_NAME_FN_PTR)
+                                (OM_uint32 *minor_status,
+                                gss_name_t input_name,
+                                gss_OID mech,
+                                gss_buffer_t output_name_buffer);
+
 typedef OM_uint32 (*ACQUIRE_CRED_FN_PTR)
                                 (OM_uint32 *minor_status,
                                 gss_const_name_t desired_name,
@@ -94,6 +100,39 @@
                                 gss_OID_set *actual_mechs,
                                 OM_uint32 *time_rec);
 
+typedef OM_uint32 (*ACQUIRE_CRED_WITH_PASSWORD_FN_PTR)
+                                (OM_uint32 *minor_status,
+                                gss_name_t desired_name,
+                                gss_buffer_t password,
+                                OM_uint32 time_req,
+                                gss_OID_set desired_mech,
+                                gss_cred_usage_t cred_usage,
+                                gss_cred_id_t *output_cred_handle,
+                                gss_OID_set *actual_mechs,
+                                OM_uint32 *time_rec);
+
+typedef OM_uint32 (*ACQUIRE_CRED_FROM_FN_PTR)
+                                (OM_uint32 *minor_status,
+                                 gss_const_name_t desired_name,
+                                 OM_uint32 time_req,
+                                 const gss_OID_set desired_mechs,
+                                 gss_cred_usage_t cred_usage,
+                                 gss_const_key_value_set_t cred_store,
+                                 gss_cred_id_t * output_cred_handle,
+                                 gss_OID_set * actual_mechs,
+                                 OM_uint32 * time_rec);
+
+typedef OM_uint32 (*STORE_CRED_INTO_FN_PTR)
+                                (OM_uint32 *minor_status,
+                                 gss_const_cred_id_t input_cred_handle,
+                                 gss_cred_usage_t input_usage,
+                                 const gss_OID desired_mech,
+                                 OM_uint32 overwrite_cred,
+                                 OM_uint32 default_cred,
+                                 gss_const_key_value_set_t cred_store,
+                                 gss_OID_set * elements_stored,
+                                 gss_cred_usage_t * cred_usage_stored);
+
 typedef OM_uint32 (*RELEASE_CRED_FN_PTR)
                                 (OM_uint32 *minor_status,
                                 gss_cred_id_t *cred_handle);
@@ -249,7 +288,11 @@
     CANONICALIZE_NAME_FN_PTR            canonicalizeName;
     EXPORT_NAME_FN_PTR                  exportName;
     DISPLAY_NAME_FN_PTR                 displayName;
+    LOCAL_NAME_FN_PTR                   localName;
     ACQUIRE_CRED_FN_PTR                 acquireCred;
+    ACQUIRE_CRED_WITH_PASSWORD_FN_PTR   acquireCredWithPassword;
+    ACQUIRE_CRED_FROM_FN_PTR            acquireCredFrom;
+    STORE_CRED_INTO_FN_PTR              storeCredInto;
     RELEASE_CRED_FN_PTR                 releaseCred;
     INQUIRE_CRED_FN_PTR                 inquireCred;
     IMPORT_SEC_CONTEXT_FN_PTR           importSecContext;
--- old/src/java.security.jgss/share/native/libj2gss/NativeUtil.c	2019-10-21 14:15:15.176467196 -0500
+++ new/src/java.security.jgss/share/native/libj2gss/NativeUtil.c	2019-10-21 14:15:15.180467146 -0500
@@ -271,9 +271,9 @@
   }
   MID_GSSNameElement_ctor =
     (*env)->GetMethodID(env, CLS_GSSNameElement,
-                        "<init>", "(JLsun/security/jgss/wrapper/GSSLibStub;)V");
+                        "<init>", "(JLorg/ietf/jgss/Oid;Lsun/security/jgss/wrapper/GSSLibStub;)V");
   if (MID_GSSNameElement_ctor == NULL) {
-    printf("Couldn't find GSSNameElement(long, GSSLibStub) constructor\n");
+    printf("Couldn't find GSSNameElement(long, Oid, GSSLibStub) constructor\n");
     return JNI_ERR;
   }
   MID_GSSCredElement_ctor =
@@ -455,6 +455,14 @@
     throwByName(env, "java/lang/OutOfMemoryError", message);
 }
 
+static jsize
+safe_jsize(size_t n)
+{
+    jsize res = (jsize)n;
+
+    return (res >= 0 && (size_t)res == n) ? res : -1;
+}
+
 /*
  * Utility routine for creating a java.lang.String object
  * using the specified gss_buffer_t structure. The specified
@@ -463,31 +471,33 @@
 jstring getJavaString(JNIEnv *env, gss_buffer_t bytes) {
   jstring result = NULL;
   OM_uint32 minor;
-  int len;
+  jsize len;
   jbyteArray jbytes;
 
-  if (bytes != NULL) {
-    /* constructs the String object with new String(byte[])
-       NOTE: do NOT include the trailing NULL */
-    len = (int) bytes->length;
-    jbytes = (*env)->NewByteArray(env, len);
-    if (jbytes == NULL) {
-      goto finish;
-    }
+  if (bytes == NULL) {
+    return NULL;
+  }
 
-    (*env)->SetByteArrayRegion(env, jbytes, 0, len, (jbyte *) bytes->value);
-    if ((*env)->ExceptionCheck(env)) {
-      goto finish;
-    }
+  /* constructs the String object with new String(byte[]) */
+  if ((len = safe_jsize(bytes->length)) < 0) {
+    (*ftab->releaseBuffer)(&minor, bytes);
+    return NULL;
+  }
+  jbytes = (*env)->NewByteArray(env, len);
+  if (jbytes == NULL) {
+    (*ftab->releaseBuffer)(&minor, bytes);
+    return NULL;
+  }
 
+  (*env)->SetByteArrayRegion(env, jbytes, 0, len, (jbyte *) bytes->value);
+  if ((*env)->ExceptionCheck(env) == JNI_FALSE) {
     result = (*env)->NewObject(env, CLS_String, MID_String_ctor,
                                jbytes);
-  finish:
-    (*env)->DeleteLocalRef(env, jbytes);
-    (*ftab->releaseBuffer)(&minor, bytes);
-    return result;
-  } /* else fall through */
-  return NULL;
+  }
+
+  (*env)->DeleteLocalRef(env, jbytes);
+  (*ftab->releaseBuffer)(&minor, bytes);
+  return result;
 }
 /*
  * Utility routine for generate message for the specified minor
@@ -519,7 +529,7 @@
  * not GSS_S_COMPLETE (i.e. 0).
  */
 void checkStatus(JNIEnv *env, jobject jstub, OM_uint32 major,
-                 OM_uint32 minor, char* methodName) {
+                 OM_uint32 minor, const char *methodName) {
   int callingErr, routineErr, supplementaryInfo;
   jint jmajor, jminor;
   char* msg;
@@ -580,76 +590,199 @@
  * Utility routine for initializing gss_buffer_t structure
  * with the byte[] in the specified jbyteArray object.
  * NOTE: must call resetGSSBuffer() to free up the resources
- * inside the gss_buffer_t structure.
  */
 void initGSSBuffer(JNIEnv *env, jbyteArray jbytes,
-                     gss_buffer_t cbytes) {
-
-  int len;
+                     gss_buffer_t cbytes, jboolean wantCopy)
+{
+  jboolean isCopy;
+  jint len;
   void* value;
 
-  if (jbytes != NULL) {
-    len = (*env)->GetArrayLength(env, jbytes);
-    value = malloc(len);
-    if (value == NULL) {
+  cbytes->length = 0;
+  cbytes->value = NULL;
+
+  if (jbytes == NULL ||
+      (len = (*env)->GetArrayLength(env, jbytes)) == 0)
+    return;
+
+  cbytes->length = len;
+
+  if (wantCopy == JNI_FALSE) {
+    cbytes->value = (*env)->GetByteArrayElements(env, jbytes, &isCopy);
+    if (cbytes->value == NULL) {
       throwOutOfMemoryError(env, NULL);
-      return;
-    } else {
-      (*env)->GetByteArrayRegion(env, jbytes, 0, len, value);
-      if ((*env)->ExceptionCheck(env)) {
-        free(value);
-        return;
-      } else {
-        cbytes->length = len;
-        cbytes->value = value;
-      }
     }
-  } else {
-    cbytes->length = 0;
-    cbytes->value = NULL;
+    return;
+  }
+
+  value = malloc(len);
+  if (value == NULL) {
+    throwOutOfMemoryError(env, NULL);
+    return;
   }
+
+  (*env)->GetByteArrayRegion(env, jbytes, 0, len, value);
+  if ((*env)->ExceptionCheck(env)) {
+    free(value);
+    return;
+  }
+  cbytes->value = value;
 }
 
 /*
- * Utility routine for freeing the bytes malloc'ed
- * in initGSSBuffer() method.
- * NOTE: used in conjunction with initGSSBuffer(...).
+ * Utility routine for freeing the buffer obtained via initGSSBuffer().
+ * If jbytes is null this is a malloced copy.
  */
-void resetGSSBuffer(gss_buffer_t cbytes) {
-  if ((cbytes != NULL) && (cbytes != GSS_C_NO_BUFFER)) {
+void resetGSSBuffer(JNIEnv *env, jbyteArray jbytes, gss_buffer_t cbytes)
+{
+  if (cbytes->value == NULL)
+    return;
+  if (jbytes != NULL) {
+    (*env)->ReleaseByteArrayElements(env, jbytes, cbytes->value, JNI_ABORT);
+  } else if (cbytes->length > 0) {
     free(cbytes->value);
-    cbytes->length = 0;
     cbytes->value = NULL;
+    cbytes->length = 0;
+  }
+}
+
+/*
+ * Utility routine for initializing gss_buffer_t structure
+ * with a String.
+ * NOTE: need to call resetGSSBufferString(...) to free up
+ * the resources.
+ */
+void initGSSBufferString(JNIEnv* env, jstring jstr, gss_buffer_t buf)
+{
+  const char *s;
+
+  buf->length = 0;
+  buf->value = NULL;
+  if (jstr != NULL) {
+    s = (*env)->GetStringUTFChars(env, jstr, NULL);
+    if (s == NULL) {
+      throwOutOfMemoryError(env, NULL);
+    } else {
+      buf->length = strlen(s);
+      buf->value = (char *)s; /* Drop const */
+    }
+  }
+}
+
+/*
+ * Utility routine for unpinning/releasing the String
+ * associated with the specified jstring object.
+ * NOTE: used in conjunction with initGSSBufferString(...).
+ */
+void resetGSSBufferString(JNIEnv *env, jstring jstr, gss_buffer_t buf)
+{
+  if (jstr != NULL && buf->value != NULL)
+    (*env)->ReleaseStringUTFChars(env, jstr, buf->value);
+}
+
+void initGSSCredStore(JNIEnv *env, jarray jstore,
+                      gss_key_value_set_desc *store) {
+  jsize nelements = 0;
+  jsize n, i, k;
+
+  store->count = 0;
+  store->elements = NULL;
+  if (jstore == NULL) {
+    return;
+  }
+  n = (*env)->GetArrayLength(env, jstore);
+  for (i = 0; i < n; i += 2) {
+    jobject jkey = (*env)->GetObjectArrayElement(env, jstore, i);
+    jobject jval = (*env)->GetObjectArrayElement(env, jstore, i + 1);
+    
+    if (!jkey || !jval) {
+      break;
+    }
+    if (!(*env)->IsInstanceOf(env, jkey, CLS_String) ||
+        !(*env)->IsInstanceOf(env, jval, CLS_String)) {
+      throwByName(env, "java/lang/IllegalArgumentException",
+                  "invalid GSS credential store element type; must be String");
+      store->count = 0;
+      return;
+    }
+    store->count += 1;
+    nelements += 2;
+  }
+  if (nelements < 0 || nelements > INT32_MAX) {
+    throwOutOfMemoryError(env,NULL);
+    store->count = 0;
+    return;
+  }
+  store->elements = calloc(store->count, sizeof(store->elements[0]));
+  if (store->elements == NULL) {
+    throwOutOfMemoryError(env,NULL);
+    store->count = 0;
+    return;
+  }
+  for (i = 0, k = 0; i < nelements; i += 2, k++) {
+    jobject jkey = (*env)->GetObjectArrayElement(env, jstore, i);
+    jobject jval = (*env)->GetObjectArrayElement(env, jstore, i + 1);
+    store->elements[k].key = (*env)->GetStringUTFChars(env, jkey, NULL);
+    store->elements[k].value = (*env)->GetStringUTFChars(env, jval, NULL);
+    TRACE2("[GSSLibStub initGSSCredStore] element %ld key %s",
+           (long)k, store->elements[k].key);
+    TRACE2("[GSSLibStub initGSSCredStore] element %ld value %s",
+           (long)k, store->elements[k].value);
   }
 }
 
+void resetGSSCredStore(JNIEnv *env,
+                       jarray jstore,
+                       gss_key_value_set_desc *store) {
+  jobject jstr;
+  jsize i;
+
+  for (i = 0; i < (jsize)store->count; i++) {
+    jstr = (*env)->GetObjectArrayElement(env, jstore, i);
+    if (!(i & 0x01)) {
+      (*env)->ReleaseStringUTFChars(env, jstr, store->elements[i].key);
+    } else {
+      (*env)->ReleaseStringUTFChars(env, jstr, store->elements[i].value);
+    }
+  }
+  free(store->elements);
+  store->elements = NULL;
+  store->count = 0;
+}
+
+
 /*
  * Utility routine for creating a jbyteArray object using
  * the byte[] value in specified gss_buffer_t structure.
  * NOTE: the specified gss_buffer_t structure is always
  * released.
  */
-jbyteArray getJavaBuffer(JNIEnv *env, gss_buffer_t cbytes) {
+jbyteArray getJavaBuffer(JNIEnv *env, gss_buffer_t cbytes, jboolean isToken) {
   jbyteArray result = NULL;
-  OM_uint32 minor; // don't care, just so it compiles
+  OM_uint32 dummy;
 
-  if (cbytes != NULL) {
-    if ((cbytes != GSS_C_NO_BUFFER) && (cbytes->length != 0)) {
-      result = (*env)->NewByteArray(env, (int) cbytes->length);
-      if (result == NULL) {
-        goto finish;
-      }
-      (*env)->SetByteArrayRegion(env, result, 0, (int) cbytes->length,
+  /*
+   * Zero length tokens map to NULL outputs, but otherwise to a zero-length
+   * Java byte array.
+   */
+  if (cbytes != GSS_C_NO_BUFFER &&
+      (isToken == JNI_FALSE || cbytes->length > 0)) {
+    jsize len = safe_jsize(cbytes->length);
+
+    if (len >= 0) {
+      result = (*env)->NewByteArray(env, len);
+    }
+    if (result != NULL) {
+      (*env)->SetByteArrayRegion(env, result, 0, len,
                                  cbytes->value);
       if ((*env)->ExceptionCheck(env)) {
+        (*env)->DeleteLocalRef(env, result);
         result = NULL;
       }
     }
-  finish:
-    (*ftab->releaseBuffer)(&minor, cbytes);
-    return result;
   }
-  return NULL;
+  (void) (*ftab->releaseBuffer)(&dummy, cbytes);
+  return result;
 }
 
 /*
@@ -737,50 +870,34 @@
   return result;
 }
 /*
- * Utility routine for creating a gss_OID_set structure
- * using the specified gss_OID.
- * NOTE: need to call deleteGSSOIDSet(...) afterwards
- * to release the created gss_OID_set structure.
- */
-gss_OID_set newGSSOIDSet(gss_OID oid) {
-  gss_OID_set oidSet;
-  OM_uint32 minor; // don't care; just so it compiles
-
-  if (oid->length != 6 ||
-      memcmp(oid->elements, SPNEGO_BYTES, 6) != 0) {
-      (*ftab->createEmptyOidSet)(&minor, &oidSet);
-      (*ftab->addOidSetMember)(&minor, oid, &oidSet);
-      return oidSet;
-  } else {
-      // Use all mechs for SPNEGO in order to work with
-      // various native GSS impls
-      return (ftab->mechs);
-  }
-}
-/*
- * Utility routine for releasing a gss_OID_set structure.
- * NOTE: used in conjunction with newGSSOIDSet(...).
- */
-void deleteGSSOIDSet(gss_OID_set oidSet) {
-  OM_uint32 minor; /* don't care; just so it compiles */
-
-  if ((oidSet != ftab->mechs) &&
-      (oidSet != NULL) && (oidSet != GSS_C_NO_OID_SET)) {
-    (*ftab->releaseOidSet)(&minor, &oidSet);
+ * Utility routine for filling in a 1-element gss_OID_set structure using the
+ * specified gss_OID (storage owned by caller).  However, with SPNEGO we return
+ * a static set containing all the available mechanisms.
+ */
+gss_OID_set makeGSSOIDSet(gss_OID_set mechs, gss_OID oid) {
+  if (oid->length != 6 || memcmp(oid->elements, SPNEGO_BYTES, 6) != 0) {
+      mechs->count = 1;
+      mechs->elements = oid;
+      return mechs;
   }
+  /* Use all mechs for SPNEGO in order to work with various native GSS impls */
+  return (ftab->mechs);
 }
 /*
  * Utility routine for creating a org.ietf.jgss.Oid[]
  * using the specified gss_OID_set structure.
  */
 jobjectArray getJavaOIDArray(JNIEnv *env, gss_OID_set cOidSet) {
-  int numOfOids = 0;
+  jsize numOfOids = 0;
   jobjectArray jOidSet;
   jobject jOid;
-  int i;
+  jsize i;
 
   if (cOidSet != NULL && cOidSet != GSS_C_NO_OID_SET) {
-    numOfOids = (int) cOidSet->count;
+    numOfOids = safe_jsize(cOidSet->count);
+    if (numOfOids < 0) {
+      return NULL;
+    }
     jOidSet = (*env)->NewObjectArray(env, numOfOids, CLS_Oid, NULL);
     if ((*env)->ExceptionCheck(env)) {
       return NULL;
--- old/src/java.security.jgss/share/native/libj2gss/NativeUtil.h	2019-10-21 14:15:15.332465235 -0500
+++ new/src/java.security.jgss/share/native/libj2gss/NativeUtil.h	2019-10-21 14:15:15.336465185 -0500
@@ -36,18 +36,21 @@
 #endif
   extern jint getJavaTime(OM_uint32);
   extern OM_uint32 getGSSTime(jint);
-  extern void checkStatus(JNIEnv *, jobject, OM_uint32, OM_uint32, char*);
+  extern void checkStatus(JNIEnv *, jobject, OM_uint32, OM_uint32, const char *);
   extern jint checkTime(OM_uint32);
   extern void throwOutOfMemoryError(JNIEnv *, const char*);
-  extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
-  extern void resetGSSBuffer(gss_buffer_t);
+  extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t, jboolean);
+  extern void resetGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
+  extern void initGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
+  extern void resetGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
+  extern void initGSSCredStore(JNIEnv *, jarray, gss_key_value_set_desc *);
+  extern void resetGSSCredStore(JNIEnv *, jarray, gss_key_value_set_desc *);
 
   extern gss_OID newGSSOID(JNIEnv *, jobject);
   extern void deleteGSSOID(gss_OID);
-  extern gss_OID_set newGSSOIDSet(gss_OID);
-  extern void deleteGSSOIDSet(gss_OID_set);
+  extern gss_OID_set makeGSSOIDSet(gss_OID_set, gss_OID);
 
-  extern jbyteArray getJavaBuffer(JNIEnv *, gss_buffer_t);
+  extern jbyteArray getJavaBuffer(JNIEnv *, gss_buffer_t, jboolean);
   extern jstring getJavaString(JNIEnv *, gss_buffer_t);
   extern jobject getJavaOID(JNIEnv *, gss_OID);
   extern jobjectArray getJavaOIDArray(JNIEnv *, gss_OID_set);
--- old/src/java.security.jgss/share/native/libj2gss/gssapi.h	2019-10-21 14:15:15.444463827 -0500
+++ new/src/java.security.jgss/share/native/libj2gss/gssapi.h	2019-10-21 14:15:15.452463727 -0500
@@ -119,6 +119,19 @@
 typedef OM_uint32       gss_qop_t;
 typedef int             gss_cred_usage_t;
 
+/* Credential store extensions */
+typedef struct gss_key_value_element_struct {
+    const char *key;
+    const char *value;
+} gss_key_value_element_desc;
+
+typedef struct gss_key_value_set_struct {
+    OM_uint32 count; /* should be size_t, but for MIT compat */
+    gss_key_value_element_desc *elements;
+} gss_key_value_set_desc, *gss_key_value_set_t;
+
+typedef const gss_key_value_set_desc *gss_const_key_value_set_t;
+
 /*
  * Flag bits for context-level services.
  */
@@ -699,6 +712,32 @@
 #    pragma pack(pop)
 #endif
 
+/* Common extension (NOT in RFC2744) */
+OM_uint32
+gss_add_cred_with_password(
+        OM_uint32 *,            /* minor_status */
+        gss_const_cred_id_t,    /* input_cred_handle */
+        gss_const_name_t,       /* desired_name */
+        gss_const_OID,          /* desired_mech */
+        gss_const_buffer_t,     /* password */
+        gss_cred_usage_t,       /* cred_usage */
+        OM_uint32,              /* initiator_time_req */
+        OM_uint32,              /* acceptor_time_req */
+        gss_cred_id_t *,        /* output_cred_handle */
+        gss_OID_set *,          /* actual_mechs */
+        OM_uint32 *,            /* initiator_time_rec */
+        OM_uint32 *             /* acceptor_time_rec */
+);
+
+/* Common extension for aname2lname (NOT in RFC2744) */
+OM_uint32
+gss_localname(
+        OM_uint32 *,            /* minor_status */
+        gss_const_name_t,       /* name */
+        gss_OID,                /* mech_type */
+        gss_buffer_t            /* localname */
+);
+
 #ifdef __cplusplus
 }
 #endif
--- old/src/jdk.jdwp.agent/share/native/libjdwp/export/sys.h	2019-10-21 14:15:15.572462218 -0500
+++ new/src/jdk.jdwp.agent/share/native/libjdwp/export/sys.h	2019-10-21 14:15:15.576462168 -0500
@@ -41,6 +41,7 @@
 void *  dbgsysLoadLibrary(const char *, char *err_buf, int err_buflen);
 void    dbgsysUnloadLibrary(void *);
 void *  dbgsysFindLibraryEntry(void *, const char *);
+int     dbgsysGetLastErrorString(char *, int);
 
 /* Implemented in exec_md.c */
 int     dbgsysExec(char *cmdLine);
--- old/src/jdk.jdwp.agent/unix/native/libjdwp/linker_md.c	2019-10-21 14:15:15.684460810 -0500
+++ new/src/jdk.jdwp.agent/unix/native/libjdwp/linker_md.c	2019-10-21 14:15:15.688460760 -0500
@@ -66,6 +66,28 @@
     free(paths_copy);
 }
 
+int
+dbgsysGetLastErrorString(char *buf, int len)
+{
+    const char *s = dlerror();
+    size_t n;
+    size_t l = (size_t)len;
+
+    if (len <= 0)
+        return 0;
+
+    *buf = '\0';
+    if (s == NULL)
+        return 0;
+
+    n = strlen(s);
+    if (n >= l)
+        n = l - 1;
+    strncpy(buf, s, n);
+    buf[n] = '\0'; /* not actually needed */
+    return n;
+}
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
--- /dev/null	2019-10-10 12:20:09.293823624 -0500
+++ new/src/jdk.security.auth/share/classes/com/sun/security/auth/module/GssLoginModule.java	2019-10-21 14:15:15.796459402 -0500
@@ -0,0 +1,846 @@
+/*
+ * Copyright (c) 2000, 2017-2018 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.security.auth.module;
+
+import java.text.MessageFormat;
+import java.util.Map;
+import java.util.Set;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import javax.security.auth.Subject;
+import javax.security.auth.SubjectDomainCombiner;
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.auth.login.LoginException;
+import javax.security.auth.spi.LoginModule;
+
+import org.ietf.jgss.GSSManager;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSCredential;
+import org.ietf.jgss.GSSName;
+import org.ietf.jgss.Oid;
+
+import static sun.security.util.ResourcesMgr.getAuthResourceString;
+
+/**
+ * <p>This {@code LoginModule} authenticates users using a GSS-API
+ * mechanism.</p>
+ *
+ * <p> The configuration entry for {@code GssLoginModule} has
+ * several options that control the authentication process and
+ * additions to the {@code Subject}'s private credential
+ * set. Irrespective of these options, the {@code Subject}'s
+ * principal set and private credentials set are updated only when
+ * {@code commit} is called.
+ * When {@code commit} is called, the {@code GSSName} is added to the
+ * {@code Subject}'s principal set. If {@code initiate} is true, the
+ * initiator credential will be added to the {@code Subject}'s private
+ * credentials.</p>
+ *
+ * <p> If the configuration entry for {@code GssLoginModule}
+ * has the option {@code accept} set to true, then acceptor credential
+ * will be added to the subject's private credentials.</p>
+ *
+ * <p> This {@code LoginModule} recognizes the {@code doNotPrompt}
+ * option. If set to true the user will not be prompted for their password.</p>
+ *
+ * <p> When using the GSS-API Kerberos mechanism, the user can specify
+ * the location of the ticket cache by using the option
+ * {@code ticketCache} in the configuration entry. Similarly, a keytab
+ * can be specified using the option {@code keyTab} in the
+ * configuration entry.</p>
+ *
+ * <p> Other credential store options can be specified as
+ * {@code credStoreKeyValue_KEY}, where {@code KEY} is the name of a
+ * credential store key supported by the GSS-API mechanism provider.
+ * When using platform native GSS-API providers, consult their
+ * documentation (for example, look for the {@code gss_acquire_cred_from()}
+ * and {@code gss_store_cred_into()} functions).</p>
+ *
+ * <p> The principal name can be specified in the configuration entry
+ * by using the option {@code name} and {@code nameType}. The principal name
+ * can either be a simple user name, a service name such as
+ * {@code host@mission.eng.sun.com}. The principal can also
+ * be set using the system property
+ * {@systemProperty sun.security.gss.name}, and its name-type can be set
+ * with {@systemProperty sun.security.gss.nametype}.
+ * These properties are checked during login if the name and name-type
+ * are not set in the configuration.  In the case where the principal
+ * property is not set and the principal entry also does not exist, the
+ * user is prompted for the name.</p>
+ *
+ * <p> The following is a list of configuration options supported
+ * for {@code GssLoginModule}:
+ * <blockquote><dl>
+ * <dt>{@code doNotPrompt}:</dt>
+ * <dd>Set this to true if you do not want to be
+ * prompted for the password
+ * if credentials can not be obtained from the cache, the keytab,
+ * or through shared state.(Default is false)
+ * If set to true, credential must be obtained through cache, keytab,
+ * or shared state. Otherwise, authentication will fail.</dd>
+ * <dt>{@code ticketCache}:</dt>
+ * <dd>Set this to the name of the ticket cache file that contains
+ * user's TGT.</dd>
+ * <dt>{@code keyTab}:</dt>
+ * <dd>Set this to the file name of the keytab to get principal's secret
+ * key(s).</dd>
+ * <dt>{@code name}:</dt>
+ * <dd>The name of the principal that should be used. The principal can
+ * be a simple username such as "{@code testuser}" or a service name
+ * such as "{@code host@testhost.eng.sun.com}". You can use the
+ * {@code principal} option to set the principal when there are
+ * credentials for multiple principals in the {@code keyTab} or when you
+ * want a specific ticket cache only. The principal can also be set
+ * using the system property {@code sun.security.gss.name}. The value
+ * from the configuration takes precedence.</dd>
+ * <dt>{@code nametype}:</dt>
+ * <dd>This is the type of the name. This can be "{@code username}",
+ * "{@code hostbased}", or an OID, and defaults to "{@code username}".</dd>
+ * <dt>{@code initiate}:</dt>
+ * <dd>Set this to true, if you need to acquire initiator
+ * credentials.</dd>
+ * <dt>{@code accept}:</dt>
+ * <dd>Set this to true, if you need to acquire acceptor
+ * credentials. Either or both of {@code initiate} and {@code accept}
+ * may be set to true. If both are false then {@code initiate} will be
+ * treated as true.</dd>
+ * </dl></blockquote></p>
+ *
+ * <p> This {@code LoginModule} also recognizes the following additional
+ * {@code Configuration}
+ * options that enable you to share username and passwords across different
+ * authentication modules:
+ * <blockquote><dl>
+ *
+ *    <dt>{@code useFirstPass}:</dt>
+ *                   <dd>if, true, this LoginModule retrieves the
+ *                   username and password from the module's shared state,
+ *                   using "javax.security.auth.login.name" and
+ *                   "javax.security.auth.login.password" as the respective
+ *                   keys. The retrieved values are used for authentication.
+ *                   If authentication fails, no attempt for a retry
+ *                   is made, and the failure is reported back to the
+ *                   calling application.</dd>
+ *
+ *    <dt>{@code tryFirstPass}:</dt>
+ *                   <dd>if, true, this LoginModule retrieves the
+ *                   the username and password from the module's shared
+ *                   state using "javax.security.auth.login.name" and
+ *                   "javax.security.auth.login.password" as the respective
+ *                   keys.  The retrieved values are used for
+ *                   authentication.
+ *                   If authentication fails, the module uses the
+ *                   CallbackHandler to retrieve a new username
+ *                   and password, and another attempt to authenticate
+ *                   is made. If the authentication fails,
+ *                   the failure is reported back to the calling application</dd>
+ *
+ *    <dt>{@code storePass}:</dt>
+ *                   <dd>if, true, this LoginModule stores the username and
+ *                   password obtained from the CallbackHandler in the
+ *                   modules shared state, using
+ *                   "javax.security.auth.login.name" and
+ *                   "javax.security.auth.login.password" as the respective
+ *                   keys.  This is not performed if existing values already
+ *                   exist for the username and password in the shared
+ *                   state, or if authentication fails.</dd>
+ *
+ *    <dt>{@code clearPass}:</dt>
+ *                   <dd>if, true, this LoginModule clears the
+ *                   username and password stored in the module's shared
+ *                   state  after both phases of authentication
+ *                   (login and commit) have completed.</dd>
+ * </dl></blockquote></p>
+ * <p>If the principal system property or key is already provided, the value of
+ * "javax.security.auth.login.name" in the shared state is ignored.</p>
+ *
+ * <p>Note that if any step fails, it will fallback to the next step.
+ * There's only one exception, if the shared state step fails and
+ * {@code useFirstPass = true}, no user prompt is made.</p>
+ */
+
+
+public class GssLoginModule implements LoginModule {
+
+    // From initialize
+    private Subject subject;
+    private CallbackHandler callbackHandler;
+    private Map<String, Object> sharedState;
+    private Map<String, ?> options;
+
+    // Configuration option
+    private boolean debug;
+    private boolean doNotPrompt;
+    private String defName;
+    private String name;
+    private String nametype; // username, hostbased, unspecified
+    private Oid nametypeOid;
+
+    private GSSManager manager;
+    private GSSName gssName;
+    private GSSCredential gssICred;
+    private GSSCredential gssACred;
+
+    private boolean useNative; // sun.security.jgss.native property
+
+    private boolean useFirstPass;
+    private boolean tryFirstPass;
+    private boolean storePass;
+    private boolean clearPass;
+    private boolean initiate;
+    private boolean accept;
+    private boolean tryDefaultCreds;
+    private boolean useDefaultCreds;
+
+    // Module state
+    private boolean succeeded;
+    private boolean commitSucceeded;
+
+    private String password = null;
+    private Map<String,String> store = null;
+
+    private static final String NAME = "javax.security.auth.login.name";
+    private static final String PWD = "javax.security.auth.login.password";
+
+    private String getString(String key) {
+        return (String)options.get(key);
+    }
+    private boolean getBool(String key) {
+        String value = (String)options.get(key);
+        return value != null ? Boolean.parseBoolean(value) : false;
+    }
+    private boolean getBoolWithDefault(String key, boolean defval) {
+        String value = (String)options.get(key);
+        return value != null ? Boolean.parseBoolean(value) : defval;
+    }
+
+    private void storeAddKeyValue(String key, String value) {
+        if (store == null) {
+            store = new HashMap<String,String>(){{put(key, value);}};
+        } else {
+            store.put(key, value);
+        }
+    }
+
+    private void storeAddOption(String optionName, String key) {
+        if (options.containsKey(optionName)) {
+            storeAddKeyValue(key, getString(optionName));
+        }
+    }
+
+    private void storeAddOptions() {
+        for (String key : options.keySet()) {
+            if (!key.startsWith("credStoreKeyValue_"))
+                continue;
+            storeAddOption(key, key.substring("credStoreKeyValue_".length()));
+        }
+    }
+
+    /**
+     * Initialize this <code>LoginModule</code>.
+     *
+     * <p>
+     * @param subject the <code>Subject</code> to be authenticated.</p>
+     *
+     * <p>
+     * @param callbackHandler a <code>CallbackHandler</code> for
+     *                  communication with the end user (prompting for
+     *                  usernames and passwords, for example).</p>
+     *
+     * <p>
+     * @param sharedState shared <code>LoginModule</code> state.</p>
+     *
+     * <p>
+     * @param options options specified in the login
+     *                  <code>Configuration</code> for this particular
+     *                  <code>LoginModule</code>.</p>
+     */
+    // Unchecked warning from (Map<String, Object>)sharedState is safe
+    // since javax.security.auth.login.LoginContext passes a raw HashMap.
+    // Unchecked warnings from options.get(String) are safe since we are
+    // passing known keys.
+    @SuppressWarnings("unchecked")
+    public void initialize(Subject subject,
+                           CallbackHandler callbackHandler,
+                           Map<String, ?> sharedState,
+                           Map<String, ?> options) {
+
+        this.subject = subject;
+        this.callbackHandler = callbackHandler;
+        this.sharedState = (Map<String, Object>)sharedState;
+        this.options = options;
+
+        /*
+         * When sun.security.jgss.native=false (i.e., not using the system's
+         * native C/ELF/DLL GSS implementation) then there's nothing for this
+         * login module to do.  Otherwise we'd get into an infinite recursion
+         * problem due to re-entering GssLoginModule like this:
+         *
+         * Application -> LoginContext -> GssLoginModule -> Krb5 ->
+         *      GSSUtil.login -> LoginContext -> GssLoginModule -> ...
+         *
+         * It stands to reason that when sun.security.jgss.native=false the
+         * login modules corresponding to the actual GSS mechanisms coded in
+         * Java are the ones that should be acquiring their corresponding
+         * credentials.
+         *
+         * A policy like "let the application use GSS credentials but not the
+         * raw, underlying Krb5 credentials" when
+         * sun.security.jgss.native=false" could be expressible by adding a
+         * module option to Krb5LoginModule that causes it to add only GSS
+         * credentials to the Subject, not Krb5 credentials.
+         *
+         * (It has never been possible to express such a policy, so we lose
+         * nothing by punting here when sun.security.jgss.native=false.)
+         */
+        useNative = Boolean.getBoolean("sun.security.jgss.native");
+        if (!useNative)
+            return;
+
+        manager = GSSManager.getInstance();
+
+        // initialize any configured options
+
+        debug = getBool("debug");
+        doNotPrompt = getBool("doNotPrompt");
+        defName = getString("name");
+        nametype = getString("nametype");
+
+        if (defName == null)
+            defName = System.getProperty("sun.security.gss.name");
+        if (nametype == null)
+            nametype = System.getProperty("sun.security.gss.nametype");
+        if (nametype == null || nametype.equals("username")) {
+            nametypeOid = GSSName.NT_USER_NAME;
+        } else if (nametype.equals("hostbased")) {
+            nametypeOid = GSSName.NT_HOSTBASED_SERVICE;
+        } else if (!nametype.equals("")) {
+            try {
+                nametypeOid = new Oid(nametype);
+            } catch (GSSException e) {
+                if (debug)
+                    System.out.print("Unknown name type OID " + nametype);
+                nametypeOid = null;
+            }
+        } else {
+            nametype = "<default: username>";
+            nametypeOid = GSSName.NT_USER_NAME;
+        }
+
+        storeAddOptions();
+        storeAddOption("keyTab", "keytab");
+        storeAddOption("clientKeyTab", "client_keytab");
+        storeAddOption("ticketCache", "ccache");
+        storeAddOption("replayCache", "rcache");
+
+        tryFirstPass = getBool("tryFirstPass");
+        useFirstPass = getBoolWithDefault("useFirstPass", doNotPrompt);
+        storePass = getBool("storePass");
+        clearPass = getBool("clearPass");
+        initiate = getBool("initiate");
+        accept = getBool("accept");
+        tryDefaultCreds = getBool("tryDefaultCreds");
+        useDefaultCreds = getBoolWithDefault("useDefaultCreds", doNotPrompt);
+        if (!initiate && !accept)
+            initiate = true;
+        if (debug) {
+            System.out.print("Debug is  " + debug
+                             + " doNotPrompt " + doNotPrompt
+                             + " defName is " + defName
+                             + " nametype is " + nametype
+                             + " tryFirstPass is " + tryFirstPass
+                             + " useFirstPass is " + useFirstPass
+                             + " storePass is " + storePass
+                             + " clearPass is " + clearPass
+                             + " initiate is " + initiate
+                             + " accept is " + accept
+                             + " tryDefaultCreds is " + tryDefaultCreds
+                             + " useDefaultCreds is " + useDefaultCreds + "\n");
+            System.out.print("Credential store options are:");
+            if (store.size() == 0) {
+                System.out.print(" <none>");
+            } else {
+                for (var e : store.entrySet()) {
+                    System.out.print(" " + e.getKey() + "=" + e.getValue() + ";");
+                }
+            }
+            System.out.println("");
+        }
+    }
+
+
+    /**
+     * Authenticate the user
+     *
+     * <p>
+     *
+     * @return true in all cases since this <code>LoginModule</code>
+     *          should not be ignored.</p>
+     *
+     * <p>
+     * @exception FailedLoginException if the authentication fails.</p>
+     *
+     * <p>
+     * @exception LoginException if this <code>LoginModule</code>
+     *          is unable to perform the authentication.</p>
+     */
+    public boolean login() throws LoginException {
+        succeeded = false;
+
+        /*
+         * See commentary in initialize().  By returning false we cause
+         * LoginContext to ignore this module.
+         */
+        if (!useNative)
+            return false;
+        try {
+            if (tryFirstPass || useFirstPass) {
+                attemptAuthentication(true);
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] " +
+                                       "authentication succeeded");
+                succeeded = true;
+                cleanState();
+                return true;
+            }
+        } catch (LoginException le) {
+            // authentication failed -- try again below by prompting
+            cleanState();
+            if (debug) {
+                System.out.println("\t\t[GssLoginModule] " +
+                                   (tryFirstPass ? "tryFirstPass " : "") +
+                                   "authentication failed with:" +
+                                   le.getMessage());
+            }
+            if (useFirstPass)
+                throw le;
+        }
+
+        // The first password didn't work or we didn't try it, try prompting
+        try {
+            attemptAuthentication(false);
+            if (debug)
+                System.out.println("\t\t[GssLoginModule] " +
+                                   "authentication succeeded");
+            succeeded = true;
+            cleanState();
+            return true;
+        } catch (LoginException le2) {
+            cleanState();
+            if (debug) {
+                System.out.println("\t\t[GssLoginModule] " +
+                                   (tryFirstPass ? "tryFirstPass " : "") +
+                                   "authentication failed with:" +
+                                   le2.getMessage());
+            }
+            throw le2;
+        }
+    }
+
+    private void getcreds() throws GSSException {
+        if (initiate) {
+            if (password == null && store == null) {
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] acquiring" +
+                        ((gssName == null) ? " default" : "") +
+                        " initiator credentials...");
+                gssICred = manager.createCredential(gssName,
+                        GSSCredential.DEFAULT_LIFETIME, (Oid[])null,
+                        GSSCredential.INITIATE_ONLY);
+            } else if (password != null) {
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] acquiring" +
+                        " initiator credentials using a password...");
+                gssICred = manager.createCredential(gssName, password,
+                        GSSCredential.DEFAULT_LIFETIME, (Oid[])null,
+                        GSSCredential.INITIATE_ONLY);
+            } else {
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] acquiring" +
+                        ((gssName == null) ? " default" : "") +
+                        " initiator credentials using a specified" +
+                        " credential store...");
+                gssICred = manager.createCredential(gssName, store,
+                        GSSCredential.DEFAULT_LIFETIME, (Oid[])null,
+                        GSSCredential.INITIATE_ONLY);
+            }
+            if (debug)
+                System.out.println("\t\t[GssLoginModule] acquired" +
+                    " initiator credentials: " + gssName);
+        }
+        if (accept) {
+            if (debug)
+                System.out.println("\t\t[GssLoginModule] acquiring" +
+                    ((gssName == null) ? " default" : "") +
+                    " acceptor credentials...");
+            gssACred = manager.createCredential(gssName, password,
+                    GSSCredential.DEFAULT_LIFETIME, (Oid[])null,
+                    GSSCredential.ACCEPT_ONLY);
+            // Default acceptor credentials retain a null name
+            if (debug)
+                System.out.println("\t\t[GssLoginModule] acquired" +
+                    " acceptor credentials");
+        }
+        if (gssName == null && gssICred != null)
+            gssName = gssICred.getName();
+        if (gssName == null && gssACred != null)
+            gssName = gssACred.getName();
+    }
+
+    private void attemptAuthentication(boolean getPasswdFromSharedState)
+        throws LoginException {
+
+        // Get a name, maybe
+        if (name == null) {
+            if (useDefaultCreds) {
+                try {
+                    getcreds();
+                    return;
+                } catch (GSSException e) {
+                    throw new LoginException(e.getMessage());
+                }
+            }
+            if (tryDefaultCreds) {
+                try {
+                    getcreds();
+                    return;
+                } catch (GSSException e) { }
+            }
+
+            promptForName(getPasswdFromSharedState);
+            if (name == null)
+                throw new LoginException ("Unable to determine a GSS name");
+        }
+
+        try {
+            gssName = manager.createName(name, nametypeOid);
+        } catch (GSSException e) {
+            throw new LoginException ("Unable to import GSS name");
+        }
+
+        promptForPass(getPasswdFromSharedState);
+
+        try {
+            getcreds();
+        } catch (GSSException e) {
+            throw new LoginException(e.getMessage());
+        }
+    }
+
+    private void promptForName(boolean getPasswdFromSharedState)
+        throws LoginException {
+        if (getPasswdFromSharedState) {
+            // use the name saved by a module earlier in the stack
+            name = (String)sharedState.get(NAME);
+            if (name == null || name.length() == 0)
+                name = defName;
+            if (debug) {
+                System.out.println("\t\t[GssLoginModule] username from" +
+		    " shared state is " + name);
+            }
+            if (name != null && name.length() > 0)
+                return;
+        }
+
+        if (doNotPrompt)
+            return; // name may be null
+
+        if (callbackHandler == null)
+            throw new LoginException("No CallbackHandler "
+                                     + "available "
+                                     + "to prompt for authentication "
+                                     + "information from the user");
+
+        try {
+            String defUsername = System.getProperty("user.name");
+
+            MessageFormat form = new MessageFormat(
+                                   getAuthResourceString(
+                                   "GSS.name.defName."));
+            Object[] source =  {defUsername};
+            Callback[] callbacks = {new NameCallback(form.format(source))};
+            callbackHandler.handle(callbacks);
+            NameCallback callback = (NameCallback)callbacks[0];
+            name = callback.getName();
+            if (name != null && name.length() == 0)
+                name = null;
+            if (name == null && defUsername != null &&
+                    defUsername.length() != 0)
+                name = defUsername;
+        } catch (java.io.IOException ioe) {
+            throw new LoginException(ioe.getMessage());
+        } catch (UnsupportedCallbackException uce) {
+            throw new LoginException
+                (uce.getMessage()
+                 +" not available to garner "
+                 +" authentication information "
+                 +" from the user");
+        }
+        // name may still be null, which we take to mean "use default
+        // credentials"
+    }
+
+    private void promptForPass(boolean getPasswdFromSharedState)
+        throws LoginException {
+
+        char[] pw;
+
+        if (getPasswdFromSharedState) {
+            // use the password saved by the first module in the stack
+            pw = (char[])sharedState.get(PWD);
+            if (pw == null) {
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] password from" +
+			" shared state is null");
+                throw new LoginException
+                    ("Password can not be obtained from sharedstate ");
+            }
+            password = new String(pw);
+            return;
+        }
+        if (doNotPrompt)
+            throw new LoginException("Unable to prompt for password");
+
+        if (callbackHandler == null) {
+            throw new LoginException("No CallbackHandler "
+                                     + "available "
+                                     + "to garner authentication "
+                                     + "information from the user");
+        }
+        try {
+            Callback[] callbacks = new Callback[1];
+            MessageFormat form = new MessageFormat(
+                                     getAuthResourceString(
+                                     "Kerberos.password.for.username."));
+            Object[] source = {name};
+            callbacks[0] = new PasswordCallback(form.format(source), false);
+            callbackHandler.handle(callbacks);
+            char[] tmpPassword = ((PasswordCallback)
+                                  callbacks[0]).getPassword();
+            if (tmpPassword == null)
+                throw new LoginException("No password provided");
+            password = new String(tmpPassword);
+            ((PasswordCallback)callbacks[0]).clearPassword();
+
+            // clear tmpPassword
+            Arrays.fill(tmpPassword, ' ');
+        } catch (java.io.IOException ioe) {
+            throw new LoginException(ioe.getMessage());
+        } catch (UnsupportedCallbackException uce) {
+            throw new LoginException(uce.getMessage()
+                                     +" not available to garner "
+                                     +" authentication information "
+                                     + "from the user");
+        }
+    }
+
+    /**
+     * <p> This method is called if the LoginContext's
+     * overall authentication succeeded
+     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL
+     * LoginModules succeeded).</p>
+     *
+     * <p> If this LoginModule's own authentication attempt
+     * succeeded (checked by retrieving the private state saved by the
+     * <code>login</code> method), then this method associates a
+     * <code>GSSName</code>
+     * with the <code>Subject</code> located in the
+     * <code>LoginModule</code>. It adds GSS Credentials to the
+     * the Subject's private credentials set. If this LoginModule's own
+     * authentication attempted failed, then this method removes
+     * any state that was originally saved.</p>
+     *
+     * <p>
+     *
+     * @exception LoginException if the commit fails.</p>
+     *
+     * <p>
+     * @return true if this LoginModule's own login and commit
+     *          attempts succeeded, or false otherwise.</p>
+     */
+
+    public boolean commit() throws LoginException {
+        if (succeeded == false)
+            return false;
+
+        if (!useNative)
+            return false;
+
+        succeeded = false;
+        if (initiate && (gssICred == null)) {
+            gssName = null;
+            gssICred = null;
+            gssACred = null;
+            throw new LoginException("Null Initiator Credential");
+        }
+        if (accept && (gssACred == null)) {
+            gssName = null;
+            gssICred = null;
+            gssACred = null;
+            throw new LoginException("Null Acceptor Credential");
+        }
+        if (subject.isReadOnly()) {
+            gssName = null;
+            gssICred = null;
+            gssACred = null;
+            throw new LoginException("Subject is Readonly");
+        }
+
+        try {
+            if (initiate && gssName == null)
+                gssName = gssICred.getName();
+        } catch (GSSException e) {}
+        try {
+            if (accept && gssName == null)
+                gssName = gssACred.getName();
+        } catch (GSSException e) {}
+
+        Set<Object> privCredSet = subject.getPrivateCredentials();
+        Set<java.security.Principal> princSet = subject.getPrincipals();
+
+        if (gssName != null && !princSet.contains(gssName))
+            princSet.add(gssName);
+        if (gssICred != null && !privCredSet.contains(gssICred))
+            privCredSet.add(gssICred);
+        if (gssACred != null && !privCredSet.contains(gssACred))
+            privCredSet.add(gssACred);
+
+        succeeded = true;
+        commitSucceeded = true;
+        if (debug)
+            System.out.println("\t\t[GssLoginModule] commit Succeeded");
+        return true;
+    }
+
+    /**
+     * <p> This method is called if the LoginContext's
+     * overall authentication failed.
+     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL
+     * LoginModules did not succeed).</p>
+     *
+     * <p> If this LoginModule's own authentication attempt
+     * succeeded (checked by retrieving the private state saved by the
+     * <code>login</code> and <code>commit</code> methods),
+     * then this method cleans up any state that was originally
+     * saved.</p>
+     *
+     * <p>
+     *
+     * @exception LoginException if the abort fails.</p>
+     *
+     * <p>
+     * @return false if this LoginModule's own login and/or commit attempts
+     *          failed, and true otherwise.</p>
+     */
+
+    public boolean abort() throws LoginException {
+        if (succeeded == false) {
+            return false;
+        } else if (succeeded == true && commitSucceeded == false) {
+            // login succeeded but overall authentication failed
+            succeeded = false;
+        } else {
+            // overall authentication succeeded and commit succeeded,
+            // but someone else's commit failed
+            logout();
+        }
+        return true;
+    }
+
+    /**
+     * <p>Logout the user.</p>
+     *
+     * <p>This method removes the <code>GSSName</code> and
+     * <code>GSSCredential</code> added by the <code>commit</code> method.</p>
+     *
+     * <p>
+     *
+     * @exception LoginException if the logout fails.</p>
+     *
+     * <p>
+     * @return true in all cases since this <code>LoginModule</code>
+     *          should not be ignored.</p>
+     */
+    public boolean logout() throws LoginException {
+        /*
+         * See commentary in initialize().  By returning false we cause
+         * LoginContext to ignore this module.
+         */
+        if (!useNative)
+            return false;
+
+        if (subject.isReadOnly())
+            throw new LoginException("Subject is Readonly");
+
+        subject.getPrincipals().remove(gssName);
+        Iterator<Object> it = subject.getPrivateCredentials().iterator();
+        while (it.hasNext()) {
+            Object o = it.next();
+            if (o instanceof GSSCredential)
+                it.remove();
+        }
+
+        succeeded = false;
+        commitSucceeded = false;
+        if (debug)
+            System.out.println("\t\t[GSSLoginModule]: logged out Subject");
+        return true;
+    }
+
+    /**
+     * Clean out the state
+     */
+    private void cleanState() {
+
+        // save input as shared state only if
+        // authentication succeeded
+        if (succeeded) {
+            if (storePass &&
+                !sharedState.containsKey(NAME) &&
+                !sharedState.containsKey(PWD)) {
+                sharedState.put(NAME, name);
+                sharedState.put(PWD, password);
+            }
+        } else {
+            // remove temp results for the next try
+            gssName = null;
+            gssICred = null;
+            gssACred = null;
+        }
+        name = null;
+        password = null;
+        if (clearPass) {
+            sharedState.remove(NAME);
+            sharedState.remove(PWD);
+        }
+    }
+}
--- old/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java	2019-10-21 14:15:15.840458849 -0500
+++ new/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java	2019-10-21 14:15:15.844458799 -0500
@@ -27,6 +27,7 @@
 package com.sun.security.auth.module;
 
 import java.io.*;
+import java.security.Principal;
 import java.text.MessageFormat;
 import java.util.*;
 
@@ -409,7 +410,6 @@
     private Credentials cred = null;
 
     private PrincipalName principal = null;
-    private KerberosPrincipal kerbClientPrinc = null;
     private KerberosTicket kerbTicket = null;
     private KerberosKey[] kerbKeys = null;
     private StringBuffer krb5PrincName = null;
@@ -520,6 +520,16 @@
      */
     public boolean login() throws LoginException {
 
+        /*
+         * Perhaps we should wrap this in a method that returns false if this
+         * throws and sun.security.jgss.native=true.  Or perhaps the wrapper
+         * could see if it can acquire comparable GSS credentials and then
+         * store those in the subject in commit() in that case (and then
+         * GSSUtil/Krb5Util code could be changed to look for those).
+         *
+         * See related commentary in GssLoginModule.
+         */
+
         if (refreshKrb5Config) {
             try {
                 if (debug) {
@@ -532,18 +542,30 @@
                 throw le;
             }
         }
+
+        // -Dsun.security.krb5.principal takes precedence over login module
+        // "principal" option
+        //
+        // XXX This seems misplaced.  This is configuration reading, and that
+        // clearly belongs in initialize().  It's not like it's very likely
+        // that this sequence of events takes place anywhere, much less that we
+        // should cater to it:
+        //
+        //  lc.initialize();
+        //  System.setProperty("sun.security.krb5.principal", ...);
+        //  lc.login();
         String principalProperty = System.getProperty
             ("sun.security.krb5.principal");
         if (principalProperty != null) {
             krb5PrincName = new StringBuffer(principalProperty);
-        } else {
-            if (princName != null) {
-                krb5PrincName = new StringBuffer(princName);
-            }
+        } else if (princName != null) {
+            krb5PrincName = new StringBuffer(princName);
         }
 
+        // XXX This really belongs in initialize()
         validateConfiguration();
 
+        // XXX This really belongs in validateConfiguration()
         if (krb5PrincName != null && krb5PrincName.toString().equals("*")) {
             unboundServer = true;
         }
@@ -632,52 +654,31 @@
         }
 
         try {
+            // This means "from the traditional FILE ccache"
             if (useTicketCache) {
-                // ticketCacheName == null implies the default cache
                 if (debug)
-                    System.out.println("Acquire TGT from Cache");
-                cred  = Credentials.acquireTGTFromCache
-                    (principal, ticketCacheName);
-
+                    System.out.println("Trying to acquire TGT from Cache");
+                cred = getCredsFromCCache(principal, renewTGT, ticketCacheName);
                 if (cred != null) {
-                    if (renewTGT && isOld(cred)) {
-                        // renew if ticket is old.
-                        Credentials newCred = renewCredentials(cred);
-                        if (newCred != null) {
-                            newCred.setProxy(cred.getProxy());
-                            cred = newCred;
-                        }
-                    }
+                    if (principal == null)
+                        principal = cred.getClient();
                     if (!isCurrent(cred)) {
-                        // credentials have expired
                         cred = null;
                         if (debug)
-                            System.out.println("Credentials are" +
-                                    " no longer valid");
-                    }
-                }
-
-                if (cred != null) {
-                   // get the principal name from the ticket cache
-                   if (principal == null) {
-                        principal = cred.getClient();
-                   }
-                }
-                if (debug) {
-                    System.out.println("Principal is " + principal);
-                    if (cred == null) {
-                        System.out.println
-                            ("null credentials from Ticket Cache");
+                            System.out.println("Found expired cached " +
+                                    "credentials for " + principal);
+                    } else if (debug) {
+                        System.out.println("Found cached credentials for "
+                                + principal);
                     }
+                } else if (debug) {
+                    System.out.println("Could not find cached credentials");
                 }
             }
 
-            // cred = null indicates that we didn't get the creds
-            // from the cache or useTicketCache was false
-
             if (cred == null) {
-                // We need the principal name whether we use keytab
-                // or AS Exchange
+                // !useTicketCache || credentials not found || expired
+
                 if (principal == null) {
                     promptForName(getPasswdFromSharedState);
                     principal = new PrincipalName
@@ -685,49 +686,19 @@
                          PrincipalName.KRB_NT_PRINCIPAL);
                 }
 
-                /*
-                 * Before dynamic KeyTab support (6894072), here we check if
-                 * the keytab contains keys for the principal. If no, keytab
-                 * will not be used and password is prompted for.
-                 *
-                 * After 6894072, we normally don't check it, and expect the
-                 * keys can be populated until a real connection is made. The
-                 * check is still done when isInitiator == true, where the keys
-                 * will be used right now.
-                 *
-                 * Probably tricky relations:
-                 *
-                 * useKeyTab is config flag, but when it's true but the ktab
-                 * does not contains keys for principal, we would use password
-                 * and keep the flag unchanged (for reuse?). In this method,
-                 * we use (ktab != null) to check whether keytab is used.
-                 * After this method (and when storeKey == true), we use
-                 * (encKeys == null) to check.
-                 */
                 if (useKeyTab) {
-                    if (!unboundServer) {
-                        KerberosPrincipal kp =
-                                new KerberosPrincipal(principal.getName());
-                        ktab = (keyTabName == null)
-                                ? KeyTab.getInstance(kp)
-                                : KeyTab.getInstance(kp, new File(keyTabName));
-                    } else {
-                        ktab = (keyTabName == null)
-                                ? KeyTab.getUnboundInstance()
-                                : KeyTab.getUnboundInstance(new File(keyTabName));
-                    }
-                    if (isInitiator) {
-                        if (Krb5Util.keysFromJavaxKeyTab(ktab, principal).length
+                    ktab = getKtab(keyTabName, principal, unboundServer);
+                    if (isInitiator &&
+                            Krb5Util.keysFromJavaxKeyTab(ktab, principal).length
                                 == 0) {
-                            ktab = null;
-                            if (debug) {
-                                System.out.println
-                                    ("Key for the principal " +
-                                     principal  +
-                                     " not available in " +
-                                     ((keyTabName == null) ?
-                                      "default key tab" : keyTabName));
-                            }
+                        ktab = null;
+                        if (debug) {
+                            System.out.println
+                                ("Key for the principal " +
+                                 principal  +
+                                 " not available in " +
+                                 ((keyTabName == null) ?
+                                  "default key tab" : keyTabName));
                         }
                     }
                 }
@@ -737,16 +708,21 @@
                 if (ktab == null) {
                     promptForPass(getPasswdFromSharedState);
                     builder = new KrbAsReqBuilder(principal, password);
-                    if (isInitiator) {
-                        // XXX Even if isInitiator=false, it might be
-                        // better to do an AS-REQ so that keys can be
-                        // updated with PA info
+                    if (isInitiator || storeKey) {
+                        // Even if isInitiator=false, if we want to accept with
+                        // long-term key derived from the password, then in
+                        // principle (and decidedly for new enctypes) we need
+                        // to do an AS exchange to get the PA etype info for
+                        // the derivation.  (For older enctypes this is bad, as
+                        // we will attempt to talk the a KDC we might not be
+                        // able to reach, then timeout...  If this is not
+                        // desired, the user can reconfigure the module.)
                         cred = builder.action().getCreds();
-                    }
-                    if (storeKey) {
-                        encKeys = builder.getKeys(isInitiator);
-                        // When encKeys is empty, the login actually fails.
-                        // For compatibility, exception is thrown in commit().
+                        if (storeKey) {
+                            encKeys = builder.getKeys(isInitiator);
+                            // When encKeys is empty, the login actually fails.
+                            // For compatibility, exception is thrown in commit().
+                        }
                     }
                 } else {
                     builder = new KrbAsReqBuilder(principal, ktab);
@@ -763,15 +739,15 @@
                         System.out.println("Will use keytab");
                     } else if (storeKey) {
                         for (int i = 0; i < encKeys.length; i++) {
+                            // Printing keys here just because debug is a bad
+                            // idea: stdout might be a file that gets sent to
+                            // loggers, and...  yeah, no.
                             System.out.println("EncryptionKey: keyType=" +
-                                encKeys[i].getEType() +
-                                " keyBytes (hex dump)=" +
-                                hd.encodeBuffer(encKeys[i].getBytes()));
+                                encKeys[i].getEType());
                         }
                     }
                 }
 
-                // we should hava a non-null cred
                 if (isInitiator && (cred == null)) {
                     throw new LoginException
                         ("TGT Can not be obtained from the KDC ");
@@ -962,6 +938,29 @@
         }
     }
 
+    private Credentials getCredsFromCCache(PrincipalName princ, boolean renewTGT, String ccacheName)
+        throws KrbException, IOException {
+        // ticketCacheName == null implies the default cache
+        // princ == null implies the cache's default princ(XXX?)
+        Credentials creds = Credentials.acquireTGTFromCache(princ, ccacheName);
+        if (creds == null)
+            return null;
+        if (renewTGT && timeToRenew(creds))
+            creds = possiblyRenewCreds(creds);
+        // It's the caller's job to deal with expired creds
+        return creds;
+    }
+
+    private KeyTab getKtab(String keyTabName, PrincipalName principal,
+            boolean unboundServer)
+    {
+        KerberosPrincipal kp = unboundServer ? null :
+            new KerberosPrincipal(principal.getName());;
+        return (keyTabName == null)
+            ? KeyTab.getInstance(kp) // default keytab
+            : KeyTab.getInstance(kp, new File(keyTabName));
+    }
+
     private static boolean isCurrent(Credentials creds)
     {
         Date endTime = creds.getEndTime();
@@ -971,47 +970,60 @@
         return true;
     }
 
-    private static boolean isOld(Credentials creds)
+    private static boolean timeToRenew(Credentials creds)
     {
+        if (!creds.isRenewable())
+            return false;
+
         Date endTime = creds.getEndTime();
-        if (endTime != null) {
-            Date authTime = creds.getAuthTime();
-            long now = System.currentTimeMillis();
-            if (authTime != null) {
-                // pass the mid between auth and end
-                return now - authTime.getTime() > endTime.getTime() - now;
-            } else {
-                // will expire in less than 2 hours
-                return now <= endTime.getTime() - 1000*3600*2L;
-            }
-        }
-        return false;
+
+        // endtime is required, so it can't be null.  We only have to check
+        // because it's Java and we could express that this can't be null.
+        // Strictly speaking we can leave out this test.
+        if (endTime == null)
+            return false;
+
+        // There's no point trying to renew a TGT we will be able to renew but
+        // with no additional lifetime.  And there's no point trying to renew
+        // non-renewable tickets.
+        Date renewTill = creds.getRenewTill();
+        if (renewTill == null || renewTill.getTime() <= endTime.getTime())
+            return false;
+
+        // NOTE WELL: We must use the *start* time, not the auth time, because
+        //            the auth time refers to when the AS exchange was done,
+        //            not to when the TGS exchange was done.  For very
+        //            long-lived TGTs using authTime here means renewing all
+        //            the time!
+        Date startTime = creds.getStartTime();
+        long now = System.currentTimeMillis();
+        // Start time can be null
+        if (startTime != null)
+            // past the mid between start and end
+            return now - startTime.getTime() > endTime.getTime() - now;
+        // will it expire in less than 2 hours?
+        return now <= endTime.getTime() - 1000*3600*2L;
     }
 
-    private Credentials renewCredentials(Credentials creds)
+    private Credentials possiblyRenewCreds(Credentials creds)
+        throws KrbException, IOException
     {
-        Credentials lcreds;
+        if (!creds.isRenewable())
+            return creds;
+
+        if (System.currentTimeMillis() > cred.getRenewTill().getTime())
+            return creds;
+
         try {
-            if (!creds.isRenewable())
-                throw new RefreshFailedException("This ticket" +
-                                " is not renewable");
-            if (creds.getRenewTill() == null) {
-                // Renewable ticket without renew-till. Illegal and ignored.
-                return creds;
-            }
-            if (System.currentTimeMillis() > cred.getRenewTill().getTime())
-                throw new RefreshFailedException("This ticket is past "
-                                             + "its last renewal time.");
-            lcreds = creds.renew();
+            creds = creds.renew();
             if (debug)
                 System.out.println("Renewed Kerberos Ticket");
         } catch (Exception e) {
-            lcreds = null;
             if (debug)
                 System.out.println("Ticket could not be renewed : "
                                 + e.getMessage());
         }
-        return lcreds;
+        return creds;
     }
 
     /**
@@ -1037,111 +1049,117 @@
      */
 
     public boolean commit() throws LoginException {
-
         /*
          * Let us add the Krb5 Creds to the Subject's
          * private credentials. The credentials are of type
          * KerberosKey or KerberosTicket
          */
         if (succeeded == false) {
+            cleanKerberosCred();
             return false;
-        } else {
+        }
 
-            if (isInitiator && (cred == null)) {
-                succeeded = false;
-                throw new LoginException("Null Client Credential");
-            }
+        if (isInitiator && (cred == null)) {
+            cleanKerberosCred();
+            succeeded = false;
+            throw new LoginException("Null Client Credential");
+        }
 
-            if (subject.isReadOnly()) {
-                cleanKerberosCred();
-                throw new LoginException("Subject is Readonly");
-            }
+        if (subject.isReadOnly()) {
+            cleanKerberosCred();
+            succeeded = false;
+            throw new LoginException("Subject is Readonly");
+        }
 
-            /*
-             * Add the Principal (authenticated identity)
-             * to the Subject's principal set and
-             * add the credentials (TGT or Service key) to the
-             * Subject's private credentials
-             */
-
-            Set<Object> privCredSet =  subject.getPrivateCredentials();
-            Set<java.security.Principal> princSet  = subject.getPrincipals();
-            kerbClientPrinc = new KerberosPrincipal(principal.getName());
+        try {
+            setupSubject(subject, unboundServer ? null : principal, ktab,
+                    storeKey && encKeys != null ? encKeys : null);
+            if (debug)
+                System.out.println("Added Kerberos credentials to subject");
+            return true;
+        } catch (Exception e) {
+            cleanKerberosCred();
+            succeeded = false;
+            throw new LoginException(e.getMessage());
+        }
+    }
 
-            // create Kerberos Ticket
-            if (isInitiator) {
-                kerbTicket = Krb5Util.credsToTicket(cred);
-                if (cred.getProxy() != null) {
-                    KerberosSecrets.getJavaxSecurityAuthKerberosAccess()
-                            .kerberosTicketSetProxy(kerbTicket,Krb5Util.credsToTicket(cred.getProxy()));
-                }
-            }
+    /**
+     * Store the given Kerberos crendentials in the given subject.
+     *
+     * @param subject the {@code Subject} to store the credentials into
+     *
+     * @param principal the {@code PrincipalName} for the credentials; use null to refer to all principals in the keytab
+     *
+     * @param ktab a {@code KeyTab} keytab to use for acting as a service (may be null)
+     *
+     * @param kerbTicket the TGT for the principal (if acting as a client)
+     *
+     * @param encKeys long-term secret keys for the principal (if acting as a server with the keys derived from a password)
+     *
+     */
+    private static void setupSubject(Subject subject, PrincipalName principal,
+            KeyTab ktab, KerberosTicket kerbTicket, EncryptionKey[] encKeys)
+        throws LoginException {
 
-            if (storeKey && encKeys != null) {
-                if (encKeys.length == 0) {
-                    succeeded = false;
-                    throw new LoginException("Null Server Key ");
-                }
+        KerberosTicket kerbTicket = null;
 
-                kerbKeys = new KerberosKey[encKeys.length];
-                for (int i = 0; i < encKeys.length; i ++) {
-                    Integer temp = encKeys[i].getKeyVersionNumber();
-                    kerbKeys[i] = new KerberosKey(kerbClientPrinc,
-                                          encKeys[i].getBytes(),
-                                          encKeys[i].getEType(),
-                                          (temp == null?
-                                          0: temp.intValue()));
-                }
+        // create Kerberos Ticket
+        if (isInitiator) {
+          kerbTicket = Krb5Util.credsToTicket(cred);
+          if (cred.getProxy() != null) {
+            KerberosSecrets.getJavaxSecurityAuthKerberosAccess()
+              .kerberosTicketSetProxy(kerbTicket,Krb5Util.credsToTicket(cred.getProxy()));
+          }
+        }
+        /*
+         * Add the Principal (authenticated identity)
+         * to the Subject's principal set and
+         * add the credentials (TGT or Service key) to the
+         * Subject's private credentials
+         */
 
-            }
-            // Let us add the kerbClientPrinc,kerbTicket and KeyTab/KerbKey (if
-            // storeKey is true)
+        if (kerbTicket == null && encKeys == null && ktab == null)
+            throw new LoginException("No Kerberos credentials provided to " +
+                    "store in subject");
 
-            // We won't add "*" as a KerberosPrincipal
-            if (!unboundServer &&
-                    !princSet.contains(kerbClientPrinc)) {
-                princSet.add(kerbClientPrinc);
-            }
+        Set<Object> privCredSet = subject.getPrivateCredentials();
+        Set<Principal> princSet = subject.getPrincipals();
 
-            // add the TGT
-            if (kerbTicket != null) {
-                if (!privCredSet.contains(kerbTicket))
-                    privCredSet.add(kerbTicket);
-            }
+        KerberosPrincipal princ = null;
+        if (principal != null) {
+            princ = new KerberosPrincipal(principal.getName());
+            if (!princSet.contains(princ))
+                princSet.add(princ);
+        }
 
-            if (storeKey) {
-                if (encKeys == null) {
-                    if (ktab != null) {
-                        if (!privCredSet.contains(ktab)) {
-                            privCredSet.add(ktab);
-                        }
-                    } else {
-                        succeeded = false;
-                        throw new LoginException("No key to store");
-                    }
-                } else {
-                    for (int i = 0; i < kerbKeys.length; i ++) {
-                        if (!privCredSet.contains(kerbKeys[i])) {
-                            privCredSet.add(kerbKeys[i]);
-                        }
-                        encKeys[i].destroy();
-                        encKeys[i] = null;
-                        if (debug) {
-                            System.out.println("Added server's key"
-                                            + kerbKeys[i]);
-                            System.out.println("\t\t[Krb5LoginModule] " +
-                                           "added Krb5Principal  " +
-                                           kerbClientPrinc.toString()
-                                           + " to Subject");
-                        }
-                    }
-                }
-            }
+        if (kerbTicket != null && !privCredSet.contains(kerbTicket))
+            privCredSet.add(kerbTicket);
+
+        if (ktab != null && !privCredSet.contains(ktab))
+            privCredSet.add(ktab);
+
+        if (encKeys == null)
+            return;
+
+        if (encKeys.length == 0)
+            throw new LoginException("Cannot store empty long-term " +
+                    "keyset in Subject");
+
+        if (princ == null)
+            throw new LoginException("Cannot store Kerberos long-term keys " +
+                    "for wild-card principal in Subject");
+
+        for (int i = 0; i < encKeys.length; i ++) {
+            Integer temp = encKeys[i].getKeyVersionNumber();
+            KerberosKey kerbKey = new KerberosKey(princ,
+                    encKeys[i].getBytes(),
+                    encKeys[i].getEType(),
+                    (temp == null?
+                     0: temp.intValue()));
+            if (!privCredSet.contains(kerbKey))
+                privCredSet.add(kerbKey);
         }
-        commitSucceeded = true;
-        if (debug)
-            System.out.println("Commit Succeeded \n");
-        return true;
     }
 
     /**
@@ -1199,8 +1217,13 @@
             throw new LoginException("Subject is Readonly");
         }
 
-        subject.getPrincipals().remove(kerbClientPrinc);
-           // Let us remove all Kerberos credentials stored in the Subject
+        Iterator<Principal> itp = subject.getPrincipals().iterator();
+        while (itp.hasNext()) {
+            Object o = itp.next();
+            if (o instanceof KerberosPrincipal)
+                itp.remove();
+        }
+
         Iterator<Object> it = subject.getPrivateCredentials().iterator();
         while (it.hasNext()) {
             Object o = it.next();
@@ -1239,9 +1262,12 @@
             throw new LoginException
                 ("Destroy Failed on Kerberos Private Credentials");
         }
+        for (int i = 0; i < kerbKeys.length; i++) {
+            encKeys[i].destroy();
+            encKeys[i] = null;
+        }
         kerbTicket = null;
         kerbKeys = null;
-        kerbClientPrinc = null;
     }
 
     /**
--- old/test/jdk/sun/security/jgss/DefaultGssConfig.java	2019-10-21 14:15:16.028456485 -0500
+++ new/test/jdk/sun/security/jgss/DefaultGssConfig.java	2019-10-21 14:15:16.048456234 -0500
@@ -58,6 +58,10 @@
         Configuration.getConfiguration();
 
         // 3. Make sure there're default entries for GSS krb5 client/server
+        //
+        // FIXME Why be so Kerberos-specific?  This is wrong.  Instead we could
+        // use a command-line argument to deal with a specific (or all)
+        // mechanisms.
         LoginConfigImpl lc = new LoginConfigImpl(GSSCaller.CALLER_INITIATE, GSSUtil.GSS_KRB5_MECH_OID);
         if (lc.getAppConfigurationEntry("").length == 0) {
             throw new Exception("No default config for GSS krb5 client");
