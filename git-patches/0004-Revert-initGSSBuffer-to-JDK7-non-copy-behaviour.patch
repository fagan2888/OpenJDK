From e11f2a6a7e063e7828dddc26cbc5ab698035eb88 Mon Sep 17 00:00:00 2001
From: Viktor Dukhovni <viktor@twosigma.com>
Date: Thu, 12 Nov 2015 06:43:43 +0000
Subject: [PATCH 04/24] Revert initGSSBuffer to JDK7 non-copy behaviour

---
 .../share/native/libj2gss/GSSLibStub.c        | 79 ++++++++++---------
 .../share/native/libj2gss/NativeUtil.c        | 40 +++++++---
 .../share/native/libj2gss/NativeUtil.h        |  4 +-
 3 files changed, 69 insertions(+), 54 deletions(-)

diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index 4bb2ce1c74..4a5096467f 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -149,21 +149,20 @@ Java_sun_security_jgss_wrapper_GSSLibStub_getMechPtr(JNIEnv *env,
  * Utility routine which releases the specified gss_channel_bindings_t
  * structure.
  */
-void deleteGSSCB(gss_channel_bindings_t cb) {
-
+static void deleteGSSCB(JNIEnv *env, gss_channel_bindings_t cb) {
   if (cb == GSS_C_NO_CHANNEL_BINDINGS) return;
 
   /* release initiator address */
   if (cb->initiator_addrtype != GSS_C_AF_NULLADDR) {
-    resetGSSBuffer(&(cb->initiator_address));
+    resetGSSBuffer(env, NULL, &(cb->initiator_address));
   }
   /* release acceptor address */
   if (cb->acceptor_addrtype != GSS_C_AF_NULLADDR) {
-    resetGSSBuffer(&(cb->acceptor_address));
+    resetGSSBuffer(env, NULL, &(cb->acceptor_address));
   }
   /* release application data */
-  if (cb->application_data.length != 0) {
-    resetGSSBuffer(&(cb->application_data));
+  if (cb->application_data.value != NULL) {
+    resetGSSBuffer(env, NULL, &(cb->application_data));
   }
   free(cb);
 }
@@ -188,9 +187,11 @@ gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
     return NULL;
   }
 
-  // initialize addrtype in CB first
+  /* Fully initialize to a state safe for cleanup */
   cb->initiator_addrtype = GSS_C_AF_NULLADDR;
   cb->acceptor_addrtype = GSS_C_AF_NULLADDR;
+  cb->application_data.length = 0;
+  cb->application_data.value = NULL;
 
   // addresses needs to be initialized to empty
   memset(&cb->initiator_address, 0, sizeof(cb->initiator_address));
@@ -208,11 +209,11 @@ gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
-    cb->initiator_addrtype = GSS_C_AF_INET;
-    initGSSBuffer(env, value, &(cb->initiator_address));
+    initGSSBuffer(env, value, &(cb->initiator_address), JNI_TRUE);
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
+    cb->initiator_addrtype = GSS_C_AF_INET;
   }
   /* set up acceptor address */
   jinetAddr = (*env)->CallObjectMethod(env, jcb,
@@ -226,11 +227,11 @@ gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
-    cb->acceptor_addrtype = GSS_C_AF_INET;
-    initGSSBuffer(env, value, &(cb->acceptor_address));
+    initGSSBuffer(env, value, &(cb->acceptor_address), JNI_TRUE);
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
+    cb->acceptor_addrtype = GSS_C_AF_INET;
   }
   /* set up application data */
   value = (*env)->CallObjectMethod(env, jcb,
@@ -238,13 +239,13 @@ gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
   if ((*env)->ExceptionCheck(env)) {
     goto cleanup;
   }
-  initGSSBuffer(env, value, &(cb->application_data));
+  initGSSBuffer(env, value, &(cb->application_data), JNI_TRUE);
   if ((*env)->ExceptionCheck(env)) {
     goto cleanup;
   }
   return cb;
 cleanup:
-  deleteGSSCB(cb);
+  deleteGSSCB(env, cb);
   return NULL;
 }
 
@@ -366,14 +367,14 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importName(JNIEnv *env,
 
   TRACE0("[GSSLibStub_importName]");
 
-  initGSSBuffer(env, jnameVal, &nameVal);
+  initGSSBuffer(env, jnameVal, &nameVal, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
       return jlong_zero;
   }
 
   nameType = newGSSOID(env, jnameType);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&nameVal);
+    resetGSSBuffer(env, jnameVal, &nameVal);
     return jlong_zero;
   }
 
@@ -385,7 +386,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importName(JNIEnv *env,
 
   /* release intermediate buffers */
   deleteGSSOID(nameType);
-  resetGSSBuffer(&nameVal);
+  resetGSSBuffer(env, jnameVal, &nameVal);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_importName]");
   if ((*env)->ExceptionCheck(env)) {
@@ -781,7 +782,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importContext(JNIEnv *env,
   TRACE0("[GSSLibStub_importContext]");
 
   contextHdl = GSS_C_NO_CONTEXT;
-  initGSSBuffer(env, jctxtToken, &ctxtToken);
+  initGSSBuffer(env, jctxtToken, &ctxtToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -793,7 +794,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importContext(JNIEnv *env,
   TRACE1("[GSSLibStub_importContext] pContext=%" PRIuPTR "", (uintptr_t) contextHdl);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&ctxtToken);
+  resetGSSBuffer(env, jctxtToken, &ctxtToken);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext]");
   /* return immediately if an exception has occurred */
@@ -874,9 +875,9 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
     return NULL;
   }
 
-  initGSSBuffer(env, jinToken, &inToken);
+  initGSSBuffer(env, jinToken, &inToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
-    deleteGSSCB(cb);
+    deleteGSSCB(env, cb);
     return NULL;
   }
 
@@ -931,8 +932,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
   }
 
   /* release intermediate buffers before checking status */
-  deleteGSSCB(cb);
-  resetGSSBuffer(&inToken);
+  deleteGSSCB(env, cb);
+  resetGSSBuffer(env, jinToken, &inToken);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_initContext]");
   if ((*env)->ExceptionCheck(env)) {
@@ -980,13 +981,13 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
   contextHdl = contextHdlSave = (gss_ctx_id_t)jlong_to_ptr(
     (*env)->GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
-  initGSSBuffer(env, jinToken, &inToken);
+  initGSSBuffer(env, jinToken, &inToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
   cb = newGSSCB(env, jcb);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&inToken);
+    resetGSSBuffer(env, jinToken, &inToken);
     return NULL;
   }
   setTarget = (credHdl == GSS_C_NO_CREDENTIAL);
@@ -1006,8 +1007,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
                            &aFlags, &aTime, &delCred);
   /* release intermediate buffers before checking status */
 
-  deleteGSSCB(cb);
-  resetGSSBuffer(&inToken);
+  deleteGSSCB(env, cb);
+  resetGSSBuffer(env, jinToken, &inToken);
 
   TRACE3("[GSSLibStub_acceptContext] after: pCred=%" PRIuPTR ", pContext=%" PRIuPTR ", pDelegCred=%" PRIuPTR "",
         (uintptr_t)credHdl, (uintptr_t)contextHdl, (uintptr_t) delCred);
@@ -1444,18 +1445,17 @@ Java_sun_security_jgss_wrapper_GSSLibStub_getMic(JNIEnv *env, jobject jobj,
     return NULL;
   }
   qop = (gss_qop_t) jqop;
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
 
   /* gss_get_mic(...) => GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
      GSS_S_BAD_QOP */
-  major =
-    (*ftab->getMic)(&minor, contextHdl, qop, &msg, &msgToken);
+  major = (*ftab->getMic)(&minor, contextHdl, qop, &msg, &msgToken);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
+  resetGSSBuffer(env, jmsg, &msg);
   checkStatus(env, jobj, major, minor, "[GSSLibStub_getMic]");
   if ((*env)->ExceptionCheck(env)) {
     (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
@@ -1499,12 +1499,12 @@ Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
   qop = (gss_qop_t) (*env)->CallIntMethod(env, jprop, MID_MessageProp_getQOP);
   if ((*env)->ExceptionCheck(env)) { return; }
 
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) { return; }
 
-  initGSSBuffer(env, jmsgToken, &msgToken);
+  initGSSBuffer(env, jmsgToken, &msgToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&msg);
+    resetGSSBuffer(env, jmsg, &msg);
     return;
   }
 
@@ -1515,8 +1515,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
     (*ftab->verifyMic)(&minor, contextHdl, &msg, &msgToken, &qop);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
-  resetGSSBuffer(&msgToken);
+  resetGSSBuffer(env, jmsg, &msg);
+  resetGSSBuffer(env, jmsgToken, &msgToken);
 
   /*
    * We don't throw on supplementary status codes here, instead we pass only
@@ -1580,7 +1580,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
     return NULL;
   }
 
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1591,8 +1591,9 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
                    &msgToken);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
+  resetGSSBuffer(env, jmsg, &msg);
   checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
+
   if ((*env)->ExceptionCheck(env)) {
     (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
     return NULL;
@@ -1643,7 +1644,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
     return NULL;
   }
 
-  initGSSBuffer(env, jmsgToken, &msgToken);
+  initGSSBuffer(env, jmsgToken, &msgToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1657,7 +1658,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
     (*ftab->unwrap)(&minor, contextHdl, &msgToken, &msg, &confState, &qop);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msgToken);
+  resetGSSBuffer(env, jmsgToken, &msgToken);
 
   /*
    * We don't throw on supplementary status codes here, instead we pass only
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
index 68caa76b68..274e706497 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
@@ -590,45 +590,59 @@ void checkStatus(JNIEnv *env, jobject jstub, OM_uint32 major,
  * Utility routine for initializing gss_buffer_t structure
  * with the byte[] in the specified jbyteArray object.
  * NOTE: must call resetGSSBuffer() to free up the resources
- * inside the gss_buffer_t structure.
  */
 void initGSSBuffer(JNIEnv *env, jbyteArray jbytes,
-                     gss_buffer_t cbytes) {
-
-  int len;
+                     gss_buffer_t cbytes, jboolean wantCopy)
+{
+  jboolean isCopy;
+  jint len;
   void* value;
 
   cbytes->length = 0;
   cbytes->value = NULL;
 
-  if (jbytes == NULL)
+  if (jbytes == NULL ||
+      (len = (*env)->GetArrayLength(env, jbytes)) == 0)
     return;
 
-  len = (*env)->GetArrayLength(env, jbytes);
+  cbytes->length = len;
+
+  if (wantCopy == JNI_FALSE) {
+    cbytes->value = (*env)->GetByteArrayElements(env, jbytes, &isCopy);
+    if (cbytes->value == NULL) {
+      throwOutOfMemoryError(env, NULL);
+    }
+    return;
+  }
+
   value = malloc(len);
   if (value == NULL) {
     throwOutOfMemoryError(env, NULL);
     return;
   }
+
   (*env)->GetByteArrayRegion(env, jbytes, 0, len, value);
   if ((*env)->ExceptionCheck(env)) {
     free(value);
     return;
   }
-  cbytes->length = len;
   cbytes->value = value;
 }
 
 /*
- * Utility routine for freeing the bytes malloc'ed
- * in initGSSBuffer() method.
- * NOTE: used in conjunction with initGSSBuffer(...).
+ * Utility routine for freeing the buffer obtained via initGSSBuffer().
+ * If jbytes is null this is a malloced copy.
  */
-void resetGSSBuffer(gss_buffer_t cbytes) {
-  if ((cbytes != NULL) && (cbytes != GSS_C_NO_BUFFER)) {
+void resetGSSBuffer(JNIEnv *env, jbyteArray jbytes, gss_buffer_t cbytes)
+{
+  if (cbytes->value == NULL)
+    return;
+  if (jbytes != NULL) {
+    (*env)->ReleaseByteArrayElements(env, jbytes, cbytes->value, JNI_ABORT);
+  } else if (cbytes->length > 0) {
     free(cbytes->value);
-    cbytes->length = 0;
     cbytes->value = NULL;
+    cbytes->length = 0;
   }
 }
 
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
index dd7a6019e3..7b35a9929e 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
@@ -39,8 +39,8 @@ extern "C" {
   extern void checkStatus(JNIEnv *, jobject, OM_uint32, OM_uint32, const char *);
   extern jint checkTime(OM_uint32);
   extern void throwOutOfMemoryError(JNIEnv *, const char*);
-  extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
-  extern void resetGSSBuffer(gss_buffer_t);
+  extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t, jboolean);
+  void resetGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
   void initGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
   void resetGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
 
-- 
2.17.1

