commit 3242b395dfbef788ede70a9f6b3bf704ebd1c57f
Author: Nicolas Williams <nico@cryptonector.com>
Date:   Fri Jun 14 21:50:40 2019 -0500

    GssLoginModule: code review
    
    Code review comments by Peter Burka.

diff --git a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/GssLoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/GssLoginModule.java
index 404a94cbcc..81dfbbee3f 100644
--- a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/GssLoginModule.java
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/GssLoginModule.java
@@ -25,13 +25,21 @@
 
 package com.sun.security.auth.module;
 
-import java.io.*;
 import java.text.MessageFormat;
-import java.util.*;
-import javax.security.auth.*;
-import javax.security.auth.callback.*;
-import javax.security.auth.login.*;
-import javax.security.auth.spi.*;
+import java.util.Map;
+import java.util.Set;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import javax.security.auth.Subject;
+import javax.security.auth.SubjectDomainCombiner;
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.auth.login.LoginException;
+import javax.security.auth.spi.LoginModule;
 
 import org.ietf.jgss.GSSManager;
 import org.ietf.jgss.GSSException;
@@ -223,9 +231,16 @@ public class GssLoginModule implements LoginModule {
     private static final String NAME = "javax.security.auth.login.name";
     private static final String PWD = "javax.security.auth.login.password";
 
-    private String getWithDefault(String key, String defval) {
+    private String getString(String key) {
+        return (String)options.get(key);
+    }
+    private boolean getBool(String key) {
+        String value = (String)options.get(key);
+        return value != null ? Boolean.parseBoolean(value) : false;
+    }
+    private boolean getBoolWithDefault(String key, boolean defval) {
         String value = (String)options.get(key);
-        return value != null ? value : defval;
+        return value != null ? Boolean.parseBoolean(value) : defval;
     }
 
     private void storeAddKeyValue(String key, String value) {
@@ -238,7 +253,7 @@ public class GssLoginModule implements LoginModule {
 
     private void storeAddOption(String optionName, String key) {
         if (options.containsKey(optionName)) {
-            storeAddKeyValue(key, (String)options.get(optionName));
+            storeAddKeyValue(key, getString(optionName));
         }
     }
 
@@ -307,8 +322,7 @@ public class GssLoginModule implements LoginModule {
          * (It has never been possible to express such a policy, so we lose
          * nothing by punting here when sun.security.jgss.native=false.)
          */
-        useNative = "true".equalsIgnoreCase(
-                System.getProperty("sun.security.jgss.native"));
+        useNative = Boolean.getBoolean("sun.security.jgss.native");
         if (!useNative)
             return;
 
@@ -316,11 +330,10 @@ public class GssLoginModule implements LoginModule {
 
         // initialize any configured options
 
-        debug = "true".equalsIgnoreCase((String)options.get("debug"));
-        doNotPrompt =
-            "true".equalsIgnoreCase(getWithDefault("doNotPrompt", "true"));
-        defName = (String)options.get("name");
-        nametype = (String)options.get("nametype");
+        debug = getBool("debug");
+        doNotPrompt = getBool("doNotPrompt");
+        defName = getString("name");
+        nametype = getString("nametype");
 
         if (defName == null)
             defName = System.getProperty("sun.security.gss.name");
@@ -349,26 +362,14 @@ public class GssLoginModule implements LoginModule {
         storeAddOption("ticketCache", "ccache");
         storeAddOption("replayCache", "rcache");
 
-        tryFirstPass =
-            "true".equalsIgnoreCase(getWithDefault("tryFirstPass", "true"));
-        useFirstPass =
-            "true".equalsIgnoreCase(
-                getWithDefault("useFirstPass",
-                    doNotPrompt ? "true" : "false"));
-        storePass =
-            "true".equalsIgnoreCase((String)options.get("storePass"));
-        clearPass =
-            "true".equalsIgnoreCase((String)options.get("clearPass"));
-        initiate =
-            "true".equalsIgnoreCase((String)options.get("initiate"));
-        accept =
-            "true".equalsIgnoreCase((String)options.get("accept"));
-        tryDefaultCreds =
-            "true".equalsIgnoreCase(getWithDefault("tryDefaultCreds", "true"));
-        useDefaultCreds =
-            "true".equalsIgnoreCase(
-                getWithDefault("useDefaultCreds",
-                    doNotPrompt ? "true" : "false"));
+        tryFirstPass = getBool("tryFirstPass");
+        useFirstPass = getBoolWithDefault("useFirstPass", doNotPrompt);
+        storePass = getBool("storePass");
+        clearPass = getBool("clearPass");
+        initiate = getBool("initiate");
+        accept = getBool("accept");
+        tryDefaultCreds = getBool("tryDefaultCreds");
+        useDefaultCreds = getBoolWithDefault("useDefaultCreds", doNotPrompt);
         if (!initiate && !accept)
             initiate = true;
         if (debug) {
@@ -582,14 +583,14 @@ public class GssLoginModule implements LoginModule {
         try {
             String defUsername = System.getProperty("user.name");
 
-            Callback[] callbacks = new Callback[1];
             MessageFormat form = new MessageFormat(
                                    getAuthResourceString(
                                    "GSS.name.defName."));
             Object[] source =  {defUsername};
-            callbacks[0] = new NameCallback(form.format(source));
+            Callback[] callbacks = {new NameCallback(form.format(source))};
             callbackHandler.handle(callbacks);
-            name = ((NameCallback)callbacks[0]).getName();
+            NameCallback callback = (NameCallback)callbacks[0];
+            name = callback.getName();
             if (name != null && name.length() == 0)
                 name = null;
             if (name == null && defUsername != null &&
@@ -627,7 +628,7 @@ public class GssLoginModule implements LoginModule {
             return;
         }
         if (doNotPrompt)
-            throw new LoginException("Unable to prompt for password\n");
+            throw new LoginException("Unable to prompt for password");
 
         if (callbackHandler == null) {
             throw new LoginException("No CallbackHandler "
@@ -651,8 +652,7 @@ public class GssLoginModule implements LoginModule {
             ((PasswordCallback)callbacks[0]).clearPassword();
 
             // clear tmpPassword
-            for (int i = 0; i < tmpPassword.length; i++)
-                tmpPassword[i] = ' ';
+            Arrays.fill(tmpPassword, ' ');
         } catch (java.io.IOException ioe) {
             throw new LoginException(ioe.getMessage());
         } catch (UnsupportedCallbackException uce) {

commit 329815575d8a4bf12439486706bd1649bcdce48c
Author: Nicolas Williams <nico@cryptonector.com>
Date:   Fri Jun 14 17:18:10 2019 -0500

    Modernize GSSUtil.java
    
    Based on code review commentary by Peter Burka.

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
index 4c1df31e9d..e7b8e56f1f 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
@@ -120,19 +120,19 @@ public class GSSUtil {
                                      GSSCredential creds) {
 
         HashSet<Object> privCredentials = null;
-        HashSet<Object> pubCredentials = new HashSet<Object>(); // empty Set
+        HashSet<Object> pubCredentials = new HashSet<>(); // empty Set
 
         Set<GSSCredentialSpi> gssCredentials = null;
 
-        Set<GSSName> names = new HashSet<GSSName>();
+        Set<GSSName> names = new HashSet<>();
         names.add(name);
 
         if (creds instanceof GSSCredentialImpl) {
             gssCredentials = ((GSSCredentialImpl) creds).getElements();
-            privCredentials = new HashSet<Object>(gssCredentials.size());
+            privCredentials = new HashSet<>(gssCredentials.size());
             populateCredentials(privCredentials, gssCredentials);
         } else {
-            privCredentials = new HashSet<Object>(); // empty Set
+            privCredentials = new HashSet<>(); // empty Set
         }
         debug("Created Subject with the following");
         debug("principals=" + names);
@@ -155,12 +155,7 @@ public class GSSUtil {
     private static void populateCredentials(Set<Object> credentials,
                                             Set<?> gssCredentials) {
 
-        Object cred;
-
-        Iterator<?> elements = gssCredentials.iterator();
-        while (elements.hasNext()) {
-
-            cred = elements.next();
+        for (Object cred : gssCredentials) {
 
             // Retrieve the internal cred out of SpNegoCredElement
             if (cred instanceof SpNegoCredElement) {
@@ -310,11 +305,8 @@ public class GSSUtil {
                         }
 
                         result = new Vector<T>();
-                        Iterator<GSSCredentialImpl> iterator =
-                            accSubj.getPrivateCredentials
-                            (GSSCredentialImpl.class).iterator();
-                        while (iterator.hasNext()) {
-                            GSSCredentialImpl cred = iterator.next();
+                        for (GSSCredentialImpl cred : accSubj.getPrivateCredentials
+                                                      (GSSCredentialImpl.class)) {
                             debug("...Found cred" + cred);
                             try {
                                 GSSCredentialSpi ce =

commit a2e5a4fe762525cf31a1ad55f06fc8fe1931a45a
Author: Nico Williams <nico@twosigma.com>
Date:   Fri Mar 11 20:54:00 2016 +0000

    Engage GssLoginModule (only) when native=true
    
    Also don't force same name for acceptor and initiator.

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java
index 4d543044cc..951f573d54 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java
@@ -42,6 +42,7 @@ public class LoginConfigImpl extends Configuration {
     private final Configuration config;
     private final GSSCaller caller;
     private final String mechName;
+    private final boolean useNative;
     private static final sun.security.util.Debug debug =
         sun.security.util.Debug.getInstance("gssloginconfig", "\t[GSS LoginConfigImpl]");
 
@@ -65,8 +66,17 @@ public class LoginConfigImpl extends Configuration {
 
         this.caller = caller;
 
-        if (mech.equals(GSSUtil.GSS_KRB5_MECH_OID)) {
+        useNative = "true".equalsIgnoreCase(
+                System.getProperty("sun.security.jgss.native"));
+
+        if (mech.equals(GSSUtil.GSS_KRB5_MECH_OID) ||
+                mech.equals(GSSUtil.GSS_KRB5_MECH_OID2) ||
+                mech.equals(GSSUtil.GSS_KRB5_MECH_OID_MS)) {
             mechName = "krb5";
+        } else if (useNative) {
+            // We don't really need a mechName, nor do we have any sort of
+            // standard notion of mechanism name (other than OIDs).
+            mechName = mech.toString();
         } else {
             throw new IllegalArgumentException(mech.toString() + " not supported");
         }
@@ -98,7 +108,7 @@ public class LoginConfigImpl extends Configuration {
         // For the 4 old callers, old entry names will be used if the new
         // entry name is not provided.
 
-        if ("krb5".equals(mechName)) {
+        if ("krb5".equals(mechName) || useNative) {
             if (caller == GSSCaller.CALLER_INITIATE) {
                 alts = new String[] {
                     "com.sun.security.jgss.krb5.initiate",
@@ -118,7 +128,7 @@ public class LoginConfigImpl extends Configuration {
             }
         } else {
             throw new IllegalArgumentException(mechName + " not supported");
-            // No other mech at the moment, maybe --
+            // No other Java-coded mech at the moment, maybe --
             /*
             switch (caller) {
             case GSSUtil.CALLER_INITIATE:
@@ -165,33 +175,42 @@ public class LoginConfigImpl extends Configuration {
      * the system-wide Configuration object.
      */
     private AppConfigurationEntry[] getDefaultConfigurationEntry() {
-        HashMap <String, String> options = new HashMap <String, String> (2);
+        HashMap <String, String> gssOptions = new HashMap <String, String> (2);
+        HashMap <String, String> krb5Options = new HashMap <String, String> (2);
 
-        if (mechName == null || mechName.equals("krb5")) {
+        if (mechName == null || mechName.equals("krb5") || useNative) {
             if (isServerSide(caller)) {
+                gssOptions.put("useDefaultCreds", "true");
+                gssOptions.put("doNotPrompt", "true");
+                gssOptions.put("accept", "true");
                 // Assuming the keytab file can be found through
                 // krb5 config file or under user home directory
-                options.put("useKeyTab", "true");
-                options.put("storeKey", "true");
-                options.put("doNotPrompt", "true");
-                options.put("principal", "*");
-                options.put("isInitiator", "false");
+                krb5Options.put("useKeyTab", "true");
+                krb5Options.put("storeKey", "true");
+                krb5Options.put("doNotPrompt", "true");
+                krb5Options.put("principal", "*");
+                krb5Options.put("isInitiator", "false");
             } else {
                 if (caller instanceof HttpCaller && !HTTP_USE_GLOBAL_CREDS) {
-                    options.put("useTicketCache", "false");
+                    gssOptions.put("tryDefaultCreds", "false");
+                    krb5Options.put("useTicketCache", "false");
                 } else {
-                    options.put("useTicketCache", "true");
+                    gssOptions.put("tryDefaultCreds", "true");
+                    krb5Options.put("useTicketCache", "true");
                 }
-                options.put("doNotPrompt", "false");
+                gssOptions.put("initiate", "true");
+                gssOptions.put("doNotPrompt", "false");
+                krb5Options.put("doNotPrompt", "false");
             }
             return new AppConfigurationEntry[] {
-                // FIXME Also -or alternatively when we're using the native
-                // providers- add GssLoginModule, since we might not be able to
-                // acquire Kerberos credentials directly, or even at all .
                 new AppConfigurationEntry(
-                        "com.sun.security.auth.module.Krb5LoginModule",
+                        "com.sun.security.auth.module.GssLoginModule",
                         AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,
-                        options)
+                        gssOptions),
+                new AppConfigurationEntry(
+                        "com.sun.security.auth.module.Krb5LoginModule",
+                        AppConfigurationEntry.LoginModuleControlFlag.SUFFICIENT,
+                        krb5Options)
             };
         }
         return null;

commit dc431f2599689f2e3a6ec137a65abee9e762f03f
Author: Nico Williams <nico@twosigma.com>
Date:   Wed Oct 7 21:18:59 2015 -0400

    Add GssLoginModule
    
    This module is to be used for GSS applications in preference to
    Krb5LoginModule, especially when using the native GSS provider.

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java
index c2b07ecfa7..4d543044cc 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/LoginConfigImpl.java
@@ -185,6 +185,9 @@ public class LoginConfigImpl extends Configuration {
                 options.put("doNotPrompt", "false");
             }
             return new AppConfigurationEntry[] {
+                // FIXME Also -or alternatively when we're using the native
+                // providers- add GssLoginModule, since we might not be able to
+                // acquire Kerberos credentials directly, or even at all .
                 new AppConfigurationEntry(
                         "com.sun.security.auth.module.Krb5LoginModule",
                         AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,
diff --git a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/GssLoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/GssLoginModule.java
new file mode 100644
index 0000000000..404a94cbcc
--- /dev/null
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/GssLoginModule.java
@@ -0,0 +1,846 @@
+/*
+ * Copyright (c) 2000, 2017-2018 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.security.auth.module;
+
+import java.io.*;
+import java.text.MessageFormat;
+import java.util.*;
+import javax.security.auth.*;
+import javax.security.auth.callback.*;
+import javax.security.auth.login.*;
+import javax.security.auth.spi.*;
+
+import org.ietf.jgss.GSSManager;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSCredential;
+import org.ietf.jgss.GSSName;
+import org.ietf.jgss.Oid;
+
+import static sun.security.util.ResourcesMgr.getAuthResourceString;
+
+/**
+ * <p>This {@code LoginModule} authenticates users using a GSS-API
+ * mechanism.</p>
+ *
+ * <p> The configuration entry for {@code GssLoginModule} has
+ * several options that control the authentication process and
+ * additions to the {@code Subject}'s private credential
+ * set. Irrespective of these options, the {@code Subject}'s
+ * principal set and private credentials set are updated only when
+ * {@code commit} is called.
+ * When {@code commit} is called, the {@code GSSName} is added to the
+ * {@code Subject}'s principal set. If {@code initiate} is true, the
+ * initiator credential will be added to the {@code Subject}'s private
+ * credentials.</p>
+ *
+ * <p> If the configuration entry for {@code GssLoginModule}
+ * has the option {@code accept} set to true, then acceptor credential
+ * will be added to the subject's private credentials.</p>
+ *
+ * <p> This {@code LoginModule} recognizes the {@code doNotPrompt}
+ * option. If set to true the user will not be prompted for their password.</p>
+ *
+ * <p> When using the GSS-API Kerberos mechanism, the user can specify
+ * the location of the ticket cache by using the option
+ * {@code ticketCache} in the configuration entry. Similarly, a keytab
+ * can be specified using the option {@code keyTab} in the
+ * configuration entry.</p>
+ *
+ * <p> Other credential store options can be specified as
+ * {@code credStoreKeyValue_KEY}, where {@code KEY} is the name of a
+ * credential store key supported by the GSS-API mechanism provider.
+ * When using platform native GSS-API providers, consult their
+ * documentation (for example, look for the {@code gss_acquire_cred_from()}
+ * and {@code gss_store_cred_into()} functions).</p>
+ *
+ * <p> The principal name can be specified in the configuration entry
+ * by using the option {@code name} and {@code nameType}. The principal name
+ * can either be a simple user name, a service name such as
+ * {@code host@mission.eng.sun.com}. The principal can also
+ * be set using the system property
+ * {@systemProperty sun.security.gss.name}, and its name-type can be set
+ * with {@systemProperty sun.security.gss.nametype}.
+ * These properties are checked during login if the name and name-type
+ * are not set in the configuration.  In the case where the principal
+ * property is not set and the principal entry also does not exist, the
+ * user is prompted for the name.</p>
+ *
+ * <p> The following is a list of configuration options supported
+ * for {@code GssLoginModule}:
+ * <blockquote><dl>
+ * <dt>{@code doNotPrompt}:</dt>
+ * <dd>Set this to true if you do not want to be
+ * prompted for the password
+ * if credentials can not be obtained from the cache, the keytab,
+ * or through shared state.(Default is false)
+ * If set to true, credential must be obtained through cache, keytab,
+ * or shared state. Otherwise, authentication will fail.</dd>
+ * <dt>{@code ticketCache}:</dt>
+ * <dd>Set this to the name of the ticket cache file that contains
+ * user's TGT.</dd>
+ * <dt>{@code keyTab}:</dt>
+ * <dd>Set this to the file name of the keytab to get principal's secret
+ * key(s).</dd>
+ * <dt>{@code name}:</dt>
+ * <dd>The name of the principal that should be used. The principal can
+ * be a simple username such as "{@code testuser}" or a service name
+ * such as "{@code host@testhost.eng.sun.com}". You can use the
+ * {@code principal} option to set the principal when there are
+ * credentials for multiple principals in the {@code keyTab} or when you
+ * want a specific ticket cache only. The principal can also be set
+ * using the system property {@code sun.security.gss.name}. The value
+ * from the configuration takes precedence.</dd>
+ * <dt>{@code nametype}:</dt>
+ * <dd>This is the type of the name. This can be "{@code username}",
+ * "{@code hostbased}", or an OID, and defaults to "{@code username}".</dd>
+ * <dt>{@code initiate}:</dt>
+ * <dd>Set this to true, if you need to acquire initiator
+ * credentials.</dd>
+ * <dt>{@code accept}:</dt>
+ * <dd>Set this to true, if you need to acquire acceptor
+ * credentials. Either or both of {@code initiate} and {@code accept}
+ * may be set to true. If both are false then {@code initiate} will be
+ * treated as true.</dd>
+ * </dl></blockquote></p>
+ *
+ * <p> This {@code LoginModule} also recognizes the following additional
+ * {@code Configuration}
+ * options that enable you to share username and passwords across different
+ * authentication modules:
+ * <blockquote><dl>
+ *
+ *    <dt>{@code useFirstPass}:</dt>
+ *                   <dd>if, true, this LoginModule retrieves the
+ *                   username and password from the module's shared state,
+ *                   using "javax.security.auth.login.name" and
+ *                   "javax.security.auth.login.password" as the respective
+ *                   keys. The retrieved values are used for authentication.
+ *                   If authentication fails, no attempt for a retry
+ *                   is made, and the failure is reported back to the
+ *                   calling application.</dd>
+ *
+ *    <dt>{@code tryFirstPass}:</dt>
+ *                   <dd>if, true, this LoginModule retrieves the
+ *                   the username and password from the module's shared
+ *                   state using "javax.security.auth.login.name" and
+ *                   "javax.security.auth.login.password" as the respective
+ *                   keys.  The retrieved values are used for
+ *                   authentication.
+ *                   If authentication fails, the module uses the
+ *                   CallbackHandler to retrieve a new username
+ *                   and password, and another attempt to authenticate
+ *                   is made. If the authentication fails,
+ *                   the failure is reported back to the calling application</dd>
+ *
+ *    <dt>{@code storePass}:</dt>
+ *                   <dd>if, true, this LoginModule stores the username and
+ *                   password obtained from the CallbackHandler in the
+ *                   modules shared state, using
+ *                   "javax.security.auth.login.name" and
+ *                   "javax.security.auth.login.password" as the respective
+ *                   keys.  This is not performed if existing values already
+ *                   exist for the username and password in the shared
+ *                   state, or if authentication fails.</dd>
+ *
+ *    <dt>{@code clearPass}:</dt>
+ *                   <dd>if, true, this LoginModule clears the
+ *                   username and password stored in the module's shared
+ *                   state  after both phases of authentication
+ *                   (login and commit) have completed.</dd>
+ * </dl></blockquote></p>
+ * <p>If the principal system property or key is already provided, the value of
+ * "javax.security.auth.login.name" in the shared state is ignored.</p>
+ *
+ * <p>Note that if any step fails, it will fallback to the next step.
+ * There's only one exception, if the shared state step fails and
+ * {@code useFirstPass = true}, no user prompt is made.</p>
+ */
+
+
+public class GssLoginModule implements LoginModule {
+
+    // From initialize
+    private Subject subject;
+    private CallbackHandler callbackHandler;
+    private Map<String, Object> sharedState;
+    private Map<String, ?> options;
+
+    // Configuration option
+    private boolean debug;
+    private boolean doNotPrompt;
+    private String defName;
+    private String name;
+    private String nametype; // username, hostbased, unspecified
+    private Oid nametypeOid;
+
+    private GSSManager manager;
+    private GSSName gssName;
+    private GSSCredential gssICred;
+    private GSSCredential gssACred;
+
+    private boolean useNative; // sun.security.jgss.native property
+
+    private boolean useFirstPass;
+    private boolean tryFirstPass;
+    private boolean storePass;
+    private boolean clearPass;
+    private boolean initiate;
+    private boolean accept;
+    private boolean tryDefaultCreds;
+    private boolean useDefaultCreds;
+
+    // Module state
+    private boolean succeeded;
+    private boolean commitSucceeded;
+
+    private String password = null;
+    private Map<String,String> store = null;
+
+    private static final String NAME = "javax.security.auth.login.name";
+    private static final String PWD = "javax.security.auth.login.password";
+
+    private String getWithDefault(String key, String defval) {
+        String value = (String)options.get(key);
+        return value != null ? value : defval;
+    }
+
+    private void storeAddKeyValue(String key, String value) {
+        if (store == null) {
+            store = new HashMap<String,String>(){{put(key, value);}};
+        } else {
+            store.put(key, value);
+        }
+    }
+
+    private void storeAddOption(String optionName, String key) {
+        if (options.containsKey(optionName)) {
+            storeAddKeyValue(key, (String)options.get(optionName));
+        }
+    }
+
+    private void storeAddOptions() {
+        for (String key : options.keySet()) {
+            if (!key.startsWith("credStoreKeyValue_"))
+                continue;
+            storeAddOption(key, key.substring("credStoreKeyValue_".length()));
+        }
+    }
+
+    /**
+     * Initialize this <code>LoginModule</code>.
+     *
+     * <p>
+     * @param subject the <code>Subject</code> to be authenticated.</p>
+     *
+     * <p>
+     * @param callbackHandler a <code>CallbackHandler</code> for
+     *                  communication with the end user (prompting for
+     *                  usernames and passwords, for example).</p>
+     *
+     * <p>
+     * @param sharedState shared <code>LoginModule</code> state.</p>
+     *
+     * <p>
+     * @param options options specified in the login
+     *                  <code>Configuration</code> for this particular
+     *                  <code>LoginModule</code>.</p>
+     */
+    // Unchecked warning from (Map<String, Object>)sharedState is safe
+    // since javax.security.auth.login.LoginContext passes a raw HashMap.
+    // Unchecked warnings from options.get(String) are safe since we are
+    // passing known keys.
+    @SuppressWarnings("unchecked")
+    public void initialize(Subject subject,
+                           CallbackHandler callbackHandler,
+                           Map<String, ?> sharedState,
+                           Map<String, ?> options) {
+
+        this.subject = subject;
+        this.callbackHandler = callbackHandler;
+        this.sharedState = (Map<String, Object>)sharedState;
+        this.options = options;
+
+        /*
+         * When sun.security.jgss.native=false (i.e., not using the system's
+         * native C/ELF/DLL GSS implementation) then there's nothing for this
+         * login module to do.  Otherwise we'd get into an infinite recursion
+         * problem due to re-entering GssLoginModule like this:
+         *
+         * Application -> LoginContext -> GssLoginModule -> Krb5 ->
+         *      GSSUtil.login -> LoginContext -> GssLoginModule -> ...
+         *
+         * It stands to reason that when sun.security.jgss.native=false the
+         * login modules corresponding to the actual GSS mechanisms coded in
+         * Java are the ones that should be acquiring their corresponding
+         * credentials.
+         *
+         * A policy like "let the application use GSS credentials but not the
+         * raw, underlying Krb5 credentials" when
+         * sun.security.jgss.native=false" could be expressible by adding a
+         * module option to Krb5LoginModule that causes it to add only GSS
+         * credentials to the Subject, not Krb5 credentials.
+         *
+         * (It has never been possible to express such a policy, so we lose
+         * nothing by punting here when sun.security.jgss.native=false.)
+         */
+        useNative = "true".equalsIgnoreCase(
+                System.getProperty("sun.security.jgss.native"));
+        if (!useNative)
+            return;
+
+        manager = GSSManager.getInstance();
+
+        // initialize any configured options
+
+        debug = "true".equalsIgnoreCase((String)options.get("debug"));
+        doNotPrompt =
+            "true".equalsIgnoreCase(getWithDefault("doNotPrompt", "true"));
+        defName = (String)options.get("name");
+        nametype = (String)options.get("nametype");
+
+        if (defName == null)
+            defName = System.getProperty("sun.security.gss.name");
+        if (nametype == null)
+            nametype = System.getProperty("sun.security.gss.nametype");
+        if (nametype == null || nametype.equals("username")) {
+            nametypeOid = GSSName.NT_USER_NAME;
+        } else if (nametype.equals("hostbased")) {
+            nametypeOid = GSSName.NT_HOSTBASED_SERVICE;
+        } else if (!nametype.equals("")) {
+            try {
+                nametypeOid = new Oid(nametype);
+            } catch (GSSException e) {
+                if (debug)
+                    System.out.print("Unknown name type OID " + nametype);
+                nametypeOid = null;
+            }
+        } else {
+            nametype = "<default: username>";
+            nametypeOid = GSSName.NT_USER_NAME;
+        }
+
+        storeAddOptions();
+        storeAddOption("keyTab", "keytab");
+        storeAddOption("clientKeyTab", "client_keytab");
+        storeAddOption("ticketCache", "ccache");
+        storeAddOption("replayCache", "rcache");
+
+        tryFirstPass =
+            "true".equalsIgnoreCase(getWithDefault("tryFirstPass", "true"));
+        useFirstPass =
+            "true".equalsIgnoreCase(
+                getWithDefault("useFirstPass",
+                    doNotPrompt ? "true" : "false"));
+        storePass =
+            "true".equalsIgnoreCase((String)options.get("storePass"));
+        clearPass =
+            "true".equalsIgnoreCase((String)options.get("clearPass"));
+        initiate =
+            "true".equalsIgnoreCase((String)options.get("initiate"));
+        accept =
+            "true".equalsIgnoreCase((String)options.get("accept"));
+        tryDefaultCreds =
+            "true".equalsIgnoreCase(getWithDefault("tryDefaultCreds", "true"));
+        useDefaultCreds =
+            "true".equalsIgnoreCase(
+                getWithDefault("useDefaultCreds",
+                    doNotPrompt ? "true" : "false"));
+        if (!initiate && !accept)
+            initiate = true;
+        if (debug) {
+            System.out.print("Debug is  " + debug
+                             + " doNotPrompt " + doNotPrompt
+                             + " defName is " + defName
+                             + " nametype is " + nametype
+                             + " tryFirstPass is " + tryFirstPass
+                             + " useFirstPass is " + useFirstPass
+                             + " storePass is " + storePass
+                             + " clearPass is " + clearPass
+                             + " initiate is " + initiate
+                             + " accept is " + accept
+                             + " tryDefaultCreds is " + tryDefaultCreds
+                             + " useDefaultCreds is " + useDefaultCreds + "\n");
+            System.out.print("Credential store options are:");
+            if (store.size() == 0) {
+                System.out.print(" <none>");
+            } else {
+                for (var e : store.entrySet()) {
+                    System.out.print(" " + e.getKey() + "=" + e.getValue() + ";");
+                }
+            }
+            System.out.println("");
+        }
+    }
+
+
+    /**
+     * Authenticate the user
+     *
+     * <p>
+     *
+     * @return true in all cases since this <code>LoginModule</code>
+     *          should not be ignored.</p>
+     *
+     * <p>
+     * @exception FailedLoginException if the authentication fails.</p>
+     *
+     * <p>
+     * @exception LoginException if this <code>LoginModule</code>
+     *          is unable to perform the authentication.</p>
+     */
+    public boolean login() throws LoginException {
+        succeeded = false;
+
+        /*
+         * See commentary in initialize().  By returning false we cause
+         * LoginContext to ignore this module.
+         */
+        if (!useNative)
+            return false;
+        try {
+            if (tryFirstPass || useFirstPass) {
+                attemptAuthentication(true);
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] " +
+                                       "authentication succeeded");
+                succeeded = true;
+                cleanState();
+                return true;
+            }
+        } catch (LoginException le) {
+            // authentication failed -- try again below by prompting
+            cleanState();
+            if (debug) {
+                System.out.println("\t\t[GssLoginModule] " +
+                                   (tryFirstPass ? "tryFirstPass " : "") +
+                                   "authentication failed with:" +
+                                   le.getMessage());
+            }
+            if (useFirstPass)
+                throw le;
+        }
+
+        // The first password didn't work or we didn't try it, try prompting
+        try {
+            attemptAuthentication(false);
+            if (debug)
+                System.out.println("\t\t[GssLoginModule] " +
+                                   "authentication succeeded");
+            succeeded = true;
+            cleanState();
+            return true;
+        } catch (LoginException le2) {
+            cleanState();
+            if (debug) {
+                System.out.println("\t\t[GssLoginModule] " +
+                                   (tryFirstPass ? "tryFirstPass " : "") +
+                                   "authentication failed with:" +
+                                   le2.getMessage());
+            }
+            throw le2;
+        }
+    }
+
+    private void getcreds() throws GSSException {
+        if (initiate) {
+            if (password == null && store == null) {
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] acquiring" +
+                        ((gssName == null) ? " default" : "") +
+                        " initiator credentials...");
+                gssICred = manager.createCredential(gssName,
+                        GSSCredential.DEFAULT_LIFETIME, (Oid[])null,
+                        GSSCredential.INITIATE_ONLY);
+            } else if (password != null) {
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] acquiring" +
+                        " initiator credentials using a password...");
+                gssICred = manager.createCredential(gssName, password,
+                        GSSCredential.DEFAULT_LIFETIME, (Oid[])null,
+                        GSSCredential.INITIATE_ONLY);
+            } else {
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] acquiring" +
+                        ((gssName == null) ? " default" : "") +
+                        " initiator credentials using a specified" +
+                        " credential store...");
+                gssICred = manager.createCredential(gssName, store,
+                        GSSCredential.DEFAULT_LIFETIME, (Oid[])null,
+                        GSSCredential.INITIATE_ONLY);
+            }
+            if (debug)
+                System.out.println("\t\t[GssLoginModule] acquired" +
+                    " initiator credentials: " + gssName);
+        }
+        if (accept) {
+            if (debug)
+                System.out.println("\t\t[GssLoginModule] acquiring" +
+                    ((gssName == null) ? " default" : "") +
+                    " acceptor credentials...");
+            gssACred = manager.createCredential(gssName, password,
+                    GSSCredential.DEFAULT_LIFETIME, (Oid[])null,
+                    GSSCredential.ACCEPT_ONLY);
+            // Default acceptor credentials retain a null name
+            if (debug)
+                System.out.println("\t\t[GssLoginModule] acquired" +
+                    " acceptor credentials");
+        }
+        if (gssName == null && gssICred != null)
+            gssName = gssICred.getName();
+        if (gssName == null && gssACred != null)
+            gssName = gssACred.getName();
+    }
+
+    private void attemptAuthentication(boolean getPasswdFromSharedState)
+        throws LoginException {
+
+        // Get a name, maybe
+        if (name == null) {
+            if (useDefaultCreds) {
+                try {
+                    getcreds();
+                    return;
+                } catch (GSSException e) {
+                    throw new LoginException(e.getMessage());
+                }
+            }
+            if (tryDefaultCreds) {
+                try {
+                    getcreds();
+                    return;
+                } catch (GSSException e) { }
+            }
+
+            promptForName(getPasswdFromSharedState);
+            if (name == null)
+                throw new LoginException ("Unable to determine a GSS name");
+        }
+
+        try {
+            gssName = manager.createName(name, nametypeOid);
+        } catch (GSSException e) {
+            throw new LoginException ("Unable to import GSS name");
+        }
+
+        promptForPass(getPasswdFromSharedState);
+
+        try {
+            getcreds();
+        } catch (GSSException e) {
+            throw new LoginException(e.getMessage());
+        }
+    }
+
+    private void promptForName(boolean getPasswdFromSharedState)
+        throws LoginException {
+        if (getPasswdFromSharedState) {
+            // use the name saved by a module earlier in the stack
+            name = (String)sharedState.get(NAME);
+            if (name == null || name.length() == 0)
+                name = defName;
+            if (debug) {
+                System.out.println("\t\t[GssLoginModule] username from" +
+		    " shared state is " + name);
+            }
+            if (name != null && name.length() > 0)
+                return;
+        }
+
+        if (doNotPrompt)
+            return; // name may be null
+
+        if (callbackHandler == null)
+            throw new LoginException("No CallbackHandler "
+                                     + "available "
+                                     + "to prompt for authentication "
+                                     + "information from the user");
+
+        try {
+            String defUsername = System.getProperty("user.name");
+
+            Callback[] callbacks = new Callback[1];
+            MessageFormat form = new MessageFormat(
+                                   getAuthResourceString(
+                                   "GSS.name.defName."));
+            Object[] source =  {defUsername};
+            callbacks[0] = new NameCallback(form.format(source));
+            callbackHandler.handle(callbacks);
+            name = ((NameCallback)callbacks[0]).getName();
+            if (name != null && name.length() == 0)
+                name = null;
+            if (name == null && defUsername != null &&
+                    defUsername.length() != 0)
+                name = defUsername;
+        } catch (java.io.IOException ioe) {
+            throw new LoginException(ioe.getMessage());
+        } catch (UnsupportedCallbackException uce) {
+            throw new LoginException
+                (uce.getMessage()
+                 +" not available to garner "
+                 +" authentication information "
+                 +" from the user");
+        }
+        // name may still be null, which we take to mean "use default
+        // credentials"
+    }
+
+    private void promptForPass(boolean getPasswdFromSharedState)
+        throws LoginException {
+
+        char[] pw;
+
+        if (getPasswdFromSharedState) {
+            // use the password saved by the first module in the stack
+            pw = (char[])sharedState.get(PWD);
+            if (pw == null) {
+                if (debug)
+                    System.out.println("\t\t[GssLoginModule] password from" +
+			" shared state is null");
+                throw new LoginException
+                    ("Password can not be obtained from sharedstate ");
+            }
+            password = new String(pw);
+            return;
+        }
+        if (doNotPrompt)
+            throw new LoginException("Unable to prompt for password\n");
+
+        if (callbackHandler == null) {
+            throw new LoginException("No CallbackHandler "
+                                     + "available "
+                                     + "to garner authentication "
+                                     + "information from the user");
+        }
+        try {
+            Callback[] callbacks = new Callback[1];
+            MessageFormat form = new MessageFormat(
+                                     getAuthResourceString(
+                                     "Kerberos.password.for.username."));
+            Object[] source = {name};
+            callbacks[0] = new PasswordCallback(form.format(source), false);
+            callbackHandler.handle(callbacks);
+            char[] tmpPassword = ((PasswordCallback)
+                                  callbacks[0]).getPassword();
+            if (tmpPassword == null)
+                throw new LoginException("No password provided");
+            password = new String(tmpPassword);
+            ((PasswordCallback)callbacks[0]).clearPassword();
+
+            // clear tmpPassword
+            for (int i = 0; i < tmpPassword.length; i++)
+                tmpPassword[i] = ' ';
+        } catch (java.io.IOException ioe) {
+            throw new LoginException(ioe.getMessage());
+        } catch (UnsupportedCallbackException uce) {
+            throw new LoginException(uce.getMessage()
+                                     +" not available to garner "
+                                     +" authentication information "
+                                     + "from the user");
+        }
+    }
+
+    /**
+     * <p> This method is called if the LoginContext's
+     * overall authentication succeeded
+     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL
+     * LoginModules succeeded).</p>
+     *
+     * <p> If this LoginModule's own authentication attempt
+     * succeeded (checked by retrieving the private state saved by the
+     * <code>login</code> method), then this method associates a
+     * <code>GSSName</code>
+     * with the <code>Subject</code> located in the
+     * <code>LoginModule</code>. It adds GSS Credentials to the
+     * the Subject's private credentials set. If this LoginModule's own
+     * authentication attempted failed, then this method removes
+     * any state that was originally saved.</p>
+     *
+     * <p>
+     *
+     * @exception LoginException if the commit fails.</p>
+     *
+     * <p>
+     * @return true if this LoginModule's own login and commit
+     *          attempts succeeded, or false otherwise.</p>
+     */
+
+    public boolean commit() throws LoginException {
+        if (succeeded == false)
+            return false;
+
+        if (!useNative)
+            return false;
+
+        succeeded = false;
+        if (initiate && (gssICred == null)) {
+            gssName = null;
+            gssICred = null;
+            gssACred = null;
+            throw new LoginException("Null Initiator Credential");
+        }
+        if (accept && (gssACred == null)) {
+            gssName = null;
+            gssICred = null;
+            gssACred = null;
+            throw new LoginException("Null Acceptor Credential");
+        }
+        if (subject.isReadOnly()) {
+            gssName = null;
+            gssICred = null;
+            gssACred = null;
+            throw new LoginException("Subject is Readonly");
+        }
+
+        try {
+            if (initiate && gssName == null)
+                gssName = gssICred.getName();
+        } catch (GSSException e) {}
+        try {
+            if (accept && gssName == null)
+                gssName = gssACred.getName();
+        } catch (GSSException e) {}
+
+        Set<Object> privCredSet = subject.getPrivateCredentials();
+        Set<java.security.Principal> princSet = subject.getPrincipals();
+
+        if (gssName != null && !princSet.contains(gssName))
+            princSet.add(gssName);
+        if (gssICred != null && !privCredSet.contains(gssICred))
+            privCredSet.add(gssICred);
+        if (gssACred != null && !privCredSet.contains(gssACred))
+            privCredSet.add(gssACred);
+
+        succeeded = true;
+        commitSucceeded = true;
+        if (debug)
+            System.out.println("\t\t[GssLoginModule] commit Succeeded");
+        return true;
+    }
+
+    /**
+     * <p> This method is called if the LoginContext's
+     * overall authentication failed.
+     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL
+     * LoginModules did not succeed).</p>
+     *
+     * <p> If this LoginModule's own authentication attempt
+     * succeeded (checked by retrieving the private state saved by the
+     * <code>login</code> and <code>commit</code> methods),
+     * then this method cleans up any state that was originally
+     * saved.</p>
+     *
+     * <p>
+     *
+     * @exception LoginException if the abort fails.</p>
+     *
+     * <p>
+     * @return false if this LoginModule's own login and/or commit attempts
+     *          failed, and true otherwise.</p>
+     */
+
+    public boolean abort() throws LoginException {
+        if (succeeded == false) {
+            return false;
+        } else if (succeeded == true && commitSucceeded == false) {
+            // login succeeded but overall authentication failed
+            succeeded = false;
+        } else {
+            // overall authentication succeeded and commit succeeded,
+            // but someone else's commit failed
+            logout();
+        }
+        return true;
+    }
+
+    /**
+     * <p>Logout the user.</p>
+     *
+     * <p>This method removes the <code>GSSName</code> and
+     * <code>GSSCredential</code> added by the <code>commit</code> method.</p>
+     *
+     * <p>
+     *
+     * @exception LoginException if the logout fails.</p>
+     *
+     * <p>
+     * @return true in all cases since this <code>LoginModule</code>
+     *          should not be ignored.</p>
+     */
+    public boolean logout() throws LoginException {
+        /*
+         * See commentary in initialize().  By returning false we cause
+         * LoginContext to ignore this module.
+         */
+        if (!useNative)
+            return false;
+
+        if (subject.isReadOnly())
+            throw new LoginException("Subject is Readonly");
+
+        subject.getPrincipals().remove(gssName);
+        Iterator<Object> it = subject.getPrivateCredentials().iterator();
+        while (it.hasNext()) {
+            Object o = it.next();
+            if (o instanceof GSSCredential)
+                it.remove();
+        }
+
+        succeeded = false;
+        commitSucceeded = false;
+        if (debug)
+            System.out.println("\t\t[GSSLoginModule]: logged out Subject");
+        return true;
+    }
+
+    /**
+     * Clean out the state
+     */
+    private void cleanState() {
+
+        // save input as shared state only if
+        // authentication succeeded
+        if (succeeded) {
+            if (storePass &&
+                !sharedState.containsKey(NAME) &&
+                !sharedState.containsKey(PWD)) {
+                sharedState.put(NAME, name);
+                sharedState.put(PWD, password);
+            }
+        } else {
+            // remove temp results for the next try
+            gssName = null;
+            gssICred = null;
+            gssACred = null;
+        }
+        name = null;
+        password = null;
+        if (clearPass) {
+            sharedState.remove(NAME);
+            sharedState.remove(PWD);
+        }
+    }
+}
diff --git a/test/jdk/sun/security/jgss/DefaultGssConfig.java b/test/jdk/sun/security/jgss/DefaultGssConfig.java
index e80a2aaf36..de8bf0b869 100644
--- a/test/jdk/sun/security/jgss/DefaultGssConfig.java
+++ b/test/jdk/sun/security/jgss/DefaultGssConfig.java
@@ -58,6 +58,10 @@ public class DefaultGssConfig {
         Configuration.getConfiguration();
 
         // 3. Make sure there're default entries for GSS krb5 client/server
+        //
+        // FIXME Why be so Kerberos-specific?  This is wrong.  Instead we could
+        // use a command-line argument to deal with a specific (or all)
+        // mechanisms.
         LoginConfigImpl lc = new LoginConfigImpl(GSSCaller.CALLER_INITIATE, GSSUtil.GSS_KRB5_MECH_OID);
         if (lc.getAppConfigurationEntry("").length == 0) {
             throw new Exception("No default config for GSS krb5 client");

commit 9d79b6a3ea2beebb4d6793f880dcdb78ecb52c41
Author: Nicolas Williams <nico@cryptonector.com>
Date:   Tue Apr 23 15:54:19 2019 -0500

    Add JGSS JNI bindings for gss cred store functions

diff --git a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSCredential.java b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSCredential.java
index 6c304bed59..29b5df2377 100644
--- a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSCredential.java
+++ b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSCredential.java
@@ -25,6 +25,8 @@
 
 package org.ietf.jgss;
 
+import java.util.Map;
+
 /**
  * This interface encapsulates the GSS-API credentials for an entity.  A
  * credential contains all the necessary cryptographic information to
@@ -349,6 +351,26 @@ public interface GSSCredential extends Cloneable{
     public void add(GSSName name, int initLifetime, int acceptLifetime,
                     Oid mech, int usage) throws GSSException;
 
+    /**
+     * Stores a credential element into an external credential store.
+     *
+     * @param usage The credential usage to store.
+     * @param mech The mechanism element of the credential to store.
+     * @param overwrite Whether to overwrite any existing credentials in
+     * the external store.
+     * @param defaultCred Whether to make the credential to be stored
+     * also be the default credential in the external store.
+     * @param store A description of the external store.  Common keys
+     * supported by platform-native GSS-API providers include:
+     * {@code ccache} and {@code keytab}, with the values being
+     * typically file paths.  Consult the documentation for your
+     * platform's native GSS-API providers.  The Java-native Krb5
+     * provider does not support this method at this time.
+     */
+    public void storeInto(int usage, Oid mech,
+                          boolean overwrite, boolean defaultCred,
+                          Map<String,String> store) throws GSSException;
+
     /**
      * Tests if this GSSCredential asserts the same entity as the supplied
      * object.  The two credentials must be acquired over the same
diff --git a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
index ab3181302c..3ae80eed39 100644
--- a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
+++ b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
@@ -25,6 +25,7 @@
 
 package org.ietf.jgss;
 
+import java.util.Map;
 import java.security.Provider;
 
 /**
@@ -442,6 +443,7 @@ public abstract class GSSManager {
      *
      * @param name the name of the principal for whom this credential is to be
      * acquired.  Use <code>null</code> to specify the default principal.
+     * @param password The password for the principal.
      * @param lifetime The number of seconds that credentials should remain
      * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
      * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
@@ -475,6 +477,64 @@ public abstract class GSSManager {
                                   int usage)
         throws GSSException;
 
+    /**
+     * Factory method for acquiring a single mechanism credential from
+     * an external credential store.<p>
+     *
+     * GSS-API mechanism providers must impose a local access-control
+     * policy on callers to prevent unauthorized callers from acquiring
+     * credentials to which they are not entitled. The kinds of permissions
+     * needed by different mechanism providers will be documented on a
+     * per-mechanism basis. A failed permission check might cause a {@link
+     * java.lang.SecurityException SecurityException} to be thrown from
+     * this method. <p>
+     *
+     * Non-default values for lifetime cannot always be honored by the
+     * underlying mechanisms, thus applications should be prepared to call
+     * {@link GSSCredential#getRemainingLifetime() getRemainingLifetime}
+     * on the returned credential.<p>
+     *
+     * @param name the name of the principal for whom this credential is to be
+     * acquired.  Use <code>null</code> to specify the default principal.
+     * @param store A description of an external credential store.
+     * Common keys supported by platform-native GSS-API providers
+     * include: {@code ccache} and {@code keytab}, with the values being
+     * typically file paths.  Consult the documentation for your
+     * platform's native GSS-API providers.  The Java-native Krb5
+     * provider does not support this method at this time.
+     * @param lifetime The number of seconds that credentials should remain
+     * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
+     * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
+     * have the maximum permitted lifetime.  Use {@link
+     * GSSCredential#DEFAULT_LIFETIME GSSCredential.DEFAULT_LIFETIME} to
+     * request default credential lifetime.
+     * @param mech the Oid of the desired mechanism.  Use <code>(Oid) null
+     * </code> to request the default mechanism.
+     * @param usage The intended usage for this credential object. The value
+     * of this parameter must be one of:
+     * {@link GSSCredential#INITIATE_AND_ACCEPT
+     * GSSCredential.INITIATE_AND_ACCEPT},
+     * {@link GSSCredential#ACCEPT_ONLY GSSCredential.ACCEPT_ONLY}, and
+     * {@link GSSCredential#INITIATE_ONLY GSSCredential.INITIATE_ONLY}.
+     * @return a GSSCredential of the requested type.
+     *
+     * @see GSSCredential
+     *
+     * @throws GSSException containing the following
+     * major error codes:
+     *    {@link GSSException#BAD_MECH GSSException.BAD_MECH},
+     *    {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
+     *    {@link GSSException#BAD_NAME GSSException.BAD_NAME},
+     *    {@link GSSException#CREDENTIALS_EXPIRED
+     *                                   GSSException.CREDENTIALS_EXPIRED},
+     *    {@link GSSException#NO_CRED GSSException.NO_CRED},
+     *    {@link GSSException#FAILURE GSSException.FAILURE}
+     */
+    public abstract GSSCredential createCredential (GSSName name,
+                                  Map<String,String> store, int lifetime,
+                                  Oid mech, int usage)
+        throws GSSException;
+
     /**
      * Factory method for acquiring credentials over a set of
      * mechanisms. This method attempts to acquire credentials for
@@ -556,6 +616,7 @@ public abstract class GSSManager {
      * @param name the name of the principal for whom this credential is to
      * be acquired.  Use <code>null</code> to specify the default
      * principal.
+     * @param password The password for the principal.
      * @param lifetime The number of seconds that credentials should remain
      * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
      * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
@@ -590,6 +651,68 @@ public abstract class GSSManager {
                                       Oid mechs[], int usage)
         throws GSSException;
 
+    /**
+     * Factory method for acquiring credentials with a "credential
+     * store" over a set of mechanisms. This method attempts to acquire
+     * credentials for each of the mechanisms specified in the array
+     * called mechs.  To determine the list of mechanisms for which the
+     * acquisition of credentials succeeded, the caller should use the
+     * {@link GSSCredential#getMechs() GSSCredential.getMechs}
+     * method.<p>
+     *
+     * GSS-API mechanism providers must impose a local access-control
+     * policy on callers to prevent unauthorized callers from acquiring
+     * credentials to which they are not entitled. The kinds of permissions
+     * needed by different mechanism providers will be documented on a
+     * per-mechanism basis. A failed permission check might cause a {@link
+     * java.lang.SecurityException SecurityException} to be thrown from
+     * this method.<p>
+     *
+     * Non-default values for lifetime cannot always be honored by the
+     * underlying mechanisms, thus applications should be prepared to call
+     * {@link GSSCredential#getRemainingLifetime() getRemainingLifetime}
+     * on the returned credential.<p>
+     *
+     * @param name the name of the principal for whom this credential is to
+     * be acquired.  Use <code>null</code> to specify the default
+     * principal.
+     * @param store Map of string key and values describing how to
+     * acquire the credential. Consult the documentation for the various
+     * GSS mechanisms.
+     * @param lifetime The number of seconds that credentials should remain
+     * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
+     * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
+     * have the maximum permitted lifetime.  Use {@link
+     * GSSCredential#DEFAULT_LIFETIME GSSCredential.DEFAULT_LIFETIME} to
+     * request default credential lifetime.
+     * @param mechs an array of Oid's indicating the mechanisms over which
+     * the credential is to be acquired.  Use <code>(Oid[]) null</code> for
+     * requesting a system specific default set of mechanisms.
+     * @param usage The intended usage for this credential object. The value
+     * of this parameter must be one of:
+     * {@link GSSCredential#INITIATE_AND_ACCEPT
+     * GSSCredential.INITIATE_AND_ACCEPT},
+     * {@link GSSCredential#ACCEPT_ONLY GSSCredential.ACCEPT_ONLY}, and
+     * {@link GSSCredential#INITIATE_ONLY GSSCredential.INITIATE_ONLY}.
+     * @return a GSSCredential of the requested type.
+     *
+     * @see GSSCredential
+     *
+     * @throws GSSException containing the following
+     * major error codes:
+     *    {@link GSSException#BAD_MECH GSSException.BAD_MECH},
+     *    {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
+     *    {@link GSSException#BAD_NAME GSSException.BAD_NAME},
+     *    {@link GSSException#CREDENTIALS_EXPIRED
+     *                                   GSSException.CREDENTIALS_EXPIRED},
+     *    {@link GSSException#NO_CRED GSSException.NO_CRED},
+     *    {@link GSSException#FAILURE GSSException.FAILURE}
+     */
+    public abstract GSSCredential createCredential(GSSName name,
+                                      Map<String,String> store, int lifetime,
+                                      Oid mechs[], int usage)
+        throws GSSException;
+
     /**
      * Factory method for creating a context on the initiator's
      * side.
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java
index 18eccb14b1..c9b6c6c8d3 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java
@@ -75,6 +75,16 @@ public class GSSCredentialImpl implements GSSCredential {
         add(name, password, lifetime, lifetime, mech, usage);
     }
 
+    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
+                      Map<String,String> store, int lifetime, Oid mech,
+                      int usage)
+        throws GSSException {
+        if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
+
+        init(gssManager);
+        add(name, store, lifetime, lifetime, mech, usage);
+    }
+
     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name, String password,
                       int lifetime, Oid mech, int usage)
         throws GSSException {
@@ -90,6 +100,33 @@ public class GSSCredentialImpl implements GSSCredential {
         this(gssManager, name, (String)null, lifetime, mechs, usage);
     }
 
+    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
+                      Map<String,String> store, int lifetime,
+                      Oid mechs[], int usage)
+        throws GSSException {
+        init(gssManager);
+        boolean defaultList = false;
+        if (mechs == null) {
+            mechs = gssManager.getMechs();
+            defaultList = true;
+        }
+
+        for (int i = 0; i < mechs.length; i++) {
+            try {
+                add(name, store, lifetime, lifetime, mechs[i], usage);
+            } catch (GSSException e) {
+                if (defaultList) {
+                    // Try the next mechanism
+                    GSSUtil.debug("Ignore " + e + " while acquring cred for "
+                        + mechs[i]);
+                    //e.printStackTrace();
+                } else throw e; // else try the next mechanism
+            }
+        }
+        if ((hashtable.size() == 0) || (usage != getUsage()))
+            throw new GSSException(GSSException.NO_CRED);
+    }
+
     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
                       String password, int lifetime, Oid mechs[], int usage)
         throws GSSException {
@@ -437,9 +474,23 @@ public class GSSCredentialImpl implements GSSCredential {
         add(name, password, initLifetime, acceptLifetime, mech, usage);
     }
 
+    public void add(GSSName name, Map<String,String> store, int initLifetime,
+                    int acceptLifetime, Oid mech, int usage)
+                    throws GSSException {
+        add(name, (String)null, store, initLifetime, acceptLifetime,
+            mech, usage);
+    }
+
     public void add(GSSName name, String password, int initLifetime,
                     int acceptLifetime, Oid mech, int usage)
                     throws GSSException {
+        add(name, password, (Map<String,String>)null, initLifetime,
+            acceptLifetime, mech, usage);
+    }
+
+    private void add(GSSName name, String password, Map<String,String> store,
+                    int initLifetime, int acceptLifetime, Oid mech, int usage)
+                    throws GSSException {
 
         if (destroyed) {
             throw new IllegalStateException("This credential is " +
@@ -459,12 +510,27 @@ public class GSSCredentialImpl implements GSSCredential {
         GSSNameSpi nameElement = (name == null ? null :
                                   ((GSSNameImpl)name).getElement(mech));
 
-        tempCred = gssManager.getCredentialElement(nameElement,
-                                                   password,
-                                                   initLifetime,
-                                                   acceptLifetime,
-                                                   mech,
-                                                   usage);
+        if (password == null && store == null) {
+            tempCred = gssManager.getCredentialElement(nameElement,
+                                                       initLifetime,
+                                                       acceptLifetime,
+                                                       mech,
+                                                       usage);
+        } else if (password != null) {
+            tempCred = gssManager.getCredentialElement(nameElement,
+                                                       password,
+                                                       initLifetime,
+                                                       acceptLifetime,
+                                                       mech,
+                                                       usage);
+        } else {
+            tempCred = gssManager.getCredentialElement(nameElement,
+                                                       store,
+                                                       initLifetime,
+                                                       acceptLifetime,
+                                                       mech,
+                                                       usage);
+        }
         /*
          * Not all mechanisms support the concept of one credential element
          * that can be used for both initiating and accepting a context. In
@@ -498,19 +564,26 @@ public class GSSCredentialImpl implements GSSCredential {
                 key = new SearchKey(mech, currentUsage);
                 hashtable.put(key, tempCred);
 
-                if (password == null) {
+                if (store == null && password == null) {
                     tempCred = gssManager.getCredentialElement(nameElement,
                                                                initLifetime,
                                                                acceptLifetime,
                                                                mech,
                                                                desiredUsage);
-                } else {
+                } else if (password != null) {
                     tempCred = gssManager.getCredentialElement(nameElement,
                                                                password,
                                                                initLifetime,
                                                                acceptLifetime,
                                                                mech,
                                                                desiredUsage);
+                } else {
+                    tempCred = gssManager.getCredentialElement(nameElement,
+                                                               store,
+                                                               initLifetime,
+                                                               acceptLifetime,
+                                                               mech,
+                                                               desiredUsage);
                 }
 
                 key = new SearchKey(mech, desiredUsage);
@@ -673,6 +746,31 @@ public class GSSCredentialImpl implements GSSCredential {
         return displayString;
     }
 
+    public void storeInto(int usage, Oid mech,
+                          boolean overwrite, boolean defaultCred,
+                          Map<String,String> store) throws GSSException {
+        if (destroyed) {
+            throw new IllegalStateException("This credential is " +
+                                            "no longer valid");
+        }
+
+        SearchKey key = null;
+        GSSCredentialSpi element = null;
+
+        if (mech == null) {
+            mech = ProviderList.DEFAULT_MECH_OID;
+        }
+
+        key = new SearchKey(mech, usage);
+        element = hashtable.get(key);
+        if (element == null) {
+            throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
+        }
+
+        element.storeInto(usage, overwrite, defaultCred, store);
+    }
+
+
     public String toString() {
 
         if (destroyed) {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java
index 8298be9926..b75e65e8d7 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java
@@ -25,6 +25,7 @@
 
 package sun.security.jgss;
 
+import java.util.Map;
 import org.ietf.jgss.*;
 import sun.security.action.GetBooleanAction;
 import sun.security.jgss.spi.*;
@@ -135,6 +136,14 @@ public class GSSManagerImpl extends GSSManager {
         return wrap(new GSSCredentialImpl(this, aName, lifetime, mech, usage));
     }
 
+    public GSSCredential createCredential(GSSName aName,
+                                          Map<String,String> store,
+                                          int lifetime, Oid mech, int usage)
+        throws GSSException {
+        return new GSSCredentialImpl(this, aName, store, lifetime, mech,
+            usage);
+    }
+
     public GSSCredential createCredential(GSSName aName, String password,
                                           int lifetime, Oid mech, int usage)
         throws GSSException {
@@ -155,6 +164,14 @@ public class GSSManagerImpl extends GSSManager {
                 lifetime, mechs, usage);
     }
 
+    public GSSCredential createCredential(GSSName aName,
+                                          Map<String,String> store,
+                                          int lifetime, Oid mechs[], int usage)
+        throws GSSException {
+        return new GSSCredentialImpl(this, aName, store,
+                lifetime, mechs, usage);
+    }
+
     public GSSContext createContext(GSSName peer, Oid mech,
                                     GSSCredential myCred, int lifetime)
         throws GSSException {
@@ -200,6 +217,17 @@ public class GSSManagerImpl extends GSSManager {
                                             acceptLifetime, usage);
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 Map<String,String> store,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 Oid mech, int usage)
+        throws GSSException {
+        MechanismFactory factory = list.getMechFactory(mech);
+        return factory.getCredentialElement(name, store, initLifetime,
+                                            acceptLifetime, usage);
+    }
+
     // Used by java SPNEGO impl
     public GSSNameSpi getNameElement(String name, Oid nameType, Oid mech)
         throws GSSException {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java
index ab06ff6c81..a9c2d48de4 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java
@@ -32,6 +32,7 @@ import sun.security.jgss.spi.*;
 import javax.security.auth.kerberos.ServicePermission;
 import java.security.Provider;
 import java.util.Vector;
+import java.util.Map;
 
 /**
  * Krb5 Mechanism plug in for JGSS
@@ -149,10 +150,60 @@ public final class Krb5MechFactory implements MechanismFactory {
         return credElement;
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+           Map<String,String> store, int initLifetime, int acceptLifetime,
+           int usage) throws GSSException {
+
+        if (store != null) {
+            // XXX Implement!  Shouldn't be too hard...
+            throw new GSSException(GSSException.UNAVAILABLE, -1,
+                    "The Kerberos mechanism Java implementation does not " +
+                    "currently support acquiring GSS credentials handle " +
+                    "elements using a \"credential store\"");
+        }
+
+        if (name != null && !(name instanceof Krb5NameElement)) {
+            name = Krb5NameElement.getInstance(name.toString(),
+                                       name.getStringNameType());
+        }
+
+        Krb5CredElement credElement = getCredFromSubject
+            (name, (usage != GSSCredential.ACCEPT_ONLY));
+
+        if (credElement == null) {
+            if (usage == GSSCredential.INITIATE_ONLY ||
+                usage == GSSCredential.INITIATE_AND_ACCEPT) {
+                credElement = Krb5InitCredential.getInstance
+                    (caller, (Krb5NameElement) name, initLifetime);
+                checkInitCredPermission
+                    ((Krb5NameElement) credElement.getName());
+            } else if (usage == GSSCredential.ACCEPT_ONLY) {
+                credElement =
+                    Krb5AcceptCredential.getInstance(caller,
+                                                     (Krb5NameElement) name);
+                checkAcceptCredPermission
+                    ((Krb5NameElement) credElement.getName(), name);
+            } else
+                throw new GSSException(GSSException.FAILURE, -1,
+                                       "Unknown usage mode requested");
+        }
+        return credElement;
+    }
+
     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
             int initLifetime, int acceptLifetime, int usage)
         throws GSSException {
-        return getCredentialElement(name, null, initLifetime, acceptLifetime, usage);
+        return getCredentialElement(name, initLifetime, acceptLifetime,
+            usage);
+    }
+
+    public void storeCredInto(GSSCredentialSpi cred, int usage,
+                              boolean overwrite, boolean defaultCred,
+                              Map<String,String> store) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "The Kerberos mechanism Java implementation does not " +
+                "currently support storing GSS credentials handle " +
+                "elements into a \"credential store\"");
     }
 
     public static void checkInitCredPermission(Krb5NameElement name) {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java b/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java
index c417c9999b..73b2c052c0 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java
@@ -27,6 +27,7 @@ package sun.security.jgss.spi;
 
 import org.ietf.jgss.*;
 import java.security.Provider;
+import java.util.Map;
 
 /**
  * This interface is implemented by a mechanism specific credential
@@ -104,6 +105,26 @@ public interface GSSCredentialSpi {
      */
     public Oid getMechanism();
 
+    /**
+     * Stores a credential in the location specified by the store
+     * argument.
+     *
+     * @param usage The credential usage to store.
+     * @param overwrite Whether to overwrite any credential found at the
+     * given store location.
+     * @param defaultCred Whether to make the credential the default
+     * credential in the store at the given location.
+     * @param store A map of string keys and values specifying a store
+     * location.
+     */
+    default void storeInto(int usage, boolean overwrite, boolean defaultCred,
+                           Map<String,String> store) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "The " + getMechanism() + "mechanism does not " +
+                "currently support storing GSS credentials handle " +
+                "elements into a \"credential store\"");
+    }
+
     /**
      * Impersonates another client.
      *
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java
index 51ce06614a..c1467a960d 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java
@@ -27,6 +27,7 @@ package sun.security.jgss.spi;
 
 import org.ietf.jgss.*;
 import java.security.Provider;
+import java.util.Map;
 
 /**
  * This interface is implemented by the factory class for every
@@ -146,6 +147,8 @@ public interface MechanismFactory {
      * @param name the mechanism level name element for the entity whose
      * credential is desired. A null value indicates that a mechanism
      * dependent default choice is to be made.
+     * @param password is the password for the entity whose credential
+     * is desired.
      * @param initLifetime indicates the lifetime (in seconds) that is
      * requested for this credential to be used at the context initiator's
      * end. This value should be ignored if the usage is
@@ -166,6 +169,85 @@ public interface MechanismFactory {
       String password, int initLifetime, int acceptLifetime, int usage)
         throws GSSException;
 
+    /**
+     * Creates a credential element using a "credential store" for this
+     * mechanism to be included as part of a GSSCredential
+     * implementation. A GSSCredential is conceptually a container class
+     * of several credential elements from different mechanisms. A
+     * GSS-API credential can be used either for initiating GSS security
+     * contexts or for accepting them. This method also accepts
+     * parameters that indicate what usage is expected and how long the
+     * life of the credential should be. It is not necessary that the
+     * mechanism honor the request for lifetime. An application will
+     * always query an acquired GSSCredential to determine what lifetime
+     * it got back.<p>
+     *
+     * <b>Not all mechanisms support the concept of one credential element
+     * that can be used for both initiating and accepting a context. In the
+     * event that an application requests usage INITIATE_AND_ACCEPT for a
+     * credential from such a mechanism, the GSS framework will need to
+     * obtain two different credential elements from the mechanism, one
+     * that will have usage INITIATE_ONLY and another that will have usage
+     * ACCEPT_ONLY. The mechanism will help the GSS-API realize this by
+     * returning a credential element with usage INITIATE_ONLY or
+     * ACCEPT_ONLY prompting it to make another call to
+     * getCredentialElement, this time with the other usage mode. The
+     * mechanism indicates the missing mode by returning a 0 lifetime for
+     * it.</b>
+     *
+     * @param name the mechanism level name element for the entity whose
+     * credential is desired. A null value indicates that a mechanism
+     * dependent default choice is to be made.
+     * @param store is an array of even length whose elements at even
+     * indices are keys, and whose elements at any odd index are the
+     * values for the preceding keys. Keys supported by mechanisms
+     * vary. This is mostly intended for use with the platform's native
+     * GSS-API providers. Common keys include "keytab", "client_keytab",
+     * "ccache", and "rcache". Consult the documentation for the
+     * platform's native GSS-API providers.
+     * @param initLifetime indicates the lifetime (in seconds) that is
+     * requested for this credential to be used at the context initiator's
+     * end. This value should be ignored if the usage is
+     * ACCEPT_ONLY. Predefined contants are available in the
+     * org.ietf.jgss.GSSCredential interface.
+     * @param acceptLifetime indicates the lifetime (in seconds) that is
+     * requested for this credential to be used at the context acceptor's
+     * end. This value should be ignored if the usage is
+     * INITIATE_ONLY. Predefined contants are available in the
+     * org.ietf.jgss.GSSCredential interface.
+     * @param usage One of the values GSSCredential.INIATE_ONLY,
+     * GSSCredential.ACCEPT_ONLY, and GSSCredential.INITIATE_AND_ACCEPT.
+     * @see org.ietf.jgss.GSSCredential
+     * @throws GSSException if one of the error situations described in RFC
+     * 2743 with the GSS_Acquire_Cred or GSS_Add_Cred calls occurs.
+     */
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 Map<String,String> store,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 int usage)
+        throws GSSException;
+
+    /**
+     * Stores a credential element into a specified location.
+     *
+     * @param cred The credential element to store.
+     * @param usage The credential usage to store.
+     * @param overwrite Whether to overwrite credentials found at the specified
+     * location.
+     * @param @defaultCred Whether to store the credentials as the default
+     * credentials in the specified location.
+     * @param store The location into which to store the credentials.
+     */
+    default void storeCredInto(GSSCredentialSpi cred, int usage,
+                              boolean overwrite, boolean defaultCred,
+                              Map<String,String> store) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "The " + getMechanismOid() + "mechanism does not " +
+                "currently support storing GSS credentials handle " +
+                "elements into a \"credential store\"");
+    }
+
     /**
      * Creates a name element for this mechanism to be included as part of
      * a GSSName implementation. A GSSName is conceptually a container
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
index 336f88e823..c12c77b708 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
@@ -34,6 +34,7 @@ import sun.security.jgss.krb5.Krb5AcceptCredential;
 import sun.security.jgss.krb5.Krb5NameElement;
 import java.security.Provider;
 import java.util.Vector;
+import java.util.Map;
 
 /**
  * SpNego Mechanism plug in for JGSS
@@ -169,6 +170,31 @@ public final class SpNegoMechFactory implements MechanismFactory {
         return credElement;
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+           Map<String,String> store, int initLifetime, int acceptLifetime,
+           int usage) throws GSSException {
+
+        SpNegoCredElement credElement = getCredFromSubject
+            (name, (usage != GSSCredential.ACCEPT_ONLY));
+
+        if (credElement == null) {
+            // get CredElement for the default Mechanism
+            credElement = new SpNegoCredElement
+                (manager.getCredentialElement(name, store, initLifetime,
+                acceptLifetime, null, usage));
+        }
+        return credElement;
+    }
+
+    public void storeCredInto(GSSCredentialSpi cred, int usage,
+                              boolean overwrite, boolean defaultCred,
+                              Map<String,String> store) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "The SpNego mechanism does not " +
+                "currently support storing GSS credentials handle " +
+                "elements into a \"credential store\"");
+    }
+
     public GSSContextSpi getMechanismContext(GSSNameSpi peer,
                              GSSCredentialSpi myInitiatorCred, int lifetime)
         throws GSSException {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
index c2fc315268..5979a6ebe0 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
@@ -26,6 +26,9 @@ package sun.security.jgss.wrapper;
 
 import org.ietf.jgss.*;
 import java.security.Provider;
+import java.util.Map;
+import java.util.List;
+import java.util.ArrayList;
 import sun.security.jgss.GSSUtil;
 import sun.security.jgss.spi.GSSCredentialSpi;
 import sun.security.jgss.spi.GSSNameSpi;
@@ -74,31 +77,49 @@ public class GSSCredElement implements GSSCredentialSpi {
         name = srcName;
     }
 
-    GSSCredElement(GSSNameElement name, String password, int lifetime,
-                   int usage, GSSLibStub stub) throws GSSException {
+    private GSSCredElement(GSSNameElement name, String password,
+                           Map<String,String> store, int lifetime, int usage,
+                           GSSLibStub stub) throws GSSException {
         cStub = stub;
         this.usage = usage;
 
         if (name != null) { // Could be GSSNameElement.DEF_ACCEPTOR
             this.name = name;
             doServicePermCheck();
-            pCred = cStub.acquireCred(this.name.pName, password, lifetime,
-                    usage);
+            pCred = cStub.acquireCred(this.name.pName, password, store,
+                lifetime, usage);
             if (name == GSSNameElement.DEF_ACCEPTOR)
                 isDefCred = true;
         } else {
-            pCred = cStub.acquireCred(0, password, lifetime, usage);
+            pCred = cStub.acquireCred(0, password, store, lifetime, usage);
             this.name = new GSSNameElement(cStub.getCredName(pCred), cStub.getMech(), cStub);
             doServicePermCheck();
             isDefCred = true;
         }
     }
 
+    GSSCredElement(GSSNameElement name, Map<String,String> store, int lifetime,
+                   int usage, GSSLibStub stub) throws GSSException {
+        this(name, (String)null, store, lifetime, usage, stub);
+    }
+
+    GSSCredElement(GSSNameElement name, String password, int lifetime,
+                   int usage, GSSLibStub stub) throws GSSException {
+        this(name, password, (Map<String,String>)null, lifetime, usage, stub);
+    }
+
     GSSCredElement(GSSNameElement name, int lifetime, int usage,
                    GSSLibStub stub) throws GSSException {
         this(name, (String)null, lifetime, usage, stub);
     }
 
+    public void storeInto(int usage, boolean overwrite, boolean defaultCred,
+                          Map<String,String> store)
+            throws GSSException {
+        cStub.storeCred(pCred, usage, getMechanism(), overwrite,
+                        defaultCred, store);
+    }
+
     public Provider getProvider() {
         return SunNativeProvider.INSTANCE;
     }
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
index d6089781b2..8971093165 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
@@ -25,6 +25,8 @@
 
 package sun.security.jgss.wrapper;
 
+import java.util.Map;
+import java.util.ArrayList;
 import java.util.Hashtable;
 import org.ietf.jgss.Oid;
 import org.ietf.jgss.GSSName;
@@ -69,8 +71,11 @@ class GSSLibStub {
     native Object[] displayName(long pName) throws GSSException;
 
     // Credential related routines
-    native long acquireCred(long pName, String password,
+    native long acquireCred(long pName, String password, String[] store,
                             int lifetime, int usage) throws GSSException;
+    native long storeCred(long pCred, int usage, Oid mech,
+                          boolean overwrite, boolean defaultCred,
+                          String[] store) throws GSSException;
     native long releaseCred(long pCred);
     native long getCredName(long pCred);
     native int getCredTime(long pCred);
@@ -111,6 +116,27 @@ class GSSLibStub {
         this.mech = mech;
         this.pMech = getMechPtr(mech.getDER());
     }
+    private static String[] map2array(Map<String,String> m) {
+        if (m == null)
+            return null;
+        ArrayList<String> l = new ArrayList<String>();
+        for (var e : m.entrySet()) {
+            l.add(e.getKey());
+            l.add(e.getValue());
+        }
+        return l.toArray(new String[0]);
+    }
+    public long acquireCred(long pName, String password,
+                            Map<String,String> store,
+                            int lifetime, int usage) throws GSSException {
+        return acquireCred(pName, password, map2array(store), lifetime, usage);
+    }
+    public long storeCred(long pCred, int usage, Oid mech,
+                          boolean overwrite, boolean defaultCred,
+                          Map<String,String> store) throws GSSException {
+        return storeCred(pCred, usage, mech, overwrite, defaultCred,
+            map2array(store));
+    }
     public boolean equals(Object obj) {
         if (obj == this) return true;
         if (!(obj instanceof GSSLibStub)) {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java
index 66dd30660c..54d3ad5c6b 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java
@@ -27,6 +27,7 @@ package sun.security.jgss.wrapper;
 
 import java.io.UnsupportedEncodingException;
 import java.security.Provider;
+import java.util.Map;
 import java.util.Vector;
 import org.ietf.jgss.*;
 import sun.security.jgss.GSSUtil;
@@ -148,11 +149,63 @@ public final class NativeGSSFactory implements MechanismFactory {
     }
 
     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 Map<String,String> store,
                                                  int initLifetime,
                                                  int acceptLifetime,
                                                  int usage)
         throws GSSException {
-        return getCredentialElement(name, null, initLifetime,
+        GSSNameElement nname = null;
+        if (name != null && !(name instanceof GSSNameElement)) {
+            nname = (GSSNameElement)
+                getNameElement(name.toString(), name.getStringNameType());
+        } else nname = (GSSNameElement) name;
+
+        if (usage == GSSCredential.INITIATE_AND_ACCEPT) {
+            // Force separate acqusition of cred element since
+            // MIT's impl does not correctly report NO_CRED error.
+            usage = GSSCredential.INITIATE_ONLY;
+        }
+
+        GSSCredElement credElement =
+            getCredFromSubject(nname, (usage == GSSCredential.INITIATE_ONLY));
+
+        if (credElement == null) {
+            // No cred in the Subject
+            if (usage == GSSCredential.INITIATE_ONLY) {
+                if (store == null) {
+                    credElement = new GSSCredElement(nname, initLifetime,
+                                                     usage, cStub);
+                } else {
+                    credElement = new GSSCredElement(nname, store,
+                                                     initLifetime,
+                                                     usage, cStub);
+                }
+            } else if (usage == GSSCredential.ACCEPT_ONLY) {
+                if (nname == null) {
+                    nname = GSSNameElement.DEF_ACCEPTOR;
+                }
+                if (store == null) {
+                    credElement = new GSSCredElement(nname, acceptLifetime,
+                                                     usage, cStub);
+                } else {
+                    credElement = new GSSCredElement(nname, store,
+                                                     acceptLifetime,
+                                                     usage, cStub);
+                }
+            } else {
+                throw new GSSException(GSSException.FAILURE, -1,
+                                       "Unknown usage mode requested");
+            }
+        }
+        return credElement;
+    }
+
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 int usage)
+        throws GSSException {
+        return getCredentialElement(name, (String)null, initLifetime,
                                     acceptLifetime, usage);
     }
 
diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index 50d5d962c2..dcc618da64 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -641,13 +641,14 @@ Java_sun_security_jgss_wrapper_GSSLibStub_displayName(JNIEnv *env,
 /*
  * Class:     sun_security_jgss_wrapper_GSSLibStub
  * Method:    acquireCred
- * Signature: (JLjava/lang/String;II)J
+ * Signature: (JLjava/lang/String;[II)J
  */
 JNIEXPORT jlong JNICALL
 Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
                                                       jobject jobj,
                                                       jlong pName,
                                                       jstring jPassword,
+                                                      jarray jCredStore,
                                                       jint reqTime,
                                                       jint usage)
 {
@@ -663,6 +664,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
   TRACE0("[GSSLibStub_acquireCred]");
 
   mech = (gss_OID) jlong_to_ptr((*env)->GetLongField(env, jobj, FID_GSSLibStub_pMech));
+  mechs = makeGSSOIDSet(&singleton, mech);
   credUsage = (gss_cred_usage_t) usage;
   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 
@@ -670,11 +672,10 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
 
   /* gss_acquire_cred(...) => GSS_S_BAD_MECH, GSS_S_BAD_NAMETYPE,
      GSS_S_BAD_NAME, GSS_S_CREDENTIALS_EXPIRED, GSS_S_NO_CRED */
-  if (jPassword == NULL) {
-    mechs = makeGSSOIDSet(&singleton, mech);
+  if (jPassword == NULL && jCredStore == NULL) {
     major = (*ftab->acquireCred)(&minor, nameHdl, reqTime, mechs, credUsage,
                                  &credHdl, NULL, NULL);
-  } else {
+  } else if (jPassword != NULL) {
     gss_buffer_desc password;
 
     if (ftab->acquireCredWithPassword == NULL) {
@@ -687,11 +688,35 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
     }
 
     initGSSBufferString(env, jPassword, &password);
-    mechs = makeGSSOIDSet(&singleton, mech);
+    if ((*env)->ExceptionCheck(env)) {
+      return jlong_zero;
+    }
     major = (*ftab->acquireCredWithPassword)(&minor, nameHdl, &password,
                                              reqTime, mechs, credUsage,
                                              &credHdl, NULL, NULL);
     resetGSSBufferString(env, jPassword, &password);
+  } else {
+    gss_key_value_set_desc credStore = {0, 0};
+
+    if (ftab->acquireCredFrom == NULL) {
+      const char *msg = "GSSLibStub_acquireCred from credential store not "
+          "supported by GSS provider";
+
+      TRACE0("[GSSLibStub_acquireCred] acquiring from a specific credential "
+             "store not supported by GSS provider");
+      checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,
+                  "[GSSLibStub_acquireCred]");
+      return ptr_to_jlong(NULL);
+    }
+
+    initGSSCredStore(env, jCredStore, &credStore);
+    if ((*env)->ExceptionCheck(env)) {
+      return jlong_zero;
+    }
+    major = (*ftab->acquireCredFrom)(&minor, nameHdl, reqTime, mechs,
+                                     credUsage, &credStore, &credHdl,
+                                     NULL, NULL);
+    resetGSSCredStore(env, jCredStore, &credStore);
   }
 
   TRACE1("[GSSLibStub_acquireCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
@@ -703,6 +728,64 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
   return ptr_to_jlong(credHdl);
 }
 
+/*
+ * Class:     sun_security_jgss_wrapper_GSSLibStub
+ * Method:    storeCred
+ * Signature: (JILorg/ietf/jgss/Oid;ZZ[)J
+ */
+JNIEXPORT jlong JNICALL
+Java_sun_security_jgss_wrapper_GSSLibStub_storeCred(JNIEnv *env,
+                                                    jobject jobj,
+                                                    jlong pCred,
+                                                    jint usage,
+                                                    jobject jmech,
+                                                    jboolean overwrite,
+                                                    jboolean defaultCred,
+                                                    jarray jCredStore)
+{
+  OM_uint32 minor, major;
+  gss_key_value_set_desc credStore;
+  gss_cred_usage_t credUsage;
+  gss_cred_id_t credHdl;
+  gss_OID mech;
+
+  TRACE0("[GSSLibStub_storeCred]");
+
+  credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
+  credUsage = (gss_cred_usage_t) usage;
+
+  mech = newGSSOID(env, jmech);
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+
+  TRACE2("[GSSLibStub_storeCred] pCred=%ld, usage=%d", (long)pCred, usage);
+
+  if (ftab->storeCredInto == NULL) {
+    TRACE0("[GSSLibStub_storeCred] GSSLibStub_storeCred not supported by "
+           "GSS provider");
+    checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, "[GSSLibStub_storeCred]");
+    return ptr_to_jlong(NULL);
+  }
+
+  initGSSCredStore(env, jCredStore, &credStore);
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+  major = (*ftab->storeCredInto)(&minor, credHdl, credUsage, mech,
+                                 overwrite, defaultCred, &credStore,
+                                 NULL, NULL);
+  resetGSSCredStore(env, jCredStore, &credStore);
+
+  TRACE1("[GSSLibStub_storeCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_storeCred]");
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+  return ptr_to_jlong(credHdl);
+}
+
 /*
  * Class:     sun_security_jgss_wrapper_GSSLibStub
  * Method:    releaseCred
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeFunc.c b/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
index 650520d173..23315bd1db 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
@@ -37,6 +37,8 @@ static const char DISPLAY_NAME[]                = "gss_display_name";
 static const char LOCAL_NAME[]                  = "gss_localname";
 static const char ACQUIRE_CRED[]                = "gss_acquire_cred";
 static const char ACQUIRE_CRED_WITH_PASSWORD[]  = "gss_acquire_cred_with_password";
+static const char ACQUIRE_CRED_FROM[]           = "gss_acquire_cred_from";
+static const char STORE_CRED_INTO[]             = "gss_store_cred_into";
 static const char RELEASE_CRED[]                = "gss_release_cred";
 static const char INQUIRE_CRED[]                = "gss_inquire_cred";
 static const char IMPORT_SEC_CONTEXT[]          = "gss_import_sec_context";
@@ -137,11 +139,15 @@ int loadNative(const char *libName) {
     }
 
     /*
-     * This one may not be available for a given GSS library, as it's an
-     * extension, therefore we don't fail if it's missing.
+     * These may not be available for a given GSS library, as they are
+     * extensions, therefore we don't fail if it's missing.
      */
     ftab->acquireCredWithPassword = (ACQUIRE_CRED_WITH_PASSWORD_FN_PTR)
                         GETFUNC(gssLib, ACQUIRE_CRED_WITH_PASSWORD);
+    ftab->acquireCredFrom = (ACQUIRE_CRED_FROM_FN_PTR)
+                        GETFUNC(gssLib, ACQUIRE_CRED_FROM);
+    ftab->storeCredInto = (STORE_CRED_INTO_FN_PTR)
+                        GETFUNC(gssLib, STORE_CRED_INTO);
 
     ftab->releaseCred = (RELEASE_CRED_FN_PTR)GETFUNC(gssLib, RELEASE_CRED);
     if (ftab->releaseCred == NULL) {
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeFunc.h b/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
index 6326618f11..525fa02d75 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
@@ -111,6 +111,28 @@ typedef OM_uint32 (*ACQUIRE_CRED_WITH_PASSWORD_FN_PTR)
                                 gss_OID_set *actual_mechs,
                                 OM_uint32 *time_rec);
 
+typedef OM_uint32 (*ACQUIRE_CRED_FROM_FN_PTR)
+                                (OM_uint32 *minor_status,
+                                 gss_const_name_t desired_name,
+                                 OM_uint32 time_req,
+                                 const gss_OID_set desired_mechs,
+                                 gss_cred_usage_t cred_usage,
+                                 gss_const_key_value_set_t cred_store,
+                                 gss_cred_id_t * output_cred_handle,
+                                 gss_OID_set * actual_mechs,
+                                 OM_uint32 * time_rec);
+
+typedef OM_uint32 (*STORE_CRED_INTO_FN_PTR)
+                                (OM_uint32 *minor_status,
+                                 gss_const_cred_id_t input_cred_handle,
+                                 gss_cred_usage_t input_usage,
+                                 const gss_OID desired_mech,
+                                 OM_uint32 overwrite_cred,
+                                 OM_uint32 default_cred,
+                                 gss_const_key_value_set_t cred_store,
+                                 gss_OID_set * elements_stored,
+                                 gss_cred_usage_t * cred_usage_stored);
+
 typedef OM_uint32 (*RELEASE_CRED_FN_PTR)
                                 (OM_uint32 *minor_status,
                                 gss_cred_id_t *cred_handle);
@@ -269,6 +291,8 @@ typedef struct GSS_FUNCTION_TABLE {
     LOCAL_NAME_FN_PTR                   localName;
     ACQUIRE_CRED_FN_PTR                 acquireCred;
     ACQUIRE_CRED_WITH_PASSWORD_FN_PTR   acquireCredWithPassword;
+    ACQUIRE_CRED_FROM_FN_PTR            acquireCredFrom;
+    STORE_CRED_INTO_FN_PTR              storeCredInto;
     RELEASE_CRED_FN_PTR                 releaseCred;
     INQUIRE_CRED_FN_PTR                 inquireCred;
     IMPORT_SEC_CONTEXT_FN_PTR           importSecContext;
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
index a9e2cf507b..54e9bef735 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
@@ -680,6 +680,77 @@ void resetGSSBufferString(JNIEnv *env, jstring jstr, gss_buffer_t buf)
     (*env)->ReleaseStringUTFChars(env, jstr, buf->value);
 }
 
+void initGSSCredStore(JNIEnv *env, jarray jstore,
+                      gss_key_value_set_desc *store) {
+  jsize nelements = 0;
+  jsize n, i, k;
+
+  store->count = 0;
+  store->elements = NULL;
+  if (jstore == NULL) {
+    return;
+  }
+  n = (*env)->GetArrayLength(env, jstore);
+  for (i = 0; i < n; i += 2) {
+    jobject jkey = (*env)->GetObjectArrayElement(env, jstore, i);
+    jobject jval = (*env)->GetObjectArrayElement(env, jstore, i + 1);
+    
+    if (!jkey || !jval) {
+      break;
+    }
+    if (!(*env)->IsInstanceOf(env, jkey, CLS_String) ||
+        !(*env)->IsInstanceOf(env, jval, CLS_String)) {
+      throwByName(env, "java/lang/IllegalArgumentException",
+                  "invalid GSS credential store element type; must be String");
+      store->count = 0;
+      return;
+    }
+    store->count += 1;
+    nelements += 2;
+  }
+  if (nelements < 0 || nelements > INT32_MAX) {
+    throwOutOfMemoryError(env,NULL);
+    store->count = 0;
+    return;
+  }
+  store->elements = calloc(store->count, sizeof(store->elements[0]));
+  if (store->elements == NULL) {
+    throwOutOfMemoryError(env,NULL);
+    store->count = 0;
+    return;
+  }
+  for (i = 0, k = 0; i < nelements; i += 2, k++) {
+    jobject jkey = (*env)->GetObjectArrayElement(env, jstore, i);
+    jobject jval = (*env)->GetObjectArrayElement(env, jstore, i + 1);
+    store->elements[k].key = (*env)->GetStringUTFChars(env, jkey, NULL);
+    store->elements[k].value = (*env)->GetStringUTFChars(env, jval, NULL);
+    TRACE2("[GSSLibStub initGSSCredStore] element %ld key %s",
+           (long)k, store->elements[k].key);
+    TRACE2("[GSSLibStub initGSSCredStore] element %ld value %s",
+           (long)k, store->elements[k].value);
+  }
+}
+
+void resetGSSCredStore(JNIEnv *env,
+                       jarray jstore,
+                       gss_key_value_set_desc *store) {
+  jobject jstr;
+  jsize i;
+
+  for (i = 0; i < (jsize)store->count; i++) {
+    jstr = (*env)->GetObjectArrayElement(env, jstore, i);
+    if (!(i & 0x01)) {
+      (*env)->ReleaseStringUTFChars(env, jstr, store->elements[i].key);
+    } else {
+      (*env)->ReleaseStringUTFChars(env, jstr, store->elements[i].value);
+    }
+  }
+  free(store->elements);
+  store->elements = NULL;
+  store->count = 0;
+}
+
+
 /*
  * Utility routine for creating a jbyteArray object using
  * the byte[] value in specified gss_buffer_t structure.
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
index 07f03046f5..70eb73ca81 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
@@ -40,9 +40,11 @@ extern "C" {
   extern jint checkTime(OM_uint32);
   extern void throwOutOfMemoryError(JNIEnv *, const char*);
   extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t, jboolean);
-  void resetGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
-  void initGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
-  void resetGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
+  extern void resetGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
+  extern void initGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
+  extern void resetGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
+  extern void initGSSCredStore(JNIEnv *, jarray, gss_key_value_set_desc *);
+  extern void resetGSSCredStore(JNIEnv *, jarray, gss_key_value_set_desc *);
 
   extern gss_OID newGSSOID(JNIEnv *, jobject);
   extern void deleteGSSOID(gss_OID);
diff --git a/src/java.security.jgss/share/native/libj2gss/gssapi.h b/src/java.security.jgss/share/native/libj2gss/gssapi.h
index 857077e49b..59ebeca554 100644
--- a/src/java.security.jgss/share/native/libj2gss/gssapi.h
+++ b/src/java.security.jgss/share/native/libj2gss/gssapi.h
@@ -119,6 +119,19 @@ typedef const struct gss_channel_bindings_struct *gss_const_channel_bindings_t;
 typedef OM_uint32       gss_qop_t;
 typedef int             gss_cred_usage_t;
 
+/* Credential store extensions */
+typedef struct gss_key_value_element_struct {
+    const char *key;
+    const char *value;
+} gss_key_value_element_desc;
+
+typedef struct gss_key_value_set_struct {
+    OM_uint32 count; /* should be size_t, but for MIT compat */
+    gss_key_value_element_desc *elements;
+} gss_key_value_set_desc, *gss_key_value_set_t;
+
+typedef const gss_key_value_set_desc *gss_const_key_value_set_t;
+
 /*
  * Flag bits for context-level services.
  */
@@ -703,10 +716,10 @@ GSS_DLLIMP OM_uint32 gss_canonicalize_name(
 OM_uint32
 gss_add_cred_with_password(
         OM_uint32 *,            /* minor_status */
-        const gss_cred_id_t,    /* input_cred_handle */
-        const gss_name_t,       /* desired_name */
-        const gss_OID,          /* desired_mech */
-        const gss_buffer_t,     /* password */
+        gss_const_cred_id_t,    /* input_cred_handle */
+        gss_const_name_t,       /* desired_name */
+        gss_const_OID,          /* desired_mech */
+        gss_const_buffer_t,     /* password */
         gss_cred_usage_t,       /* cred_usage */
         OM_uint32,              /* initiator_time_req */
         OM_uint32,              /* acceptor_time_req */
@@ -720,7 +733,7 @@ gss_add_cred_with_password(
 OM_uint32
 gss_localname(
         OM_uint32 *,            /* minor_status */
-        const gss_name_t,       /* name */
+        gss_const_name_t,       /* name */
         gss_OID,                /* mech_type */
         gss_buffer_t            /* localname */
 );

commit e3c725fe882daac1f3cd8d64f54233fffb63ed55
Author: Nico Williams <nico@twosigma.com>
Date:   Wed Sep 26 18:25:37 2018 -0500

    JGSS: Simplify context permissions checks
    
    We were reacquiring the initiator/acceptor credential upon security
    context full establishment in order to indirectly perform a permission
    check on the srcName/targName once we find out what they are.  But this
    is just one more way to end up failing, which happens with Heimdal when
    using SPNEGO because we ask to acquire a Kerberos credentials using a
    SPNEGO MN and that fails.
    
    Also, there was a security bug here: if the permission check fails then
    we raise, but if the application already has a context handle, then it
    can use it anyways if it catches the exception!  The fix for this is to
    dispose() when the permission check fails.

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
index 32205c96d3..cb6640d2f0 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
@@ -75,8 +75,8 @@ class NativeGSSContext implements GSSContextSpi {
     private int lifetime = GSSCredential.DEFAULT_LIFETIME;
     private final GSSLibStub cStub;
 
-    private boolean skipDelegPermCheck;
-    private boolean skipServicePermCheck;
+    private boolean skipDelegPermCheck = false;
+    private boolean skipServicePermCheck = false;
 
     // Retrieve the (preferred) mech out of SPNEGO tokens, i.e.
     // NegTokenInit & NegTokenTarg
@@ -111,28 +111,20 @@ class NativeGSSContext implements GSSContextSpi {
     // Perform the Service permission check
     private void doServicePermCheck() throws GSSException {
         if (System.getSecurityManager() != null) {
-            String action = (isInitiator? "initiate" : "accept");
-            // Need to check Service permission for accessing
-            // initiator cred for SPNEGO during context establishment
-            if (GSSUtil.isSpNegoMech(cStub.getMech()) && isInitiator
-                && !isEstablished) {
-                if (srcName == null) {
-                    // Check by creating default initiator KRB5 cred
-                    GSSCredElement tempCred =
-                        new GSSCredElement(null, lifetime,
-                                           GSSCredential.INITIATE_ONLY,
-                                           GSSLibStub.getInstance(GSSUtil.GSS_KRB5_MECH_OID));
-                    tempCred.dispose();
-                } else {
+            try {
+                if (isInitiator && srcName != null) {
                     String tgsName = Krb5Util.getTGSName(srcName);
-                    Krb5Util.checkServicePermission(tgsName, action);
+                    Krb5Util.checkServicePermission(tgsName, "initiate");
+                    skipServicePermCheck = true;
+                } else if (!isInitiator && targetName != null) {
+                    String targetStr = targetName.getKrbName();
+                    Krb5Util.checkServicePermission(targetStr, "accept");
+                    skipServicePermCheck = true;
                 }
+            } catch (GSSException ge) {
+                dispose();
+                throw ge;
             }
-            if (targetName == null)
-                return;
-            String targetStr = targetName.getKrbName();
-            Krb5Util.checkServicePermission(targetStr, action);
-            skipServicePermCheck = true;
         }
     }
 
@@ -204,13 +196,13 @@ class NativeGSSContext implements GSSContextSpi {
         lifetime = time;
 
         if (GSSUtil.isKerberosMech(cStub.getMech())) {
-            doServicePermCheck();
             if (cred == null) {
                 disposeCred = cred =
                     new GSSCredElement(null, lifetime,
                             GSSCredential.INITIATE_ONLY, cStub);
             }
             srcName = cred.getName();
+            doServicePermCheck();
         }
     }
 
@@ -307,6 +299,9 @@ class NativeGSSContext implements GSSContextSpi {
                 // getMechFromSpNegoToken() does the horrible, no good, very
                 // bad thing its name says it does.  For now we retain this bit
                 // of evil.
+                //
+                // XXX Time to remove this workaround.  It's been 20
+                // years.
                 try {
                     actualMech = getMechFromSpNegoToken(outToken, true);
                 } catch (GSSException e) { }
@@ -327,13 +322,7 @@ class NativeGSSContext implements GSSContextSpi {
                         (cStub.getContextName(pContext, true), actualMech,
                          cStub);
                 }
-                // XXX Attempt to get the actual target name from the cStub.
-
-                if (cred == null) {
-                    disposeCred = cred =
-                        new GSSCredElement(srcName, lifetime,
-                                GSSCredential.INITIATE_ONLY, cStub);
-                }
+                if (!skipServicePermCheck) doServicePermCheck();
             }
         }
         return outToken;
@@ -355,27 +344,15 @@ class NativeGSSContext implements GSSContextSpi {
             if (isEstablished && targetName == null) {
                 targetName = new GSSNameElement
                     (cStub.getContextName(pContext, false), actualMech, cStub);
-                // Replace the current default acceptor cred now that
-                // the context acceptor name is available
-                if (disposeCred != null) {
-                    disposeCred.dispose();
-                }
-                disposeCred = cred =
-                    new GSSCredElement(targetName, lifetime,
-                            GSSCredential.ACCEPT_ONLY, cStub);
             }
-
-            // Only inspect token when the permission check has not
-            // been performed
-            //
-            // XXX No, we should inspect the token the one time we can, just
-            // like with actualMech on the initiator side.
-            if (GSSUtil.isSpNegoMech(cStub.getMech()) &&
-                (outToken != null) && !skipServicePermCheck) {
-                if (GSSUtil.isKerberosMech(getMechFromSpNegoToken
-                                           (outToken, false))) {
-                    doServicePermCheck();
-                }
+            if (GSSUtil.isSpNegoMech(cStub.getMech()) && outToken != null &&
+                actualMech == null) {
+                try {
+                    actualMech = getMechFromSpNegoToken(outToken, true);
+                } catch (GSSException e) { }
+            }
+            if (isEstablished && targetName != null && !skipServicePermCheck) {
+                doServicePermCheck();
             }
         }
         return outToken;

commit b81971809c9677259c78bf670b3c16ed0faafdc8
Author: Nico Williams <nico@twosigma.com>
Date:   Thu Sep 27 12:41:48 2018 -0500

    Add commentary about permissions checks

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
index d066de5e96..2027f58377 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
@@ -198,6 +198,27 @@ public class GSSNameElement implements GSSNameSpi {
         long mName = 0;
         GSSLibStub stub = cStub;
         if (!GSSUtil.isKerberosMech(mech)) {
+            // XXX We can't expect this to work generally.  We should
+            // generalize the permission checks so that they can deal
+            // with name forms other than those of Kerberos.
+            //
+            // Alternatively we could have a method in GSSLibStub for
+            // mapping a non-Kerberos MN to a Kerberos MN, but depending
+            // on the specifics of the non-Kerberos mechanism we would
+            // either end up needing new conventions for Kerberos naming
+            // or else having cases where we can end up failing to
+            // support unconventional name forms.
+            //
+            // Consider a SAML assertion with a variety of identifying
+            // attributes and a variety of non-identifying attributes
+            // that are relevant to authorization.  How should a
+            // Kerberos-equivalent be constructed?  GSS does have
+            // extensions for decorating name objects with attributes,
+            // so that's not an issue, but if there are multiple
+            // identifying attributes then we'd have to pick one.  Now,
+            // suppose the identifying attribute has a form like
+            // <phone-number> -- we'd need a Kerberos convention for
+            // that, which might be PHONE/<number>@<ASSERTION-SIGNER>.
             stub = GSSLibStub.getInstance(GSSUtil.GSS_KRB5_MECH_OID);
         }
         mName = stub.canonicalizeName(pName);

commit 86ed2d817f37dde21b5d6ff87629e674f53ee813
Author: Nico Williams <nico@twosigma.com>
Date:   Fri Dec 4 22:14:59 2015 -0500

    FIXME commentary

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
index 5ae19bed34..336f88e823 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
@@ -79,6 +79,10 @@ public final class SpNegoMechFactory implements MechanismFactory {
                                     null : creds.firstElement());
 
         // Force permission check before returning the cred to caller
+        //
+        // FIXME This code assumes that the Kerberos mechanism is Java-coded,
+        // whereas it should be possible to mix Java-coded SPNEGO with a native
+        // (C-coded) mechanism.  For now this assumption stands.
         if (result != null) {
             GSSCredentialSpi cred = result.getInternalCred();
             if (GSSUtil.isKerberosMech(cred.getMechanism())) {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
index 5d2b7e6486..c2fc315268 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
@@ -45,7 +45,11 @@ public class GSSCredElement implements GSSCredentialSpi {
     public boolean isDefCred;
 
     // Perform the necessary ServicePermission check on this cred
+    // FIXME Don't use any Krb5-specific code here.
     void doServicePermCheck() throws GSSException {
+        // FIXME We need only do this check in initSecContext() and
+        // acceptSecContext(), so gut this here, and never ever do the
+        // Krb5Util.getTGSName(name) check.
         if (GSSUtil.isKerberosMech(cStub.getMech())) {
             if (System.getSecurityManager() != null) {
                 if (isInitiatorCredential()) {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java
index 8f78a3fe13..a80d0c3a1c 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java
@@ -109,7 +109,14 @@ public final class SunNativeProvider extends Provider {
                             if (GSSLibStub.init(libName, DEBUG)) {
                                 debug("Loaded GSS library: " + libName);
                                 Oid[] mechs = GSSLibStub.indicateMechs();
-                                HashMap<String,String> map = new HashMap<>();
+                                HashMap<String, String> map =
+                                            new HashMap<String, String>();
+                                // If the GSSLibStub does not support SPNEGO,
+                                // we could use ours, but ours has too much
+                                // knowledge of the Java Krb5 GSS mechanism, so
+                                // we can't, but if we could we'd do it thusly:
+                                //   map.put("GssApiMechanism.1.3.6.1.5.5.2",
+                                //           "sun.security.jgss.spnego.SpNegoMechFactory");
                                 for (int i = 0; i < mechs.length; i++) {
                                     debug("Native MF for " + mechs[i]);
                                     map.put("GssApiMechanism." + mechs[i],

commit 97fcf702006d18ca502a976730567fe42ad7375f
Author: Nico Williams <nico@twosigma.com>
Date:   Tue Aug 14 15:50:26 2018 -0500

    fixup SEAM bug uncomments

diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index 45e6ef8644..50d5d962c2 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -1000,9 +1000,11 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
                               FID_NativeGSSContext_isEstablished,
                               JNI_TRUE);
 
-      jMech = getJavaOID(env, aMech);
-      (*env)->SetObjectField(env, jcontextSpi,
-                             FID_NativeGSSContext_actualMech, jMech);
+      jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);
+      if (!(*env)->ExceptionCheck(env)) {
+        (*env)->SetObjectField(env, jcontextSpi,
+                               FID_NativeGSSContext_actualMech, jMech);
+      }
     } else if (major & GSS_S_CONTINUE_NEEDED) {
       TRACE0("[GSSLibStub_initContext] context not established");
       major &= ~GSS_S_CONTINUE_NEEDED;
@@ -1103,16 +1105,13 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
     /* update member values if needed */
 
-    if (aMech != GSS_C_NO_OID) {
-      jMech = getJavaOID(env, aMech);
-      if ((*env)->ExceptionCheck(env)) {
-        goto error;
-      }
+    jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);
+    if (!(*env)->ExceptionCheck(env)) {
       (*env)->SetObjectField(env, jcontextSpi,
                              FID_NativeGSSContext_actualMech, jMech);
-      if ((*env)->ExceptionCheck(env)) {
-        goto error;
-      }
+    }
+    if ((*env)->ExceptionCheck(env)) {
+      goto error;
     }
 
     /* WORKAROUND for an old Heimdal bug */

commit f3d9dd4a01a31a1c109f5954ddf34769f5584ade
Author: Nico Williams <nico@twosigma.com>
Date:   Tue Mar 8 23:54:45 2016 +0000

    Krb5LoginModule cleanup
    
    Add commentary about native in Krb5LoginModule

diff --git a/src/java.security.jgss/share/classes/sun/security/krb5/KrbAsReqBuilder.java b/src/java.security.jgss/share/classes/sun/security/krb5/KrbAsReqBuilder.java
index c626cfda8e..578ca84f65 100644
--- a/src/java.security.jgss/share/classes/sun/security/krb5/KrbAsReqBuilder.java
+++ b/src/java.security.jgss/share/classes/sun/security/krb5/KrbAsReqBuilder.java
@@ -473,6 +473,9 @@ public final class KrbAsReqBuilder {
         }
     }
 
+    // XXX It'd be nice to implement AutoCloseable with a close() that calls
+    // destroy()
+
     /**
      * Checks if the current state is the specified one.
      * @param st the expected state
diff --git a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java
index 605ff09e4e..0590b05152 100644
--- a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java
@@ -27,6 +27,7 @@
 package com.sun.security.auth.module;
 
 import java.io.*;
+import java.security.Principal;
 import java.text.MessageFormat;
 import java.util.*;
 
@@ -409,7 +410,6 @@ public class Krb5LoginModule implements LoginModule {
     private Credentials cred = null;
 
     private PrincipalName principal = null;
-    private KerberosPrincipal kerbClientPrinc = null;
     private KerberosTicket kerbTicket = null;
     private KerberosKey[] kerbKeys = null;
     private StringBuffer krb5PrincName = null;
@@ -520,6 +520,16 @@ public class Krb5LoginModule implements LoginModule {
      */
     public boolean login() throws LoginException {
 
+        /*
+         * Perhaps we should wrap this in a method that returns false if this
+         * throws and sun.security.jgss.native=true.  Or perhaps the wrapper
+         * could see if it can acquire comparable GSS credentials and then
+         * store those in the subject in commit() in that case (and then
+         * GSSUtil/Krb5Util code could be changed to look for those).
+         *
+         * See related commentary in GssLoginModule.
+         */
+
         if (refreshKrb5Config) {
             try {
                 if (debug) {
@@ -532,18 +542,30 @@ public class Krb5LoginModule implements LoginModule {
                 throw le;
             }
         }
+
+        // -Dsun.security.krb5.principal takes precedence over login module
+        // "principal" option
+        //
+        // XXX This seems misplaced.  This is configuration reading, and that
+        // clearly belongs in initialize().  It's not like it's very likely
+        // that this sequence of events takes place anywhere, much less that we
+        // should cater to it:
+        //
+        //  lc.initialize();
+        //  System.setProperty("sun.security.krb5.principal", ...);
+        //  lc.login();
         String principalProperty = System.getProperty
             ("sun.security.krb5.principal");
         if (principalProperty != null) {
             krb5PrincName = new StringBuffer(principalProperty);
-        } else {
-            if (princName != null) {
-                krb5PrincName = new StringBuffer(princName);
-            }
+        } else if (princName != null) {
+            krb5PrincName = new StringBuffer(princName);
         }
 
+        // XXX This really belongs in initialize()
         validateConfiguration();
 
+        // XXX This really belongs in validateConfiguration()
         if (krb5PrincName != null && krb5PrincName.toString().equals("*")) {
             unboundServer = true;
         }
@@ -632,52 +654,31 @@ public class Krb5LoginModule implements LoginModule {
         }
 
         try {
+            // This means "from the traditional FILE ccache"
             if (useTicketCache) {
-                // ticketCacheName == null implies the default cache
                 if (debug)
-                    System.out.println("Acquire TGT from Cache");
-                cred  = Credentials.acquireTGTFromCache
-                    (principal, ticketCacheName);
-
+                    System.out.println("Trying to acquire TGT from Cache");
+                cred = getCredsFromCCache(principal, renewTGT, ticketCacheName);
                 if (cred != null) {
-                    if (renewTGT && isOld(cred)) {
-                        // renew if ticket is old.
-                        Credentials newCred = renewCredentials(cred);
-                        if (newCred != null) {
-                            newCred.setProxy(cred.getProxy());
-                            cred = newCred;
-                        }
-                    }
+                    if (principal == null)
+                        principal = cred.getClient();
                     if (!isCurrent(cred)) {
-                        // credentials have expired
                         cred = null;
                         if (debug)
-                            System.out.println("Credentials are" +
-                                    " no longer valid");
-                    }
-                }
-
-                if (cred != null) {
-                   // get the principal name from the ticket cache
-                   if (principal == null) {
-                        principal = cred.getClient();
-                   }
-                }
-                if (debug) {
-                    System.out.println("Principal is " + principal);
-                    if (cred == null) {
-                        System.out.println
-                            ("null credentials from Ticket Cache");
+                            System.out.println("Found expired cached " +
+                                    "credentials for " + principal);
+                    } else if (debug) {
+                        System.out.println("Found cached credentials for "
+                                + principal);
                     }
+                } else if (debug) {
+                    System.out.println("Could not find cached credentials");
                 }
             }
 
-            // cred = null indicates that we didn't get the creds
-            // from the cache or useTicketCache was false
-
             if (cred == null) {
-                // We need the principal name whether we use keytab
-                // or AS Exchange
+                // !useTicketCache || credentials not found || expired
+
                 if (principal == null) {
                     promptForName(getPasswdFromSharedState);
                     principal = new PrincipalName
@@ -685,49 +686,19 @@ public class Krb5LoginModule implements LoginModule {
                          PrincipalName.KRB_NT_PRINCIPAL);
                 }
 
-                /*
-                 * Before dynamic KeyTab support (6894072), here we check if
-                 * the keytab contains keys for the principal. If no, keytab
-                 * will not be used and password is prompted for.
-                 *
-                 * After 6894072, we normally don't check it, and expect the
-                 * keys can be populated until a real connection is made. The
-                 * check is still done when isInitiator == true, where the keys
-                 * will be used right now.
-                 *
-                 * Probably tricky relations:
-                 *
-                 * useKeyTab is config flag, but when it's true but the ktab
-                 * does not contains keys for principal, we would use password
-                 * and keep the flag unchanged (for reuse?). In this method,
-                 * we use (ktab != null) to check whether keytab is used.
-                 * After this method (and when storeKey == true), we use
-                 * (encKeys == null) to check.
-                 */
                 if (useKeyTab) {
-                    if (!unboundServer) {
-                        KerberosPrincipal kp =
-                                new KerberosPrincipal(principal.getName());
-                        ktab = (keyTabName == null)
-                                ? KeyTab.getInstance(kp)
-                                : KeyTab.getInstance(kp, new File(keyTabName));
-                    } else {
-                        ktab = (keyTabName == null)
-                                ? KeyTab.getUnboundInstance()
-                                : KeyTab.getUnboundInstance(new File(keyTabName));
-                    }
-                    if (isInitiator) {
-                        if (Krb5Util.keysFromJavaxKeyTab(ktab, principal).length
+                    ktab = getKtab(keyTabName, principal, unboundServer);
+                    if (isInitiator &&
+                            Krb5Util.keysFromJavaxKeyTab(ktab, principal).length
                                 == 0) {
-                            ktab = null;
-                            if (debug) {
-                                System.out.println
-                                    ("Key for the principal " +
-                                     principal  +
-                                     " not available in " +
-                                     ((keyTabName == null) ?
-                                      "default key tab" : keyTabName));
-                            }
+                        ktab = null;
+                        if (debug) {
+                            System.out.println
+                                ("Key for the principal " +
+                                 principal  +
+                                 " not available in " +
+                                 ((keyTabName == null) ?
+                                  "default key tab" : keyTabName));
                         }
                     }
                 }
@@ -737,16 +708,21 @@ public class Krb5LoginModule implements LoginModule {
                 if (ktab == null) {
                     promptForPass(getPasswdFromSharedState);
                     builder = new KrbAsReqBuilder(principal, password);
-                    if (isInitiator) {
-                        // XXX Even if isInitiator=false, it might be
-                        // better to do an AS-REQ so that keys can be
-                        // updated with PA info
+                    if (isInitiator || storeKey) {
+                        // Even if isInitiator=false, if we want to accept with
+                        // long-term key derived from the password, then in
+                        // principle (and decidedly for new enctypes) we need
+                        // to do an AS exchange to get the PA etype info for
+                        // the derivation.  (For older enctypes this is bad, as
+                        // we will attempt to talk the a KDC we might not be
+                        // able to reach, then timeout...  If this is not
+                        // desired, the user can reconfigure the module.)
                         cred = builder.action().getCreds();
-                    }
-                    if (storeKey) {
-                        encKeys = builder.getKeys(isInitiator);
-                        // When encKeys is empty, the login actually fails.
-                        // For compatibility, exception is thrown in commit().
+                        if (storeKey) {
+                            encKeys = builder.getKeys(isInitiator);
+                            // When encKeys is empty, the login actually fails.
+                            // For compatibility, exception is thrown in commit().
+                        }
                     }
                 } else {
                     builder = new KrbAsReqBuilder(principal, ktab);
@@ -763,15 +739,15 @@ public class Krb5LoginModule implements LoginModule {
                         System.out.println("Will use keytab");
                     } else if (storeKey) {
                         for (int i = 0; i < encKeys.length; i++) {
+                            // Printing keys here just because debug is a bad
+                            // idea: stdout might be a file that gets sent to
+                            // loggers, and...  yeah, no.
                             System.out.println("EncryptionKey: keyType=" +
-                                encKeys[i].getEType() +
-                                " keyBytes (hex dump)=" +
-                                hd.encodeBuffer(encKeys[i].getBytes()));
+                                encKeys[i].getEType());
                         }
                     }
                 }
 
-                // we should hava a non-null cred
                 if (isInitiator && (cred == null)) {
                     throw new LoginException
                         ("TGT Can not be obtained from the KDC ");
@@ -962,6 +938,29 @@ public class Krb5LoginModule implements LoginModule {
         }
     }
 
+    private Credentials getCredsFromCCache(PrincipalName princ, boolean renewTGT, String ccacheName)
+        throws KrbException, IOException {
+        // ticketCacheName == null implies the default cache
+        // princ == null implies the cache's default princ(XXX?)
+        Credentials creds = Credentials.acquireTGTFromCache(princ, ccacheName);
+        if (creds == null)
+            return null;
+        if (renewTGT && timeToRenew(creds))
+            creds = possiblyRenewCreds(creds);
+        // It's the caller's job to deal with expired creds
+        return creds;
+    }
+
+    private KeyTab getKtab(String keyTabName, PrincipalName principal,
+            boolean unboundServer)
+    {
+        KerberosPrincipal kp = unboundServer ? null :
+            new KerberosPrincipal(principal.getName());;
+        return (keyTabName == null)
+            ? KeyTab.getInstance(kp) // default keytab
+            : KeyTab.getInstance(kp, new File(keyTabName));
+    }
+
     private static boolean isCurrent(Credentials creds)
     {
         Date endTime = creds.getEndTime();
@@ -971,47 +970,60 @@ public class Krb5LoginModule implements LoginModule {
         return true;
     }
 
-    private static boolean isOld(Credentials creds)
+    private static boolean timeToRenew(Credentials creds)
     {
+        if (!creds.isRenewable())
+            return false;
+
         Date endTime = creds.getEndTime();
-        if (endTime != null) {
-            Date authTime = creds.getAuthTime();
-            long now = System.currentTimeMillis();
-            if (authTime != null) {
-                // pass the mid between auth and end
-                return now - authTime.getTime() > endTime.getTime() - now;
-            } else {
-                // will expire in less than 2 hours
-                return now <= endTime.getTime() - 1000*3600*2L;
-            }
-        }
-        return false;
+
+        // endtime is required, so it can't be null.  We only have to check
+        // because it's Java and we could express that this can't be null.
+        // Strictly speaking we can leave out this test.
+        if (endTime == null)
+            return false;
+
+        // There's no point trying to renew a TGT we will be able to renew but
+        // with no additional lifetime.  And there's no point trying to renew
+        // non-renewable tickets.
+        Date renewTill = creds.getRenewTill();
+        if (renewTill == null || renewTill.getTime() <= endTime.getTime())
+            return false;
+
+        // NOTE WELL: We must use the *start* time, not the auth time, because
+        //            the auth time refers to when the AS exchange was done,
+        //            not to when the TGS exchange was done.  For very
+        //            long-lived TGTs using authTime here means renewing all
+        //            the time!
+        Date startTime = creds.getStartTime();
+        long now = System.currentTimeMillis();
+        // Start time can be null
+        if (startTime != null)
+            // past the mid between start and end
+            return now - startTime.getTime() > endTime.getTime() - now;
+        // will it expire in less than 2 hours?
+        return now <= endTime.getTime() - 1000*3600*2L;
     }
 
-    private Credentials renewCredentials(Credentials creds)
+    private Credentials possiblyRenewCreds(Credentials creds)
+        throws KrbException, IOException
     {
-        Credentials lcreds;
+        if (!creds.isRenewable())
+            return creds;
+
+        if (System.currentTimeMillis() > cred.getRenewTill().getTime())
+            return creds;
+
         try {
-            if (!creds.isRenewable())
-                throw new RefreshFailedException("This ticket" +
-                                " is not renewable");
-            if (creds.getRenewTill() == null) {
-                // Renewable ticket without renew-till. Illegal and ignored.
-                return creds;
-            }
-            if (System.currentTimeMillis() > cred.getRenewTill().getTime())
-                throw new RefreshFailedException("This ticket is past "
-                                             + "its last renewal time.");
-            lcreds = creds.renew();
+            creds = creds.renew();
             if (debug)
                 System.out.println("Renewed Kerberos Ticket");
         } catch (Exception e) {
-            lcreds = null;
             if (debug)
                 System.out.println("Ticket could not be renewed : "
                                 + e.getMessage());
         }
-        return lcreds;
+        return creds;
     }
 
     /**
@@ -1037,111 +1049,117 @@ public class Krb5LoginModule implements LoginModule {
      */
 
     public boolean commit() throws LoginException {
-
         /*
          * Let us add the Krb5 Creds to the Subject's
          * private credentials. The credentials are of type
          * KerberosKey or KerberosTicket
          */
         if (succeeded == false) {
+            cleanKerberosCred();
             return false;
-        } else {
+        }
 
-            if (isInitiator && (cred == null)) {
-                succeeded = false;
-                throw new LoginException("Null Client Credential");
-            }
+        if (isInitiator && (cred == null)) {
+            cleanKerberosCred();
+            succeeded = false;
+            throw new LoginException("Null Client Credential");
+        }
 
-            if (subject.isReadOnly()) {
-                cleanKerberosCred();
-                throw new LoginException("Subject is Readonly");
-            }
+        if (subject.isReadOnly()) {
+            cleanKerberosCred();
+            succeeded = false;
+            throw new LoginException("Subject is Readonly");
+        }
 
-            /*
-             * Add the Principal (authenticated identity)
-             * to the Subject's principal set and
-             * add the credentials (TGT or Service key) to the
-             * Subject's private credentials
-             */
+        try {
+            setupSubject(subject, unboundServer ? null : principal, ktab,
+                    storeKey && encKeys != null ? encKeys : null);
+            if (debug)
+                System.out.println("Added Kerberos credentials to subject");
+            return true;
+        } catch (Exception e) {
+            cleanKerberosCred();
+            succeeded = false;
+            throw new LoginException(e.getMessage());
+        }
+    }
 
-            Set<Object> privCredSet =  subject.getPrivateCredentials();
-            Set<java.security.Principal> princSet  = subject.getPrincipals();
-            kerbClientPrinc = new KerberosPrincipal(principal.getName());
+    /**
+     * Store the given Kerberos crendentials in the given subject.
+     *
+     * @param subject the {@code Subject} to store the credentials into
+     *
+     * @param principal the {@code PrincipalName} for the credentials; use null to refer to all principals in the keytab
+     *
+     * @param ktab a {@code KeyTab} keytab to use for acting as a service (may be null)
+     *
+     * @param kerbTicket the TGT for the principal (if acting as a client)
+     *
+     * @param encKeys long-term secret keys for the principal (if acting as a server with the keys derived from a password)
+     *
+     */
+    private static void setupSubject(Subject subject, PrincipalName principal,
+            KeyTab ktab, KerberosTicket kerbTicket, EncryptionKey[] encKeys)
+        throws LoginException {
 
-            // create Kerberos Ticket
-            if (isInitiator) {
-                kerbTicket = Krb5Util.credsToTicket(cred);
-                if (cred.getProxy() != null) {
-                    KerberosSecrets.getJavaxSecurityAuthKerberosAccess()
-                            .kerberosTicketSetProxy(kerbTicket,Krb5Util.credsToTicket(cred.getProxy()));
-                }
-            }
+        KerberosTicket kerbTicket = null;
 
-            if (storeKey && encKeys != null) {
-                if (encKeys.length == 0) {
-                    succeeded = false;
-                    throw new LoginException("Null Server Key ");
-                }
+        // create Kerberos Ticket
+        if (isInitiator) {
+          kerbTicket = Krb5Util.credsToTicket(cred);
+          if (cred.getProxy() != null) {
+            KerberosSecrets.getJavaxSecurityAuthKerberosAccess()
+              .kerberosTicketSetProxy(kerbTicket,Krb5Util.credsToTicket(cred.getProxy()));
+          }
+        }
+        /*
+         * Add the Principal (authenticated identity)
+         * to the Subject's principal set and
+         * add the credentials (TGT or Service key) to the
+         * Subject's private credentials
+         */
 
-                kerbKeys = new KerberosKey[encKeys.length];
-                for (int i = 0; i < encKeys.length; i ++) {
-                    Integer temp = encKeys[i].getKeyVersionNumber();
-                    kerbKeys[i] = new KerberosKey(kerbClientPrinc,
-                                          encKeys[i].getBytes(),
-                                          encKeys[i].getEType(),
-                                          (temp == null?
-                                          0: temp.intValue()));
-                }
+        if (kerbTicket == null && encKeys == null && ktab == null)
+            throw new LoginException("No Kerberos credentials provided to " +
+                    "store in subject");
 
-            }
-            // Let us add the kerbClientPrinc,kerbTicket and KeyTab/KerbKey (if
-            // storeKey is true)
+        Set<Object> privCredSet = subject.getPrivateCredentials();
+        Set<Principal> princSet = subject.getPrincipals();
 
-            // We won't add "*" as a KerberosPrincipal
-            if (!unboundServer &&
-                    !princSet.contains(kerbClientPrinc)) {
-                princSet.add(kerbClientPrinc);
-            }
+        KerberosPrincipal princ = null;
+        if (principal != null) {
+            princ = new KerberosPrincipal(principal.getName());
+            if (!princSet.contains(princ))
+                princSet.add(princ);
+        }
 
-            // add the TGT
-            if (kerbTicket != null) {
-                if (!privCredSet.contains(kerbTicket))
-                    privCredSet.add(kerbTicket);
-            }
+        if (kerbTicket != null && !privCredSet.contains(kerbTicket))
+            privCredSet.add(kerbTicket);
 
-            if (storeKey) {
-                if (encKeys == null) {
-                    if (ktab != null) {
-                        if (!privCredSet.contains(ktab)) {
-                            privCredSet.add(ktab);
-                        }
-                    } else {
-                        succeeded = false;
-                        throw new LoginException("No key to store");
-                    }
-                } else {
-                    for (int i = 0; i < kerbKeys.length; i ++) {
-                        if (!privCredSet.contains(kerbKeys[i])) {
-                            privCredSet.add(kerbKeys[i]);
-                        }
-                        encKeys[i].destroy();
-                        encKeys[i] = null;
-                        if (debug) {
-                            System.out.println("Added server's key"
-                                            + kerbKeys[i]);
-                            System.out.println("\t\t[Krb5LoginModule] " +
-                                           "added Krb5Principal  " +
-                                           kerbClientPrinc.toString()
-                                           + " to Subject");
-                        }
-                    }
-                }
-            }
+        if (ktab != null && !privCredSet.contains(ktab))
+            privCredSet.add(ktab);
+
+        if (encKeys == null)
+            return;
+
+        if (encKeys.length == 0)
+            throw new LoginException("Cannot store empty long-term " +
+                    "keyset in Subject");
+
+        if (princ == null)
+            throw new LoginException("Cannot store Kerberos long-term keys " +
+                    "for wild-card principal in Subject");
+
+        for (int i = 0; i < encKeys.length; i ++) {
+            Integer temp = encKeys[i].getKeyVersionNumber();
+            KerberosKey kerbKey = new KerberosKey(princ,
+                    encKeys[i].getBytes(),
+                    encKeys[i].getEType(),
+                    (temp == null?
+                     0: temp.intValue()));
+            if (!privCredSet.contains(kerbKey))
+                privCredSet.add(kerbKey);
         }
-        commitSucceeded = true;
-        if (debug)
-            System.out.println("Commit Succeeded \n");
-        return true;
     }
 
     /**
@@ -1199,8 +1217,13 @@ public class Krb5LoginModule implements LoginModule {
             throw new LoginException("Subject is Readonly");
         }
 
-        subject.getPrincipals().remove(kerbClientPrinc);
-           // Let us remove all Kerberos credentials stored in the Subject
+        Iterator<Principal> itp = subject.getPrincipals().iterator();
+        while (itp.hasNext()) {
+            Object o = itp.next();
+            if (o instanceof KerberosPrincipal)
+                itp.remove();
+        }
+
         Iterator<Object> it = subject.getPrivateCredentials().iterator();
         while (it.hasNext()) {
             Object o = it.next();
@@ -1239,9 +1262,12 @@ public class Krb5LoginModule implements LoginModule {
             throw new LoginException
                 ("Destroy Failed on Kerberos Private Credentials");
         }
+        for (int i = 0; i < kerbKeys.length; i++) {
+            encKeys[i].destroy();
+            encKeys[i] = null;
+        }
         kerbTicket = null;
         kerbKeys = null;
-        kerbClientPrinc = null;
     }
 
     /**

commit 563401d8dec019521bb20dd5352414f5e7cd0f08
Author: Nico Williams <nico@twosigma.com>
Date:   Fri Dec 4 23:27:22 2015 +0000

    Make GSSName implement Principal (add getName())

diff --git a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java
index f0bd258b55..d0013762ca 100644
--- a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java
+++ b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java
@@ -24,6 +24,7 @@
  */
 
 package org.ietf.jgss;
+import java.security.Principal;
 
 /**
  * This interface encapsulates a single GSS-API principal entity. The
@@ -102,7 +103,7 @@ package org.ietf.jgss;
  * @author Mayank Upadhyay
  * @since 1.4
  */
-public interface GSSName {
+public interface GSSName extends Principal {
 
     /**
      * Oid indicating a host-based service name form.  It is used to
@@ -281,6 +282,26 @@ public interface GSSName {
      */
     public String toString();
 
+    /**
+     * Returns a textual representation of the <code>GSSName</code> object.
+     *
+     * If <code>this</code> is not an MN then the returned name should be the
+     * same as the generic name used to construct it.  Otherwise the returned
+     * name may be a mechanism-specific name string.
+     *
+     * @return a String representing this name in printable form.
+     */
+    public String getName();
+
+    /**
+     * Returns a textual representation of the <code>GSSName</code> object
+     * element corresponding to the given <code>mech</code>.  This will be a
+     * mechanism-specific representation of <code>this</code.
+     *
+     * @return a String representing this name in printable form.
+     */
+    public String getName(Oid mech) throws GSSException;
+
     /**
      * Returns the name type of the printable
      * representation of this name that can be obtained from the <code>
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
index 97badb1e71..01f3981626 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
@@ -450,6 +450,20 @@ public class GSSNameImpl implements GSSName {
         return printableName;
     }
 
+    public String getName() {
+        return printableName;
+    }
+
+    public String getName(Oid mech) throws GSSException {
+        GSSNameSpi element = elements.get(mech);
+        if (element == null) {
+            throw new GSSExceptionImpl(GSSException.UNAVAILABLE,
+                    "GSSName object does not have an element for the " +
+                    "given mechanism");
+        }
+        return element.toString();
+    }
+
     public String getLocalName() throws GSSException {
         String lname = null;
         Oid mech = null;
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
index 4b5e57ed1c..4c1df31e9d 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
@@ -124,24 +124,8 @@ public class GSSUtil {
 
         Set<GSSCredentialSpi> gssCredentials = null;
 
-        Set<KerberosPrincipal> krb5Principals =
-                                new HashSet<KerberosPrincipal>();
-
-        if (name instanceof GSSNameImpl) {
-            try {
-                GSSNameSpi ne = ((GSSNameImpl) name).getElement
-                    (GSS_KRB5_MECH_OID);
-                String krbName = ne.toString();
-                if (ne instanceof Krb5NameElement) {
-                    krbName =
-                        ((Krb5NameElement) ne).getKrb5PrincipalName().getName();
-                }
-                KerberosPrincipal krbPrinc = new KerberosPrincipal(krbName);
-                krb5Principals.add(krbPrinc);
-            } catch (GSSException ge) {
-                debug("Skipped name " + name + " due to " + ge);
-            }
-        }
+        Set<GSSName> names = new HashSet<GSSName>();
+        names.add(name);
 
         if (creds instanceof GSSCredentialImpl) {
             gssCredentials = ((GSSCredentialImpl) creds).getElements();
@@ -151,12 +135,11 @@ public class GSSUtil {
             privCredentials = new HashSet<Object>(); // empty Set
         }
         debug("Created Subject with the following");
-        debug("principals=" + krb5Principals);
+        debug("principals=" + names);
         debug("public creds=" + pubCredentials);
         debug("private creds=" + privCredentials);
 
-        return new Subject(false, krb5Principals, pubCredentials,
-                           privCredentials);
+        return new Subject(false, names, pubCredentials, privCredentials);
 
     }
 

commit 56203b3eeb85c60e5f3535ae5f477f3157864b6d
Author: Nico Williams <nico@twosigma.com>
Date:   Fri Dec 4 23:19:50 2015 +0000

    JGSS: Prefer default cred handles if possible

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
index 936883c9c6..4b5e57ed1c 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSUtil.java
@@ -321,30 +321,44 @@ public class GSSUtil {
                     public Vector<T> run() throws Exception {
                         Subject accSubj = Subject.getSubject(acc);
                         Vector<T> result = null;
-                        if (accSubj != null) {
-                            result = new Vector<T>();
-                            Iterator<GSSCredentialImpl> iterator =
-                                accSubj.getPrivateCredentials
-                                (GSSCredentialImpl.class).iterator();
-                            while (iterator.hasNext()) {
-                                GSSCredentialImpl cred = iterator.next();
-                                debug("...Found cred" + cred);
-                                try {
-                                    GSSCredentialSpi ce =
-                                        cred.getElement(mech, initiate);
-                                    debug("......Found element: " + ce);
-                                    if (ce.getClass().equals(credCls) &&
-                                        (name == null ||
-                                         name.equals((Object) ce.getName()))) {
+                        if (accSubj == null) {
+                            debug("No Subject");
+                            return result;
+                        }
+
+                        result = new Vector<T>();
+                        Iterator<GSSCredentialImpl> iterator =
+                            accSubj.getPrivateCredentials
+                            (GSSCredentialImpl.class).iterator();
+                        while (iterator.hasNext()) {
+                            GSSCredentialImpl cred = iterator.next();
+                            debug("...Found cred" + cred);
+                            try {
+                                GSSCredentialSpi ce =
+                                    cred.getElement(mech, initiate);
+                                debug("......Found element: " + ce);
+                                if (!ce.getClass().equals(credCls)) {
+                                    debug("......Discard element (class mismatch)");
+                                } else if (name == null) {
+                                    /*
+                                     * If the caller doesn't care about
+                                     * the specific name, then prefer
+                                     * default credentials to
+                                     * non-default credentials.
+                                     */
+                                    if (ce.isDefaultCredential())
+                                        result.add(0, credCls.cast(ce));
+                                    else
                                         result.add(credCls.cast(ce));
-                                    } else {
-                                        debug("......Discard element");
-                                    }
-                                } catch (GSSException ge) {
-                                    debug("...Discard cred (" + ge + ")");
+                                } else if (name.equals((Object) ce.getName())) {
+                                    result.add(credCls.cast(ce));
+                                } else {
+                                    debug("......Discard element (name mismatch)");
                                 }
+                            } catch (GSSException ge) {
+                                debug("...Discard cred (exception: " + ge + ")");
                             }
-                        } else debug("No Subject");
+                        }
                         return result;
                     }
                 });

commit 5ce0cf02baf3cf284fa5f87d9f5062134b004ddc
Author: Nico Williams <nico@twosigma.com>
Date:   Fri Dec 4 23:14:17 2015 +0000

    Add isDefaultCredential() method to GSSCredentialSpi

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5AcceptCredential.java b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5AcceptCredential.java
index 262debcaf4..13e5b24f19 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5AcceptCredential.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5AcceptCredential.java
@@ -47,6 +47,7 @@ public class Krb5AcceptCredential
 
     private final Krb5NameElement name;
     private final ServiceCreds screds;
+    private boolean isDefCred = false;
 
     private Krb5AcceptCredential(Krb5NameElement name, ServiceCreds creds) {
         /*
@@ -57,6 +58,8 @@ public class Krb5AcceptCredential
 
         this.name = name;
         this.screds = creds;
+        if (name == null)
+            isDefCred = true;
     }
 
     static Krb5AcceptCredential getInstance(final GSSCaller caller, Krb5NameElement name)
@@ -148,6 +151,15 @@ public class Krb5AcceptCredential
         return Krb5MechFactory.GSS_KRB5_MECH_OID;
     }
 
+    /**
+     * Returns true if the credential is a default credential.
+     *
+     * @return true if the credential is a default credential, else false.
+     */
+    public boolean isDefaultCredential() {
+        return isDefCred;
+    }
+
     public final java.security.Provider getProvider() {
         return Krb5MechFactory.PROVIDER;
     }
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5InitCredential.java b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5InitCredential.java
index 3a692a2033..b69f51dbbf 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5InitCredential.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5InitCredential.java
@@ -56,6 +56,7 @@ public class Krb5InitCredential
     private Krb5NameElement name;
     private Credentials krb5Credentials;
     public KerberosTicket proxyTicket;
+    private boolean isDefCred;
 
     private Krb5InitCredential(Krb5NameElement name,
                                byte[] asn1Encoding,
@@ -88,6 +89,8 @@ public class Krb5InitCredential
         KerberosSecrets.getJavaxSecurityAuthKerberosAccess()
                 .kerberosTicketSetServerAlias(this, serverAlias);
         this.name = name;
+        if (name == null)
+            isDefCred = true;
 
         try {
             // Cache this for later use by the sun.security.krb5 package.
@@ -149,7 +152,8 @@ public class Krb5InitCredential
                 .kerberosTicketSetServerAlias(this, serverAlias);
         this.name = name;
         // A delegated cred does not have all fields set. So do not try to
-        // creat new Credentials out of the delegatedCred.
+        // creat new Credentials out of the delegatedCred.  Also, a delegated
+        // credential is not a default credential.
         this.krb5Credentials = delegatedCred;
     }
 
@@ -311,6 +315,15 @@ public class Krb5InitCredential
         return Krb5MechFactory.GSS_KRB5_MECH_OID;
     }
 
+    /**
+     * Returns true if the credential is a default credential.
+     *
+     * @return true if the credential is a default credential, else false.
+     */
+    public boolean isDefaultCredential() {
+        return isDefCred;
+    }
+
     public final java.security.Provider getProvider() {
         return Krb5MechFactory.PROVIDER;
     }
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java
index d6bb727e4a..6a5a439008 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java
@@ -367,6 +367,10 @@ public class Krb5NameElement
         return (gssNameType.equals(GSSName.NT_ANONYMOUS));
     }
 
+    public boolean isDefaultCredentialName() {
+        return false;
+    }
+
     public Provider getProvider() {
         return Krb5MechFactory.PROVIDER;
     }
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5ProxyCredential.java b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5ProxyCredential.java
index 8fbe93a576..2d1d600cd2 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5ProxyCredential.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5ProxyCredential.java
@@ -91,6 +91,11 @@ public class Krb5ProxyCredential
         return false;
     }
 
+    @Override
+    public final boolean isDefaultCredential() {
+        return false;
+    }
+
     @Override
     public final Oid getMechanism() {
         return Krb5MechFactory.GSS_KRB5_MECH_OID;
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java b/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java
index 69646d7a96..c417c9999b 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSCredentialSpi.java
@@ -88,6 +88,13 @@ public interface GSSCredentialSpi {
      */
     public boolean isAcceptorCredential() throws GSSException;
 
+     /**
+      * Returns true if the credential is a default credential.
+      *
+      * @return true if the credential is a default credential, else false.
+      */
+     public boolean isDefaultCredential();
+
     /**
      * Returns the oid representing the underlying credential
      * mechanism oid.
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java b/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java
index bfb93f9371..ed4af83000 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java
@@ -129,4 +129,10 @@ public interface GSSNameSpi {
      * Indicates if this name object represents an Anonymous name.
      */
     public boolean isAnonymousName();
+
+    /**
+     * Indicates whether this name object refers to whatever name(s) the
+     * default credentials respond to.
+     */
+    public boolean isDefaultCredentialName();
 }
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoCredElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoCredElement.java
index c7cf947742..a832fcc307 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoCredElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoCredElement.java
@@ -91,4 +91,8 @@ public class SpNegoCredElement implements GSSCredentialSpi {
     public GSSCredentialSpi impersonate(GSSNameSpi name) throws GSSException {
         return cred.impersonate(name);
     }
+
+    public boolean isDefaultCredential() {
+        return cred.isDefaultCredential();
+    }
 }
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
index d457baf6e5..5d2b7e6486 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
@@ -42,6 +42,7 @@ public class GSSCredElement implements GSSCredentialSpi {
     long pCred; // Pointer to the gss_cred_id_t structure
     private GSSNameElement name = null;
     private GSSLibStub cStub;
+    public boolean isDefCred;
 
     // Perform the necessary ServicePermission check on this cred
     void doServicePermCheck() throws GSSException {
@@ -79,10 +80,13 @@ public class GSSCredElement implements GSSCredentialSpi {
             doServicePermCheck();
             pCred = cStub.acquireCred(this.name.pName, password, lifetime,
                     usage);
+            if (name == GSSNameElement.DEF_ACCEPTOR)
+                isDefCred = true;
         } else {
             pCred = cStub.acquireCred(0, password, lifetime, usage);
             this.name = new GSSNameElement(cStub.getCredName(pCred), cStub.getMech(), cStub);
             doServicePermCheck();
+            isDefCred = true;
         }
     }
 
@@ -131,6 +135,10 @@ public class GSSCredElement implements GSSCredentialSpi {
         return cStub.getMech();
     }
 
+    public boolean isDefaultCredential() {
+        return isDefCred;
+    }
+
     public String toString() {
         // No hex bytes available for native impl
         return "N/A";
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
index 9952ee12d1..d066de5e96 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
@@ -294,6 +294,10 @@ public class GSSNameElement implements GSSNameSpi {
         return (GSSName.NT_ANONYMOUS.equals(printableType));
     }
 
+    public boolean isDefaultCredentialName() {
+        return (this == DEF_ACCEPTOR);
+    }
+
     public void dispose() {
         if (pName != 0) {
             cStub.releaseName(pName);

commit 4ae2fc4aeb72c565f159857861602dd2a5a530d9
Author: Nico Williams <nico@twosigma.com>
Date:   Fri Dec 4 23:01:02 2015 +0000

    ServicePermission empty realm support
    
    Also use empty realm as wildcard for krbtgt names

diff --git a/src/java.security.jgss/share/classes/javax/security/auth/kerberos/ServicePermission.java b/src/java.security.jgss/share/classes/javax/security/auth/kerberos/ServicePermission.java
index 19629b06a8..49f4f01374 100644
--- a/src/java.security.jgss/share/classes/javax/security/auth/kerberos/ServicePermission.java
+++ b/src/java.security.jgss/share/classes/javax/security/auth/kerberos/ServicePermission.java
@@ -214,10 +214,57 @@ public final class ServicePermission extends Permission
 
 
     boolean impliesIgnoreMask(ServicePermission p) {
-        return ((this.getName().equals("*")) ||
-                this.getName().equals(p.getName()) ||
-                (p.getName().startsWith("@") &&
-                        this.getName().endsWith(p.getName())));
+        String pName = p.getName();
+
+        if ((this.getName().equals("*")) ||
+	     this.getName().equals(p.getName()) ||
+	     (pName.startsWith("@") &&
+	             this.getName().endsWith(pName)))
+            return true;
+
+        /*
+         * Empty realm in this or p is a wild-card.  This is needed to support
+         * non-Kerberos ServicePermissions for GSS (a band-aid until we can
+         * implement a proper GssAcceptorPermission class), but also because
+         * users may not know and might not care what realm the service is in,
+         * especially when they are using a keytab.
+         *
+         * If the user is using a password, then the realm matters more.  An
+         * untrusted actor could cause KDCs for a realm they control to see
+         * material they could attack offline, but that was already the case
+         * anyways, and the answer is the same in all cases: use stronger
+         * passwords, use randomized keys in a keytab, or let us implement
+         * SPAKE or similar alternatives to the venerable PA-ENC-TIMESTAMP.
+         */
+        if ((this.getName().equals("krbtgt/@") &&
+             pName.startsWith("krbtgt/")) ||
+            (pName.equals("krbtgt/@") &&
+             this.getName().startsWith("krbtgt/")))
+            return true;
+
+        String s = this.getName();
+        int n = s.length();
+        int i;
+        for (i = 0; i < n; i++) {
+            if (s.charAt(i) == '\\') {
+                i++;
+                continue;
+            }
+            if (s.charAt(i) == '@') {
+                /*
+                 * This is the same as:
+                 *
+                 *  String s = s.substring(0, i);
+                 *  return (p.getName().startsWith(s) &&
+                 *      (p.getName().equals(s) || this.getName().equals(s)));
+                 */
+                return (pName.regionMatches(0, s, 0, i + 1) &&
+                    (pName.length() == i + 1 || s.length() == i + 1));
+            }
+        }
+
+        // No realm, not even empty -> fail
+        return false;
     }
 
     /**

commit a6fe1503ccf7c2cc5927507f81752e81f7a21ba9
Author: Nico Williams <nico@twosigma.com>
Date:   Wed Aug 15 15:21:26 2018 -0500

    JGSS: Add comment about unnec. perm check

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
index f241f7cc6c..32205c96d3 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
@@ -258,7 +258,9 @@ class NativeGSSContext implements GSSContextSpi {
         }
 
         // Do Service Permission check when importing SPNEGO context
-        // just to be safe
+        // just to be safe.  WAT, no.  If the caller has an exported sec
+        // context token, it's because someone gave it to it, therefore there's
+        // no need to do any further permission checking.  REMOVE!
         Oid mech = cStub.getMech();
         if (GSSUtil.isSpNegoMech(mech) || GSSUtil.isKerberosMech(mech)) {
             doServicePermCheck();

commit 210a04007885c26c0d4303d2181bae215377ec24
Author: Nico Williams <nico@twosigma.com>
Date:   Thu Aug 16 11:53:09 2018 -0500

    Fix SpNego multi-round-trip bug
    
    There is only one token that we can extract an actual mechanism OID from
    in the SPNEGO case when the native GSS library doesn't provide that
    (though it should) in the API.  If the SPNEGO exchange ends up requiring
    more than two tokens, then the previous code failed to establish a
    security context.
    
    Also, never raise if we cannot get an actual mech OID from SPNEGO
    tokens.

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
index faef0b6779..f241f7cc6c 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
@@ -128,6 +128,8 @@ class NativeGSSContext implements GSSContextSpi {
                     Krb5Util.checkServicePermission(tgsName, action);
                 }
             }
+            if (targetName == null)
+                return;
             String targetStr = targetName.getKrbName();
             Krb5Util.checkServicePermission(targetStr, action);
             skipServicePermCheck = true;
@@ -138,6 +140,8 @@ class NativeGSSContext implements GSSContextSpi {
     private void doDelegPermCheck() throws GSSException {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
+            if (targetName == null)
+                return;
             String targetStr = targetName.getKrbName();
             String tgsStr = Krb5Util.getTGSName(targetName);
             StringBuilder sb = new StringBuilder("\"");
@@ -241,12 +245,17 @@ class NativeGSSContext implements GSSContextSpi {
         if (info.length != NUM_OF_INQUIRE_VALUES) {
             throw new RuntimeException("Bug w/ GSSLibStub.inquireContext()");
         }
-        srcName = new GSSNameElement(info[0], actualMech, cStub);
-        targetName = new GSSNameElement(info[1], actualMech, cStub);
         isInitiator = (info[2] != 0);
         isEstablished = (info[3] != 0);
         flags = (int) info[4];
         lifetime = (int) info[5];
+        if (isEstablished) {
+            srcName = new GSSNameElement(info[0], actualMech, cStub);
+            targetName = new GSSNameElement(info[1], actualMech, cStub);
+        } else {
+            srcName = null;
+            targetName = null;
+        }
 
         // Do Service Permission check when importing SPNEGO context
         // just to be safe
@@ -286,22 +295,38 @@ class NativeGSSContext implements GSSContextSpi {
 
             // Only inspect the token when the permission check
             // has not been performed
-            if (GSSUtil.isSpNegoMech(cStub.getMech()) && outToken != null) {
+            if (!GSSUtil.isSpNegoMech(cStub.getMech())) {
+                actualMech = cStub.getMech();
+            } else if (actualMech == null && outToken != null) {
                 // WORKAROUND for SEAM bug#6287358
-                actualMech = getMechFromSpNegoToken(outToken, true);
+                //
+                // This is where some C GSS SPNEGO implementations fail to make
+                // the real actual mechanism available.
+                // getMechFromSpNegoToken() does the horrible, no good, very
+                // bad thing its name says it does.  For now we retain this bit
+                // of evil.
+                try {
+                    actualMech = getMechFromSpNegoToken(outToken, true);
+                } catch (GSSException e) { }
+            }
 
-                if (GSSUtil.isKerberosMech(actualMech)) {
-                    if (!skipServicePermCheck) doServicePermCheck();
-                    if (!skipDelegPermCheck) doDelegPermCheck();
-                }
+            if (actualMech != null && GSSUtil.isKerberosMech(actualMech)) {
+                if (!skipServicePermCheck) doServicePermCheck();
+                if (!skipDelegPermCheck) doDelegPermCheck();
             }
 
             if (isEstablished) {
+                // XXX We should attempt to get actualMech from the cStub here,
+                // and take it even if we got a semblance of an actualMech from
+                // the SPNEGO token, as long as the one returned by the cStub
+                // isn't the SPNEGO OID.
                 if (srcName == null) {
                     srcName = new GSSNameElement
                         (cStub.getContextName(pContext, true), actualMech,
                          cStub);
                 }
+                // XXX Attempt to get the actual target name from the cStub.
+
                 if (cred == null) {
                     disposeCred = cred =
                         new GSSCredElement(srcName, lifetime,
@@ -325,7 +350,7 @@ class NativeGSSContext implements GSSContextSpi {
             SunNativeProvider.debug("acceptSecContext=> outToken len=" +
                                     (outToken == null? 0 : outToken.length));
 
-            if (targetName == null) {
+            if (isEstablished && targetName == null) {
                 targetName = new GSSNameElement
                     (cStub.getContextName(pContext, false), actualMech, cStub);
                 // Replace the current default acceptor cred now that
@@ -340,6 +365,9 @@ class NativeGSSContext implements GSSContextSpi {
 
             // Only inspect token when the permission check has not
             // been performed
+            //
+            // XXX No, we should inspect the token the one time we can, just
+            // like with actualMech on the initiator side.
             if (GSSUtil.isSpNegoMech(cStub.getMech()) &&
                 (outToken != null) && !skipServicePermCheck) {
                 if (GSSUtil.isKerberosMech(getMechFromSpNegoToken

commit 4087ebb64bfd8bcc1365277aff3d557c223cc5ee
Author: Nico Williams <nico@twosigma.com>
Date:   Wed Nov 11 04:58:38 2015 +0000

    Add createCredential() with password
    
    Also avoid memory allocation in newGSSOIDSet() renamed to makeGSSOIDset()
    which now takes a singleton set argument and either assigns the requested
    OID or with SPNEGO returns a static list of all the supported mechs. With
    this we no longer need deleteGSSOIDSet().

diff --git a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
index f9ae3efafe..ab3181302c 100644
--- a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
+++ b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
@@ -423,6 +423,58 @@ public abstract class GSSManager {
                                   int lifetime, Oid mech, int usage)
         throws GSSException;
 
+    /**
+     * Factory method for acquiring a single mechanism credential with a
+     * password.<p>
+     *
+     * GSS-API mechanism providers must impose a local access-control
+     * policy on callers to prevent unauthorized callers from acquiring
+     * credentials to which they are not entitled. The kinds of permissions
+     * needed by different mechanism providers will be documented on a
+     * per-mechanism basis. A failed permission check might cause a {@link
+     * java.lang.SecurityException SecurityException} to be thrown from
+     * this method. <p>
+     *
+     * Non-default values for lifetime cannot always be honored by the
+     * underlying mechanisms, thus applications should be prepared to call
+     * {@link GSSCredential#getRemainingLifetime() getRemainingLifetime}
+     * on the returned credential.<p>
+     *
+     * @param name the name of the principal for whom this credential is to be
+     * acquired.  Use <code>null</code> to specify the default principal.
+     * @param lifetime The number of seconds that credentials should remain
+     * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
+     * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
+     * have the maximum permitted lifetime.  Use {@link
+     * GSSCredential#DEFAULT_LIFETIME GSSCredential.DEFAULT_LIFETIME} to
+     * request default credential lifetime.
+     * @param mech the Oid of the desired mechanism.  Use <code>(Oid) null
+     * </code> to request the default mechanism.
+     * @param usage The intended usage for this credential object. The value
+     * of this parameter must be one of:
+     * {@link GSSCredential#INITIATE_AND_ACCEPT
+     * GSSCredential.INITIATE_AND_ACCEPT},
+     * {@link GSSCredential#ACCEPT_ONLY GSSCredential.ACCEPT_ONLY}, and
+     * {@link GSSCredential#INITIATE_ONLY GSSCredential.INITIATE_ONLY}.
+     * @return a GSSCredential of the requested type.
+     *
+     * @see GSSCredential
+     *
+     * @throws GSSException containing the following
+     * major error codes:
+     *    {@link GSSException#BAD_MECH GSSException.BAD_MECH},
+     *    {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
+     *    {@link GSSException#BAD_NAME GSSException.BAD_NAME},
+     *    {@link GSSException#CREDENTIALS_EXPIRED
+     *                                   GSSException.CREDENTIALS_EXPIRED},
+     *    {@link GSSException#NO_CRED GSSException.NO_CRED},
+     *    {@link GSSException#FAILURE GSSException.FAILURE}
+     */
+    public abstract GSSCredential createCredential (GSSName name,
+                                  String password, int lifetime, Oid mech,
+                                  int usage)
+        throws GSSException;
+
     /**
      * Factory method for acquiring credentials over a set of
      * mechanisms. This method attempts to acquire credentials for
@@ -480,6 +532,64 @@ public abstract class GSSManager {
                                       int lifetime, Oid mechs[], int usage)
         throws GSSException;
 
+    /**
+     * Factory method for acquiring credentials with a password over a set of
+     * mechanisms. This method attempts to acquire credentials for
+     * each of the mechanisms specified in the array called mechs.  To
+     * determine the list of mechanisms for which the acquisition of
+     * credentials succeeded, the caller should use the {@link
+     * GSSCredential#getMechs() GSSCredential.getMechs} method.<p>
+     *
+     * GSS-API mechanism providers must impose a local access-control
+     * policy on callers to prevent unauthorized callers from acquiring
+     * credentials to which they are not entitled. The kinds of permissions
+     * needed by different mechanism providers will be documented on a
+     * per-mechanism basis. A failed permission check might cause a {@link
+     * java.lang.SecurityException SecurityException} to be thrown from
+     * this method.<p>
+     *
+     * Non-default values for lifetime cannot always be honored by the
+     * underlying mechanisms, thus applications should be prepared to call
+     * {@link GSSCredential#getRemainingLifetime() getRemainingLifetime}
+     * on the returned credential.<p>
+     *
+     * @param name the name of the principal for whom this credential is to
+     * be acquired.  Use <code>null</code> to specify the default
+     * principal.
+     * @param lifetime The number of seconds that credentials should remain
+     * valid.  Use {@link GSSCredential#INDEFINITE_LIFETIME
+     * GSSCredential.INDEFINITE_LIFETIME} to request that the credentials
+     * have the maximum permitted lifetime.  Use {@link
+     * GSSCredential#DEFAULT_LIFETIME GSSCredential.DEFAULT_LIFETIME} to
+     * request default credential lifetime.
+     * @param mechs an array of Oid's indicating the mechanisms over which
+     * the credential is to be acquired.  Use <code>(Oid[]) null</code> for
+     * requesting a system specific default set of mechanisms.
+     * @param usage The intended usage for this credential object. The value
+     * of this parameter must be one of:
+     * {@link GSSCredential#INITIATE_AND_ACCEPT
+     * GSSCredential.INITIATE_AND_ACCEPT},
+     * {@link GSSCredential#ACCEPT_ONLY GSSCredential.ACCEPT_ONLY}, and
+     * {@link GSSCredential#INITIATE_ONLY GSSCredential.INITIATE_ONLY}.
+     * @return a GSSCredential of the requested type.
+     *
+     * @see GSSCredential
+     *
+     * @throws GSSException containing the following
+     * major error codes:
+     *    {@link GSSException#BAD_MECH GSSException.BAD_MECH},
+     *    {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
+     *    {@link GSSException#BAD_NAME GSSException.BAD_NAME},
+     *    {@link GSSException#CREDENTIALS_EXPIRED
+     *                                   GSSException.CREDENTIALS_EXPIRED},
+     *    {@link GSSException#NO_CRED GSSException.NO_CRED},
+     *    {@link GSSException#FAILURE GSSException.FAILURE}
+     */
+    public abstract GSSCredential createCredential(GSSName name,
+                                      String password, int lifetime,
+                                      Oid mechs[], int usage)
+        throws GSSException;
+
     /**
      * Factory method for creating a context on the initiator's
      * side.
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java
index 6d0d711325..18eccb14b1 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java
@@ -66,17 +66,33 @@ public class GSSCredentialImpl implements GSSCredential {
     }
 
     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
-                             int lifetime, Oid mech, int usage)
+                      int lifetime, Oid mech, int usage)
         throws GSSException {
         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 
         init(gssManager);
-        add(name, lifetime, lifetime, mech, usage);
+        String password = null;
+        add(name, password, lifetime, lifetime, mech, usage);
+    }
+
+    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name, String password,
+                      int lifetime, Oid mech, int usage)
+        throws GSSException {
+        if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
+
+        init(gssManager);
+        add(name, password, lifetime, lifetime, mech, usage);
     }
 
     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
                       int lifetime, Oid[] mechs, int usage)
         throws GSSException {
+        this(gssManager, name, (String)null, lifetime, mechs, usage);
+    }
+
+    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
+                      String password, int lifetime, Oid mechs[], int usage)
+        throws GSSException {
         init(gssManager);
         boolean defaultList = false;
         if (mechs == null) {
@@ -86,7 +102,7 @@ public class GSSCredentialImpl implements GSSCredential {
 
         for (int i = 0; i < mechs.length; i++) {
             try {
-                add(name, lifetime, lifetime, mechs[i], usage);
+                add(name, password, lifetime, lifetime, mechs[i], usage);
             } catch (GSSException e) {
                 if (defaultList) {
                     // Try the next mechanism
@@ -417,6 +433,13 @@ public class GSSCredentialImpl implements GSSCredential {
 
     public void add(GSSName name, int initLifetime, int acceptLifetime,
                     Oid mech, int usage) throws GSSException {
+        String password = null;
+        add(name, password, initLifetime, acceptLifetime, mech, usage);
+    }
+
+    public void add(GSSName name, String password, int initLifetime,
+                    int acceptLifetime, Oid mech, int usage)
+                    throws GSSException {
 
         if (destroyed) {
             throw new IllegalStateException("This credential is " +
@@ -437,6 +460,7 @@ public class GSSCredentialImpl implements GSSCredential {
                                   ((GSSNameImpl)name).getElement(mech));
 
         tempCred = gssManager.getCredentialElement(nameElement,
+                                                   password,
                                                    initLifetime,
                                                    acceptLifetime,
                                                    mech,
@@ -474,11 +498,20 @@ public class GSSCredentialImpl implements GSSCredential {
                 key = new SearchKey(mech, currentUsage);
                 hashtable.put(key, tempCred);
 
-                tempCred = gssManager.getCredentialElement(nameElement,
-                                                        initLifetime,
-                                                        acceptLifetime,
-                                                        mech,
-                                                        desiredUsage);
+                if (password == null) {
+                    tempCred = gssManager.getCredentialElement(nameElement,
+                                                               initLifetime,
+                                                               acceptLifetime,
+                                                               mech,
+                                                               desiredUsage);
+                } else {
+                    tempCred = gssManager.getCredentialElement(nameElement,
+                                                               password,
+                                                               initLifetime,
+                                                               acceptLifetime,
+                                                               mech,
+                                                               desiredUsage);
+                }
 
                 key = new SearchKey(mech, desiredUsage);
                 hashtable.put(key, tempCred);
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java
index e804a831e5..8298be9926 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSManagerImpl.java
@@ -135,12 +135,26 @@ public class GSSManagerImpl extends GSSManager {
         return wrap(new GSSCredentialImpl(this, aName, lifetime, mech, usage));
     }
 
+    public GSSCredential createCredential(GSSName aName, String password,
+                                          int lifetime, Oid mech, int usage)
+        throws GSSException {
+        return new GSSCredentialImpl(this, aName, password,
+                lifetime, mech, usage);
+    }
+
     public GSSCredential createCredential(GSSName aName,
                                           int lifetime, Oid[] mechs, int usage)
         throws GSSException {
         return wrap(new GSSCredentialImpl(this, aName, lifetime, mechs, usage));
     }
 
+    public GSSCredential createCredential(GSSName aName, String password,
+                                          int lifetime, Oid mechs[], int usage)
+        throws GSSException {
+        return new GSSCredentialImpl(this, aName, password,
+                lifetime, mechs, usage);
+    }
+
     public GSSContext createContext(GSSName peer, Oid mech,
                                     GSSCredential myCred, int lifetime)
         throws GSSException {
@@ -175,6 +189,17 @@ public class GSSManagerImpl extends GSSManager {
                                             acceptLifetime, usage);
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 String password,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 Oid mech, int usage)
+        throws GSSException {
+        MechanismFactory factory = list.getMechFactory(mech);
+        return factory.getCredentialElement(name, password, initLifetime,
+                                            acceptLifetime, usage);
+    }
+
     // Used by java SPNEGO impl
     public GSSNameSpi getNameElement(String name, Oid nameType, Oid mech)
         throws GSSException {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java
index d5cafea044..ab06ff6c81 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5MechFactory.java
@@ -108,9 +108,17 @@ public final class Krb5MechFactory implements MechanismFactory {
     }
 
     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
-           int initLifetime, int acceptLifetime,
+           String password, int initLifetime, int acceptLifetime,
            int usage) throws GSSException {
 
+        if (password != null) {
+            // XXX Implement!  Shouldn't be too hard...
+            throw new GSSException(GSSException.UNAVAILABLE, -1,
+                    "The Kerberos mechanism Java implementation does not " +
+                    "currently support acquiring GSS credentials handle " +
+                    "elements with a password");
+        }
+
         if (name != null && !(name instanceof Krb5NameElement)) {
             name = Krb5NameElement.getInstance(name.toString(),
                                        name.getStringNameType());
@@ -141,6 +149,12 @@ public final class Krb5MechFactory implements MechanismFactory {
         return credElement;
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+            int initLifetime, int acceptLifetime, int usage)
+        throws GSSException {
+        return getCredentialElement(name, null, initLifetime, acceptLifetime, usage);
+    }
+
     public static void checkInitCredPermission(Krb5NameElement name) {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
@@ -153,7 +167,7 @@ public final class Krb5MechFactory implements MechanismFactory {
                 sm.checkPermission(perm);
             } catch (SecurityException e) {
                 if (DEBUG) {
-                    System.out.println("Permission to initiate" +
+                    System.out.println("Permission to initiate " +
                         "kerberos init credential" + e.getMessage());
                 }
                 throw e;
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java
index e5bba5f293..51ce06614a 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java
@@ -118,6 +118,54 @@ public interface MechanismFactory {
     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
       int initLifetime, int acceptLifetime, int usage) throws GSSException;
 
+    /**
+     * Creates a credential element using a password for this mechanism to be
+     * included as part of a GSSCredential implementation. A GSSCredential is
+     * conceptually a container class of several credential elements from
+     * different mechanisms. A GSS-API credential can be used either for
+     * initiating GSS security contexts or for accepting them. This method
+     * also accepts parameters that indicate what usage is expected and how
+     * long the life of the credential should be. It is not necessary that
+     * the mechanism honor the request for lifetime. An application will
+     * always query an acquired GSSCredential to determine what lifetime it
+     * got back.<p>
+     *
+     * <b>Not all mechanisms support the concept of one credential element
+     * that can be used for both initiating and accepting a context. In the
+     * event that an application requests usage INITIATE_AND_ACCEPT for a
+     * credential from such a mechanism, the GSS framework will need to
+     * obtain two different credential elements from the mechanism, one
+     * that will have usage INITIATE_ONLY and another that will have usage
+     * ACCEPT_ONLY. The mechanism will help the GSS-API realize this by
+     * returning a credential element with usage INITIATE_ONLY or
+     * ACCEPT_ONLY prompting it to make another call to
+     * getCredentialElement, this time with the other usage mode. The
+     * mechanism indicates the missing mode by returning a 0 lifetime for
+     * it.</b>
+     *
+     * @param name the mechanism level name element for the entity whose
+     * credential is desired. A null value indicates that a mechanism
+     * dependent default choice is to be made.
+     * @param initLifetime indicates the lifetime (in seconds) that is
+     * requested for this credential to be used at the context initiator's
+     * end. This value should be ignored if the usage is
+     * ACCEPT_ONLY. Predefined contants are available in the
+     * org.ietf.jgss.GSSCredential interface.
+     * @param acceptLifetime indicates the lifetime (in seconds) that is
+     * requested for this credential to be used at the context acceptor's
+     * end. This value should be ignored if the usage is
+     * INITIATE_ONLY. Predefined contants are available in the
+     * org.ietf.jgss.GSSCredential interface.
+     * @param usage One of the values GSSCredential.INIATE_ONLY,
+     * GSSCredential.ACCEPT_ONLY, and GSSCredential.INITIATE_AND_ACCEPT.
+     * @see org.ietf.jgss.GSSCredential
+     * @throws GSSException if one of the error situations described in RFC
+     * 2743 with the GSS_Acquire_Cred or GSS_Add_Cred calls occurs.
+     */
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+      String password, int initLifetime, int acceptLifetime, int usage)
+        throws GSSException;
+
     /**
      * Creates a name element for this mechanism to be included as part of
      * a GSSName implementation. A GSSName is conceptually a container
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
index 511547b8a7..5ae19bed34 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/SpNegoMechFactory.java
@@ -149,6 +149,22 @@ public final class SpNegoMechFactory implements MechanismFactory {
         return credElement;
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+           String password, int initLifetime, int acceptLifetime,
+           int usage) throws GSSException {
+
+        SpNegoCredElement credElement = getCredFromSubject
+            (name, (usage != GSSCredential.ACCEPT_ONLY));
+
+        if (credElement == null) {
+            // get CredElement for the default Mechanism
+            credElement = new SpNegoCredElement
+                (manager.getCredentialElement(name, password, initLifetime,
+                acceptLifetime, null, usage));
+        }
+        return credElement;
+    }
+
     public GSSContextSpi getMechanismContext(GSSNameSpi peer,
                              GSSCredentialSpi myInitiatorCred, int lifetime)
         throws GSSException {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
index 6c9711e80b..d457baf6e5 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
@@ -69,22 +69,28 @@ public class GSSCredElement implements GSSCredentialSpi {
         name = srcName;
     }
 
-    GSSCredElement(GSSNameElement name, int lifetime, int usage,
-                   GSSLibStub stub) throws GSSException {
+    GSSCredElement(GSSNameElement name, String password, int lifetime,
+                   int usage, GSSLibStub stub) throws GSSException {
         cStub = stub;
         this.usage = usage;
 
         if (name != null) { // Could be GSSNameElement.DEF_ACCEPTOR
             this.name = name;
             doServicePermCheck();
-            pCred = cStub.acquireCred(this.name.pName, lifetime, usage);
+            pCred = cStub.acquireCred(this.name.pName, password, lifetime,
+                    usage);
         } else {
-            pCred = cStub.acquireCred(0, lifetime, usage);
+            pCred = cStub.acquireCred(0, password, lifetime, usage);
             this.name = new GSSNameElement(cStub.getCredName(pCred), cStub.getMech(), cStub);
             doServicePermCheck();
         }
     }
 
+    GSSCredElement(GSSNameElement name, int lifetime, int usage,
+                   GSSLibStub stub) throws GSSException {
+        this(name, (String)null, lifetime, usage, stub);
+    }
+
     public Provider getProvider() {
         return SunNativeProvider.INSTANCE;
     }
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
index cbdf7a3b59..d6089781b2 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
@@ -69,8 +69,8 @@ class GSSLibStub {
     native Object[] displayName(long pName) throws GSSException;
 
     // Credential related routines
-    native long acquireCred(long pName, int lifetime, int usage)
-                                        throws GSSException;
+    native long acquireCred(long pName, String password,
+                            int lifetime, int usage) throws GSSException;
     native long releaseCred(long pCred);
     native long getCredName(long pCred);
     native int getCredTime(long pCred);
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java
index 8901272798..66dd30660c 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSFactory.java
@@ -96,6 +96,7 @@ public final class NativeGSSFactory implements MechanismFactory {
     }
 
     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 String password,
                                                  int initLifetime,
                                                  int acceptLifetime,
                                                  int usage)
@@ -118,14 +119,26 @@ public final class NativeGSSFactory implements MechanismFactory {
         if (credElement == null) {
             // No cred in the Subject
             if (usage == GSSCredential.INITIATE_ONLY) {
-                credElement = new GSSCredElement(nname, initLifetime,
-                                                 usage, cStub);
+                if (password == null) {
+                    credElement = new GSSCredElement(nname, initLifetime,
+                                                     usage, cStub);
+                } else {
+                    credElement = new GSSCredElement(nname, password,
+                                                     initLifetime,
+                                                     usage, cStub);
+                }
             } else if (usage == GSSCredential.ACCEPT_ONLY) {
                 if (nname == null) {
                     nname = GSSNameElement.DEF_ACCEPTOR;
                 }
-                credElement = new GSSCredElement(nname, acceptLifetime,
-                                                 usage, cStub);
+                if (password == null) {
+                    credElement = new GSSCredElement(nname, acceptLifetime,
+                                                     usage, cStub);
+                } else {
+                    credElement = new GSSCredElement(nname, password,
+                                                     acceptLifetime,
+                                                     usage, cStub);
+                }
             } else {
                 throw new GSSException(GSSException.FAILURE, -1,
                                        "Unknown usage mode requested");
@@ -134,6 +147,15 @@ public final class NativeGSSFactory implements MechanismFactory {
         return credElement;
     }
 
+    public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
+                                                 int initLifetime,
+                                                 int acceptLifetime,
+                                                 int usage)
+        throws GSSException {
+        return getCredentialElement(name, null, initLifetime,
+                                    acceptLifetime, usage);
+    }
+
     public GSSContextSpi getMechanismContext(GSSNameSpi peer,
                                              GSSCredentialSpi myCred,
                                              int lifetime)
diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index d9185b81d7..45e6ef8644 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -296,7 +296,7 @@ JNIEXPORT jobjectArray JNICALL
 Java_sun_security_jgss_wrapper_GSSLibStub_inquireNamesForMech(JNIEnv *env,
                                                               jobject jobj)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_OID mech;
   gss_OID_set nameTypes;
   jobjectArray result;
@@ -310,7 +310,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_inquireNamesForMech(JNIEnv *env,
 
     /* release intermediate buffers before checking status */
     result = getJavaOIDArray(env, nameTypes);
-    deleteGSSOIDSet(nameTypes);
+    (*ftab->releaseOidSet)(&dummy, &nameTypes);
     if ((*env)->ExceptionCheck(env)) {
       return NULL;
     }
@@ -641,17 +641,19 @@ Java_sun_security_jgss_wrapper_GSSLibStub_displayName(JNIEnv *env,
 /*
  * Class:     sun_security_jgss_wrapper_GSSLibStub
  * Method:    acquireCred
- * Signature: (JII)J
+ * Signature: (JLjava/lang/String;II)J
  */
 JNIEXPORT jlong JNICALL
 Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
                                                       jobject jobj,
                                                       jlong pName,
+                                                      jstring jPassword,
                                                       jint reqTime,
                                                       jint usage)
 {
   OM_uint32 minor, major;
   gss_OID mech;
+  gss_OID_set_desc singleton;
   gss_OID_set mechs;
   gss_cred_usage_t credUsage;
   gss_name_t nameHdl;
@@ -661,7 +663,6 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
   TRACE0("[GSSLibStub_acquireCred]");
 
   mech = (gss_OID) jlong_to_ptr((*env)->GetLongField(env, jobj, FID_GSSLibStub_pMech));
-  mechs = newGSSOIDSet(mech);
   credUsage = (gss_cred_usage_t) usage;
   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 
@@ -669,11 +670,29 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
 
   /* gss_acquire_cred(...) => GSS_S_BAD_MECH, GSS_S_BAD_NAMETYPE,
      GSS_S_BAD_NAME, GSS_S_CREDENTIALS_EXPIRED, GSS_S_NO_CRED */
-  major =
-    (*ftab->acquireCred)(&minor, nameHdl, reqTime, mechs,
-                     credUsage, &credHdl, NULL, NULL);
-  /* release intermediate buffers */
-  deleteGSSOIDSet(mechs);
+  if (jPassword == NULL) {
+    mechs = makeGSSOIDSet(&singleton, mech);
+    major = (*ftab->acquireCred)(&minor, nameHdl, reqTime, mechs, credUsage,
+                                 &credHdl, NULL, NULL);
+  } else {
+    gss_buffer_desc password;
+
+    if (ftab->acquireCredWithPassword == NULL) {
+      const char *msg = "GSSLibStub_acquireCred with password not supported "
+          "by GSS provider";
+
+      TRACE0(msg);
+      checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, msg);
+      return ptr_to_jlong(NULL);
+    }
+
+    initGSSBufferString(env, jPassword, &password);
+    mechs = makeGSSOIDSet(&singleton, mech);
+    major = (*ftab->acquireCredWithPassword)(&minor, nameHdl, &password,
+                                             reqTime, mechs, credUsage,
+                                             &credHdl, NULL, NULL);
+    resetGSSBufferString(env, jPassword, &password);
+  }
 
   TRACE1("[GSSLibStub_acquireCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
 
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeFunc.c b/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
index 69b3b9cdfe..650520d173 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
@@ -36,6 +36,7 @@ static const char EXPORT_NAME[]                 = "gss_export_name";
 static const char DISPLAY_NAME[]                = "gss_display_name";
 static const char LOCAL_NAME[]                  = "gss_localname";
 static const char ACQUIRE_CRED[]                = "gss_acquire_cred";
+static const char ACQUIRE_CRED_WITH_PASSWORD[]  = "gss_acquire_cred_with_password";
 static const char RELEASE_CRED[]                = "gss_release_cred";
 static const char INQUIRE_CRED[]                = "gss_inquire_cred";
 static const char IMPORT_SEC_CONTEXT[]          = "gss_import_sec_context";
@@ -135,6 +136,13 @@ int loadNative(const char *libName) {
         goto out;
     }
 
+    /*
+     * This one may not be available for a given GSS library, as it's an
+     * extension, therefore we don't fail if it's missing.
+     */
+    ftab->acquireCredWithPassword = (ACQUIRE_CRED_WITH_PASSWORD_FN_PTR)
+                        GETFUNC(gssLib, ACQUIRE_CRED_WITH_PASSWORD);
+
     ftab->releaseCred = (RELEASE_CRED_FN_PTR)GETFUNC(gssLib, RELEASE_CRED);
     if (ftab->releaseCred == NULL) {
         failed = TRUE;
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeFunc.h b/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
index 3c9d857482..6326618f11 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
@@ -100,6 +100,17 @@ typedef OM_uint32 (*ACQUIRE_CRED_FN_PTR)
                                 gss_OID_set *actual_mechs,
                                 OM_uint32 *time_rec);
 
+typedef OM_uint32 (*ACQUIRE_CRED_WITH_PASSWORD_FN_PTR)
+                                (OM_uint32 *minor_status,
+                                gss_name_t desired_name,
+                                gss_buffer_t password,
+                                OM_uint32 time_req,
+                                gss_OID_set desired_mech,
+                                gss_cred_usage_t cred_usage,
+                                gss_cred_id_t *output_cred_handle,
+                                gss_OID_set *actual_mechs,
+                                OM_uint32 *time_rec);
+
 typedef OM_uint32 (*RELEASE_CRED_FN_PTR)
                                 (OM_uint32 *minor_status,
                                 gss_cred_id_t *cred_handle);
@@ -257,6 +268,7 @@ typedef struct GSS_FUNCTION_TABLE {
     DISPLAY_NAME_FN_PTR                 displayName;
     LOCAL_NAME_FN_PTR                   localName;
     ACQUIRE_CRED_FN_PTR                 acquireCred;
+    ACQUIRE_CRED_WITH_PASSWORD_FN_PTR   acquireCredWithPassword;
     RELEASE_CRED_FN_PTR                 releaseCred;
     INQUIRE_CRED_FN_PTR                 inquireCred;
     IMPORT_SEC_CONTEXT_FN_PTR           importSecContext;
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
index 0ca04a9b99..a9e2cf507b 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
@@ -799,37 +799,18 @@ jobject getJavaOID(JNIEnv *env, gss_OID cOid) {
   return result;
 }
 /*
- * Utility routine for creating a gss_OID_set structure
- * using the specified gss_OID.
- * NOTE: need to call deleteGSSOIDSet(...) afterwards
- * to release the created gss_OID_set structure.
+ * Utility routine for filling in a 1-element gss_OID_set structure using the
+ * specified gss_OID (storage owned by caller).  However, with SPNEGO we return
+ * a static set containing all the available mechanisms.
  */
-gss_OID_set newGSSOIDSet(gss_OID oid) {
-  gss_OID_set oidSet;
-  OM_uint32 minor; // don't care; just so it compiles
-
-  if (oid->length != 6 ||
-      memcmp(oid->elements, SPNEGO_BYTES, 6) != 0) {
-      (*ftab->createEmptyOidSet)(&minor, &oidSet);
-      (*ftab->addOidSetMember)(&minor, oid, &oidSet);
-      return oidSet;
-  } else {
-      // Use all mechs for SPNEGO in order to work with
-      // various native GSS impls
-      return (ftab->mechs);
-  }
-}
-/*
- * Utility routine for releasing a gss_OID_set structure.
- * NOTE: used in conjunction with newGSSOIDSet(...).
- */
-void deleteGSSOIDSet(gss_OID_set oidSet) {
-  OM_uint32 minor; /* don't care; just so it compiles */
-
-  if ((oidSet != ftab->mechs) &&
-      (oidSet != NULL) && (oidSet != GSS_C_NO_OID_SET)) {
-    (*ftab->releaseOidSet)(&minor, &oidSet);
-  }
+gss_OID_set makeGSSOIDSet(gss_OID_set mechs, gss_OID oid) {
+  if (oid->length != 6 || memcmp(oid->elements, SPNEGO_BYTES, 6) != 0) {
+      mechs->count = 1;
+      mechs->elements = oid;
+      return mechs;
+  }
+  /* Use all mechs for SPNEGO in order to work with various native GSS impls */
+  return (ftab->mechs);
 }
 /*
  * Utility routine for creating a org.ietf.jgss.Oid[]
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
index 7b35a9929e..07f03046f5 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
@@ -46,8 +46,7 @@ extern "C" {
 
   extern gss_OID newGSSOID(JNIEnv *, jobject);
   extern void deleteGSSOID(gss_OID);
-  extern gss_OID_set newGSSOIDSet(gss_OID);
-  extern void deleteGSSOIDSet(gss_OID_set);
+  extern gss_OID_set makeGSSOIDSet(gss_OID_set, gss_OID);
 
   extern jbyteArray getJavaBuffer(JNIEnv *, gss_buffer_t, jboolean);
   extern jstring getJavaString(JNIEnv *, gss_buffer_t);
diff --git a/src/java.security.jgss/share/native/libj2gss/gssapi.h b/src/java.security.jgss/share/native/libj2gss/gssapi.h
index 885bdf8b0a..857077e49b 100644
--- a/src/java.security.jgss/share/native/libj2gss/gssapi.h
+++ b/src/java.security.jgss/share/native/libj2gss/gssapi.h
@@ -699,6 +699,23 @@ GSS_DLLIMP OM_uint32 gss_canonicalize_name(
 #    pragma pack(pop)
 #endif
 
+/* Common extension (NOT in RFC2744) */
+OM_uint32
+gss_add_cred_with_password(
+        OM_uint32 *,            /* minor_status */
+        const gss_cred_id_t,    /* input_cred_handle */
+        const gss_name_t,       /* desired_name */
+        const gss_OID,          /* desired_mech */
+        const gss_buffer_t,     /* password */
+        gss_cred_usage_t,       /* cred_usage */
+        OM_uint32,              /* initiator_time_req */
+        OM_uint32,              /* acceptor_time_req */
+        gss_cred_id_t *,        /* output_cred_handle */
+        gss_OID_set *,          /* actual_mechs */
+        OM_uint32 *,            /* initiator_time_rec */
+        OM_uint32 *             /* acceptor_time_rec */
+);
+
 /* Common extension for aname2lname (NOT in RFC2744) */
 OM_uint32
 gss_localname(

commit 5b7c1bfad58ff6a6c09b93fe7a9928c4a9439290
Author: Nico Williams <nico@twosigma.com>
Date:   Tue Mar 1 03:52:00 2016 +0000

    Add getLocalName() GSSName method

diff --git a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java
index d55bd6abb4..f0bd258b55 100644
--- a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java
+++ b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSName.java
@@ -261,6 +261,16 @@ public interface GSSName {
      */
     public byte[] export() throws GSSException;
 
+    /**
+     * Returns a local username form of a mechanism name, if available.
+     */
+    public String getLocalName() throws GSSException;
+
+    /**
+     * Returns a local username form of a mechanism name, if available.
+     */
+    public String getLocalName(Oid mech) throws GSSException;
+
     /**
      * Returns a textual representation of the <code>GSSName</code> object.  To retrieve
      * the printed name format, which determines the syntax of the returned
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
index e1e89059c5..97badb1e71 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
@@ -447,8 +447,43 @@ public class GSSNameImpl implements GSSName {
     }
 
     public String toString() {
-         return printableName;
+        return printableName;
+    }
 
+    public String getLocalName() throws GSSException {
+        String lname = null;
+        Oid mech = null;
+        Oid mech2 = null;
+
+        for (GSSNameSpi v : elements.values()) {
+            String mname = v.getLocalName();
+            if (mname == null)
+                continue;
+            if (lname == null) {
+                mech = v.getMechanism();
+                lname = mname;
+                continue;
+            }
+            if (!lname.equals(mname)) {
+                mech2 = v.getMechanism();
+                break;
+            }
+        }
+        if (mech2 == null)
+            return lname;
+        throw new GSSExceptionImpl(GSSException.UNAVAILABLE,
+                "Localname conflict between mechanisms " +
+                mech + " and " + mech2);
+    }
+
+    public String getLocalName(Oid mech) throws GSSException {
+        GSSNameSpi element = elements.get(mech);
+        if (element == null) {
+            throw new GSSExceptionImpl(GSSException.UNAVAILABLE,
+                    "GSSName object does not have an element for the " +
+                    "given mechanism");
+        }
+        return element.getLocalName();
     }
 
     public Oid getStringNameType() throws GSSException {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java
index 461e2481e5..d6bb727e4a 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java
@@ -316,6 +316,32 @@ public class Krb5NameElement
         // For testing: return (super.toString());
     }
 
+    /**
+     * Returns a local username (platform-specific) corresponding to the
+     * principal name, and may return null when no username is known for the
+     * principal name.
+     *
+     * @return username corresponding to this principal name, if any
+     */
+    public String getLocalName() throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "Mapping Kerberos principal names to usernames is not " +
+                "currently supported");
+    }
+
+    /**
+     * Returns a local username (platform-specific) corresponding to the
+     * principal name, and may return null when no username is known for the
+     * principal name.
+     *
+     * @return username corresponding to this principal name, if any
+     */
+    public String getLocalName(Oid mech) throws GSSException {
+        throw new GSSException(GSSException.UNAVAILABLE, -1,
+                "Mapping Kerberos principal names to usernames is not " +
+                "currently supported");
+    }
+
     /**
      * Returns the name type oid.
      */
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java b/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java
index 24362d0074..bfb93f9371 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spi/GSSNameSpi.java
@@ -100,6 +100,23 @@ public interface GSSNameSpi {
      */
     public String toString();
 
+    /**
+     * Returns a local username (platform-specific) corresponding to the
+     * principal name, and may return null when no username is known for the
+     * principal name.
+     *
+     * @return username corresponding to this name, if any
+     */
+    public String getLocalName() throws GSSException;
+
+    /**
+     * Returns a local username (platform-specific) corresponding to the
+     * principal name, and may return null when no username is known for the
+     * principal name.
+     *
+     * @return username corresponding to this name, if any
+     */
+    public String getLocalName(Oid mech) throws GSSException;
 
     /**
      * Returns the oid describing the format of the printable name.
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
index 900532459b..cbdf7a3b59 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSLibStub.java
@@ -65,6 +65,7 @@ class GSSLibStub {
     native boolean compareName(long pName1, long pName2);
     native long canonicalizeName(long pName);
     native byte[] exportName(long pName) throws GSSException;
+    native String localName(long pName, Oid mech) throws GSSException;
     native Object[] displayName(long pName) throws GSSException;
 
     // Credential related routines
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
index 53c62b2a4b..9952ee12d1 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
@@ -276,6 +276,16 @@ public class GSSNameElement implements GSSNameSpi {
         return printableName;
     }
 
+    public String getLocalName() throws GSSException {
+        return cStub.localName(pName, mech);
+    }
+
+    public String getLocalName(Oid mech) throws GSSException {
+        if (mech.equals(this.mech))
+            return cStub.localName(pName, mech);
+        throw new GSSException(GSSException.BAD_MECH);
+    }
+
     public Oid getStringNameType() {
         return printableType;
     }
diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index 58bab7ecb8..d9185b81d7 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -512,6 +512,69 @@ Java_sun_security_jgss_wrapper_GSSLibStub_exportName(JNIEnv *env,
   return getJavaBuffer(env, &outBuf, JNI_TRUE);
 }
 
+/*
+ * Class:     sun_security_jgss_wrapper_GSSLibStub
+ * Method:    localName
+ * Signature: (J)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_sun_security_jgss_wrapper_GSSLibStub_localName(JNIEnv *env,
+                                                    jobject jobj,
+                                                    jlong pName,
+                                                    jobject jOid)
+{
+  OM_uint32 minor, major, dummy;
+  gss_name_t nameHdl, mnNameHdl;
+  gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;
+  gss_OID mech;
+
+  nameHdl = (gss_name_t) jlong_to_ptr(pName);
+
+  if (ftab->localName == NULL) {
+    TRACE0("GSSLibStub_localName not supported by GSS provider");
+    checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,
+                "[GSSLibStub_localName]");
+    return NULL;
+  }
+  mech = newGSSOID(env, jOid);
+
+  /* gss_localname(...) => GSS_S_NAME_NOT_MN, GSS_S_BAD_NAMETYPE,
+     GSS_S_BAD_NAME */
+  major = (*ftab->localName)(&minor, nameHdl, mech, &outBuf);
+  if (major == GSS_S_COMPLETE) {
+    deleteGSSOID(mech);
+    return getJavaString(env, &outBuf);
+  }
+  (*ftab->releaseBuffer)(&minor, &outBuf);
+
+  if (major != GSS_S_NAME_NOT_MN) {
+    checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+    goto err;
+  }
+
+  /* canonicalize the internal name to MN and retry */
+  TRACE0("[GSSLibStub_localName] canonicalize and re-try");
+
+  major = (*ftab->canonicalizeName)(&minor, nameHdl, mech, &mnNameHdl);
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+  if ((*env)->ExceptionCheck(env))
+    goto err;
+
+  major = (*ftab->localName)(&minor, mnNameHdl, mech, &outBuf);
+  (void) (*ftab->releaseName)(&dummy, &mnNameHdl);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+  if ((*env)->ExceptionCheck(env) == JNI_FALSE && major == GSS_S_COMPLETE) {
+    deleteGSSOID(mech);
+    return getJavaString(env, &outBuf);
+  }
+  (*ftab->releaseBuffer)(&minor, &outBuf);
+
+err:
+  deleteGSSOID(mech);
+  return NULL;
+}
+
 /*
  * Class:     sun_security_jgss_wrapper_GSSLibStub
  * Method:    displayName
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeFunc.c b/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
index da7bc0445b..69b3b9cdfe 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeFunc.c
@@ -34,6 +34,7 @@ static const char COMPARE_NAME[]                = "gss_compare_name";
 static const char CANONICALIZE_NAME[]           = "gss_canonicalize_name";
 static const char EXPORT_NAME[]                 = "gss_export_name";
 static const char DISPLAY_NAME[]                = "gss_display_name";
+static const char LOCAL_NAME[]                  = "gss_localname";
 static const char ACQUIRE_CRED[]                = "gss_acquire_cred";
 static const char RELEASE_CRED[]                = "gss_release_cred";
 static const char INQUIRE_CRED[]                = "gss_inquire_cred";
@@ -122,6 +123,12 @@ int loadNative(const char *libName) {
         goto out;
     }
 
+    /*
+     * This one may not be available for a given GSS library, as it's an
+     * extension, therefore we don't fail if it's missing.
+     */
+    ftab->localName = (LOCAL_NAME_FN_PTR)GETFUNC(gssLib, LOCAL_NAME);
+
     ftab->acquireCred = (ACQUIRE_CRED_FN_PTR)GETFUNC(gssLib, ACQUIRE_CRED);
     if (ftab->acquireCred == NULL) {
         failed = TRUE;
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeFunc.h b/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
index 82914387c2..3c9d857482 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeFunc.h
@@ -84,6 +84,12 @@ typedef OM_uint32 (*DISPLAY_NAME_FN_PTR)
                                 gss_buffer_t output_name_buffer,
                                 gss_OID *output_name_type);
 
+typedef OM_uint32 (*LOCAL_NAME_FN_PTR)
+                                (OM_uint32 *minor_status,
+                                gss_name_t input_name,
+                                gss_OID mech,
+                                gss_buffer_t output_name_buffer);
+
 typedef OM_uint32 (*ACQUIRE_CRED_FN_PTR)
                                 (OM_uint32 *minor_status,
                                 gss_const_name_t desired_name,
@@ -249,6 +255,7 @@ typedef struct GSS_FUNCTION_TABLE {
     CANONICALIZE_NAME_FN_PTR            canonicalizeName;
     EXPORT_NAME_FN_PTR                  exportName;
     DISPLAY_NAME_FN_PTR                 displayName;
+    LOCAL_NAME_FN_PTR                   localName;
     ACQUIRE_CRED_FN_PTR                 acquireCred;
     RELEASE_CRED_FN_PTR                 releaseCred;
     INQUIRE_CRED_FN_PTR                 inquireCred;
diff --git a/src/java.security.jgss/share/native/libj2gss/gssapi.h b/src/java.security.jgss/share/native/libj2gss/gssapi.h
index 932742ca9f..885bdf8b0a 100644
--- a/src/java.security.jgss/share/native/libj2gss/gssapi.h
+++ b/src/java.security.jgss/share/native/libj2gss/gssapi.h
@@ -699,6 +699,15 @@ GSS_DLLIMP OM_uint32 gss_canonicalize_name(
 #    pragma pack(pop)
 #endif
 
+/* Common extension for aname2lname (NOT in RFC2744) */
+OM_uint32
+gss_localname(
+        OM_uint32 *,            /* minor_status */
+        const gss_name_t,       /* name */
+        gss_OID,                /* mech_type */
+        gss_buffer_t            /* localname */
+);
+
 #ifdef __cplusplus
 }
 #endif

commit 8c450b76c2cf3abf81b5806ef05578d97a2db760
Author: Viktor Dukhovni <viktor@twosigma.com>
Date:   Wed Dec 9 23:56:26 2015 +0000

    Add actual mechanism to native GSSNameElement state

diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
index 019fa6f805..6c9711e80b 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSCredElement.java
@@ -80,7 +80,7 @@ public class GSSCredElement implements GSSCredentialSpi {
             pCred = cStub.acquireCred(this.name.pName, lifetime, usage);
         } else {
             pCred = cStub.acquireCred(0, lifetime, usage);
-            this.name = new GSSNameElement(cStub.getCredName(pCred), cStub);
+            this.name = new GSSNameElement(cStub.getCredName(pCred), cStub.getMech(), cStub);
             doServicePermCheck();
         }
     }
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
index 88274c1601..53c62b2a4b 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/GSSNameElement.java
@@ -53,6 +53,7 @@ public class GSSNameElement implements GSSNameSpi {
     long pName = 0; // Pointer to the gss_name_t structure
     private String printableName;
     private Oid printableType;
+    private Oid mech;
     private GSSLibStub cStub;
 
     static final GSSNameElement DEF_ACCEPTOR = new GSSNameElement();
@@ -97,13 +98,14 @@ public class GSSNameElement implements GSSNameSpi {
         printableName = "<DEFAULT ACCEPTOR>";
     }
 
-    GSSNameElement(long pNativeName, GSSLibStub stub) throws GSSException {
+    GSSNameElement(long pNativeName, Oid mech, GSSLibStub stub) throws GSSException {
         assert(stub != null);
         if (pNativeName == 0) {
             throw new GSSException(GSSException.BAD_NAME);
         }
         // Note: pNativeName is assumed to be a MN.
         pName = pNativeName;
+        this.mech = mech;
         cStub = stub;
         setPrintables();
     }
@@ -116,6 +118,7 @@ public class GSSNameElement implements GSSNameSpi {
         }
         cStub = stub;
         byte[] name = nameBytes;
+        mech = cStub.getMech();
 
         if (nameType != null) {
             // Special handling the specified name type if
@@ -128,7 +131,6 @@ public class GSSNameElement implements GSSNameSpi {
                 // method) for "NT_EXPORT_NAME"
                 byte[] mechBytes = null;
                 DerOutputStream dout = new DerOutputStream();
-                Oid mech = cStub.getMech();
                 try {
                     dout.putOID(new ObjectIdentifier(mech.toString()));
                 } catch (IOException e) {
@@ -195,7 +197,7 @@ public class GSSNameElement implements GSSNameSpi {
     public String getKrbName() throws GSSException {
         long mName = 0;
         GSSLibStub stub = cStub;
-        if (!GSSUtil.isKerberosMech(cStub.getMech())) {
+        if (!GSSUtil.isKerberosMech(mech)) {
             stub = GSSLibStub.getInstance(GSSUtil.GSS_KRB5_MECH_OID);
         }
         mName = stub.canonicalizeName(pName);
@@ -267,7 +269,7 @@ public class GSSNameElement implements GSSNameSpi {
     }
 
     public Oid getMechanism() {
-        return cStub.getMech();
+        return (mech != null) ? mech : cStub.getMech();
     }
 
     public String toString() {
diff --git a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
index fa8e268b75..faef0b6779 100644
--- a/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java
@@ -241,8 +241,8 @@ class NativeGSSContext implements GSSContextSpi {
         if (info.length != NUM_OF_INQUIRE_VALUES) {
             throw new RuntimeException("Bug w/ GSSLibStub.inquireContext()");
         }
-        srcName = new GSSNameElement(info[0], cStub);
-        targetName = new GSSNameElement(info[1], cStub);
+        srcName = new GSSNameElement(info[0], actualMech, cStub);
+        targetName = new GSSNameElement(info[1], actualMech, cStub);
         isInitiator = (info[2] != 0);
         isEstablished = (info[3] != 0);
         flags = (int) info[4];
@@ -299,7 +299,8 @@ class NativeGSSContext implements GSSContextSpi {
             if (isEstablished) {
                 if (srcName == null) {
                     srcName = new GSSNameElement
-                        (cStub.getContextName(pContext, true), cStub);
+                        (cStub.getContextName(pContext, true), actualMech,
+                         cStub);
                 }
                 if (cred == null) {
                     disposeCred = cred =
@@ -326,7 +327,7 @@ class NativeGSSContext implements GSSContextSpi {
 
             if (targetName == null) {
                 targetName = new GSSNameElement
-                    (cStub.getContextName(pContext, false), cStub);
+                    (cStub.getContextName(pContext, false), actualMech, cStub);
                 // Replace the current default acceptor cred now that
                 // the context acceptor name is available
                 if (disposeCred != null) {
diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index 91359f447d..58bab7ecb8 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -854,10 +854,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
   gss_channel_bindings_t cb;
   gss_buffer_desc inToken;
   gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
-/* UNCOMMENT after SEAM bug#6287358 is backported to S10
   gss_OID aMech;
   jobject jMech;
-*/
 
   TRACE0("[GSSLibStub_initContext]");
 
@@ -891,7 +889,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
      GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME(!), GSS_S_BAD_MECH */
   major = (*ftab->initSecContext)(&minor, credHdl,
                                  &contextHdl, targetName, mech,
-                                 flags, time, cb, &inToken, NULL /*aMech*/,
+                                 flags, time, cb, &inToken, &aMech,
                                  &outToken, &aFlags, &aTime);
 
   TRACE2("[GSSLibStub_initContext] after: pContext=%" PRIuPTR ", outToken len=%ld",
@@ -920,11 +918,9 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
                               FID_NativeGSSContext_isEstablished,
                               JNI_TRUE);
 
-/* UNCOMMENT after SEAM bug#6287358 is backported to S10
       jMech = getJavaOID(env, aMech);
       (*env)->SetObjectField(env, jcontextSpi,
                              FID_NativeGSSContext_actualMech, jMech);
-*/
     } else if (major & GSS_S_CONTINUE_NEEDED) {
       TRACE0("[GSSLibStub_initContext] context not established");
       major &= ~GSS_S_CONTINUE_NEEDED;
@@ -1024,7 +1020,20 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
 
   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
     /* update member values if needed */
-    // WORKAROUND for an old Heimdal bug
+
+    if (aMech != GSS_C_NO_OID) {
+      jMech = getJavaOID(env, aMech);
+      if ((*env)->ExceptionCheck(env)) {
+        goto error;
+      }
+      (*env)->SetObjectField(env, jcontextSpi,
+                             FID_NativeGSSContext_actualMech, jMech);
+      if ((*env)->ExceptionCheck(env)) {
+        goto error;
+      }
+    }
+
+    /* WORKAROUND for an old Heimdal bug */
     if (delCred == GSS_C_NO_CREDENTIAL) {
         aFlags &= ~GSS_C_DELEG_FLAG;
     }
@@ -1043,7 +1052,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
 
       jtargetName = (*env)->NewObject(env, CLS_GSSNameElement,
                                 MID_GSSNameElement_ctor,
-                                ptr_to_jlong(targetName), jobj);
+                                ptr_to_jlong(targetName), jMech, jobj);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
@@ -1061,7 +1070,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
     if (srcName != GSS_C_NO_NAME) {
       jsrcName = (*env)->NewObject(env, CLS_GSSNameElement,
                                    MID_GSSNameElement_ctor,
-                                   ptr_to_jlong(srcName), jobj);
+                                   ptr_to_jlong(srcName), jMech, jobj);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
@@ -1083,12 +1092,6 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
       (*env)->SetBooleanField(env, jcontextSpi,
                               FID_NativeGSSContext_isEstablished,
                               JNI_TRUE);
-      jMech = getJavaOID(env, aMech);
-      if ((*env)->ExceptionCheck(env)) {
-        goto error;
-      }
-      (*env)->SetObjectField(env, jcontextSpi,
-                             FID_NativeGSSContext_actualMech, jMech);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
index 274e706497..0ca04a9b99 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
@@ -271,9 +271,9 @@ DEF_JNI_OnLoad(JavaVM *jvm, void *reserved) {
   }
   MID_GSSNameElement_ctor =
     (*env)->GetMethodID(env, CLS_GSSNameElement,
-                        "<init>", "(JLsun/security/jgss/wrapper/GSSLibStub;)V");
+                        "<init>", "(JLorg/ietf/jgss/Oid;Lsun/security/jgss/wrapper/GSSLibStub;)V");
   if (MID_GSSNameElement_ctor == NULL) {
-    printf("Couldn't find GSSNameElement(long, GSSLibStub) constructor\n");
+    printf("Couldn't find GSSNameElement(long, Oid, GSSLibStub) constructor\n");
     return JNI_ERR;
   }
   MID_GSSCredElement_ctor =

commit ccd17fc999068477dfd75dcf7802286ee367ae80
Author: Viktor Dukhovni <viktor@twosigma.com>
Date:   Wed Nov 11 04:12:07 2015 +0000

    Fix loss of GSS_S_FAILURE major status in importContext

diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index 4a5096467f..91359f447d 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -824,7 +824,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importContext(JNIEnv *env,
   } else {
     /* mech mismatch - clean up then return null */
     major = (*ftab->deleteSecContext)(&minor, &contextHdl, GSS_C_NO_BUFFER);
-    checkStatus(env, jobj, major, minor,
+    checkStatus(env, jobj, GSS_S_FAILURE, minor,
         "[GSSLibStub_importContext] cleanup");
     return NULL;
   }

commit e11f2a6a7e063e7828dddc26cbc5ab698035eb88
Author: Viktor Dukhovni <viktor@twosigma.com>
Date:   Thu Nov 12 06:43:43 2015 +0000

    Revert initGSSBuffer to JDK7 non-copy behaviour

diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index 4bb2ce1c74..4a5096467f 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -149,21 +149,20 @@ Java_sun_security_jgss_wrapper_GSSLibStub_getMechPtr(JNIEnv *env,
  * Utility routine which releases the specified gss_channel_bindings_t
  * structure.
  */
-void deleteGSSCB(gss_channel_bindings_t cb) {
-
+static void deleteGSSCB(JNIEnv *env, gss_channel_bindings_t cb) {
   if (cb == GSS_C_NO_CHANNEL_BINDINGS) return;
 
   /* release initiator address */
   if (cb->initiator_addrtype != GSS_C_AF_NULLADDR) {
-    resetGSSBuffer(&(cb->initiator_address));
+    resetGSSBuffer(env, NULL, &(cb->initiator_address));
   }
   /* release acceptor address */
   if (cb->acceptor_addrtype != GSS_C_AF_NULLADDR) {
-    resetGSSBuffer(&(cb->acceptor_address));
+    resetGSSBuffer(env, NULL, &(cb->acceptor_address));
   }
   /* release application data */
-  if (cb->application_data.length != 0) {
-    resetGSSBuffer(&(cb->application_data));
+  if (cb->application_data.value != NULL) {
+    resetGSSBuffer(env, NULL, &(cb->application_data));
   }
   free(cb);
 }
@@ -188,9 +187,11 @@ gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
     return NULL;
   }
 
-  // initialize addrtype in CB first
+  /* Fully initialize to a state safe for cleanup */
   cb->initiator_addrtype = GSS_C_AF_NULLADDR;
   cb->acceptor_addrtype = GSS_C_AF_NULLADDR;
+  cb->application_data.length = 0;
+  cb->application_data.value = NULL;
 
   // addresses needs to be initialized to empty
   memset(&cb->initiator_address, 0, sizeof(cb->initiator_address));
@@ -208,11 +209,11 @@ gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
-    cb->initiator_addrtype = GSS_C_AF_INET;
-    initGSSBuffer(env, value, &(cb->initiator_address));
+    initGSSBuffer(env, value, &(cb->initiator_address), JNI_TRUE);
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
+    cb->initiator_addrtype = GSS_C_AF_INET;
   }
   /* set up acceptor address */
   jinetAddr = (*env)->CallObjectMethod(env, jcb,
@@ -226,11 +227,11 @@ gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
-    cb->acceptor_addrtype = GSS_C_AF_INET;
-    initGSSBuffer(env, value, &(cb->acceptor_address));
+    initGSSBuffer(env, value, &(cb->acceptor_address), JNI_TRUE);
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
+    cb->acceptor_addrtype = GSS_C_AF_INET;
   }
   /* set up application data */
   value = (*env)->CallObjectMethod(env, jcb,
@@ -238,13 +239,13 @@ gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
   if ((*env)->ExceptionCheck(env)) {
     goto cleanup;
   }
-  initGSSBuffer(env, value, &(cb->application_data));
+  initGSSBuffer(env, value, &(cb->application_data), JNI_TRUE);
   if ((*env)->ExceptionCheck(env)) {
     goto cleanup;
   }
   return cb;
 cleanup:
-  deleteGSSCB(cb);
+  deleteGSSCB(env, cb);
   return NULL;
 }
 
@@ -366,14 +367,14 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importName(JNIEnv *env,
 
   TRACE0("[GSSLibStub_importName]");
 
-  initGSSBuffer(env, jnameVal, &nameVal);
+  initGSSBuffer(env, jnameVal, &nameVal, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
       return jlong_zero;
   }
 
   nameType = newGSSOID(env, jnameType);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&nameVal);
+    resetGSSBuffer(env, jnameVal, &nameVal);
     return jlong_zero;
   }
 
@@ -385,7 +386,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importName(JNIEnv *env,
 
   /* release intermediate buffers */
   deleteGSSOID(nameType);
-  resetGSSBuffer(&nameVal);
+  resetGSSBuffer(env, jnameVal, &nameVal);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_importName]");
   if ((*env)->ExceptionCheck(env)) {
@@ -781,7 +782,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importContext(JNIEnv *env,
   TRACE0("[GSSLibStub_importContext]");
 
   contextHdl = GSS_C_NO_CONTEXT;
-  initGSSBuffer(env, jctxtToken, &ctxtToken);
+  initGSSBuffer(env, jctxtToken, &ctxtToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -793,7 +794,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_importContext(JNIEnv *env,
   TRACE1("[GSSLibStub_importContext] pContext=%" PRIuPTR "", (uintptr_t) contextHdl);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&ctxtToken);
+  resetGSSBuffer(env, jctxtToken, &ctxtToken);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext]");
   /* return immediately if an exception has occurred */
@@ -874,9 +875,9 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
     return NULL;
   }
 
-  initGSSBuffer(env, jinToken, &inToken);
+  initGSSBuffer(env, jinToken, &inToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
-    deleteGSSCB(cb);
+    deleteGSSCB(env, cb);
     return NULL;
   }
 
@@ -931,8 +932,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
   }
 
   /* release intermediate buffers before checking status */
-  deleteGSSCB(cb);
-  resetGSSBuffer(&inToken);
+  deleteGSSCB(env, cb);
+  resetGSSBuffer(env, jinToken, &inToken);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_initContext]");
   if ((*env)->ExceptionCheck(env)) {
@@ -980,13 +981,13 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
   contextHdl = contextHdlSave = (gss_ctx_id_t)jlong_to_ptr(
     (*env)->GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
-  initGSSBuffer(env, jinToken, &inToken);
+  initGSSBuffer(env, jinToken, &inToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
   cb = newGSSCB(env, jcb);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&inToken);
+    resetGSSBuffer(env, jinToken, &inToken);
     return NULL;
   }
   setTarget = (credHdl == GSS_C_NO_CREDENTIAL);
@@ -1006,8 +1007,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
                            &aFlags, &aTime, &delCred);
   /* release intermediate buffers before checking status */
 
-  deleteGSSCB(cb);
-  resetGSSBuffer(&inToken);
+  deleteGSSCB(env, cb);
+  resetGSSBuffer(env, jinToken, &inToken);
 
   TRACE3("[GSSLibStub_acceptContext] after: pCred=%" PRIuPTR ", pContext=%" PRIuPTR ", pDelegCred=%" PRIuPTR "",
         (uintptr_t)credHdl, (uintptr_t)contextHdl, (uintptr_t) delCred);
@@ -1444,18 +1445,17 @@ Java_sun_security_jgss_wrapper_GSSLibStub_getMic(JNIEnv *env, jobject jobj,
     return NULL;
   }
   qop = (gss_qop_t) jqop;
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
 
   /* gss_get_mic(...) => GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
      GSS_S_BAD_QOP */
-  major =
-    (*ftab->getMic)(&minor, contextHdl, qop, &msg, &msgToken);
+  major = (*ftab->getMic)(&minor, contextHdl, qop, &msg, &msgToken);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
+  resetGSSBuffer(env, jmsg, &msg);
   checkStatus(env, jobj, major, minor, "[GSSLibStub_getMic]");
   if ((*env)->ExceptionCheck(env)) {
     (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
@@ -1499,12 +1499,12 @@ Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
   qop = (gss_qop_t) (*env)->CallIntMethod(env, jprop, MID_MessageProp_getQOP);
   if ((*env)->ExceptionCheck(env)) { return; }
 
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) { return; }
 
-  initGSSBuffer(env, jmsgToken, &msgToken);
+  initGSSBuffer(env, jmsgToken, &msgToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&msg);
+    resetGSSBuffer(env, jmsg, &msg);
     return;
   }
 
@@ -1515,8 +1515,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
     (*ftab->verifyMic)(&minor, contextHdl, &msg, &msgToken, &qop);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
-  resetGSSBuffer(&msgToken);
+  resetGSSBuffer(env, jmsg, &msg);
+  resetGSSBuffer(env, jmsgToken, &msgToken);
 
   /*
    * We don't throw on supplementary status codes here, instead we pass only
@@ -1580,7 +1580,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
     return NULL;
   }
 
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1591,8 +1591,9 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
                    &msgToken);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
+  resetGSSBuffer(env, jmsg, &msg);
   checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
+
   if ((*env)->ExceptionCheck(env)) {
     (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
     return NULL;
@@ -1643,7 +1644,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
     return NULL;
   }
 
-  initGSSBuffer(env, jmsgToken, &msgToken);
+  initGSSBuffer(env, jmsgToken, &msgToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1657,7 +1658,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
     (*ftab->unwrap)(&minor, contextHdl, &msgToken, &msg, &confState, &qop);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msgToken);
+  resetGSSBuffer(env, jmsgToken, &msgToken);
 
   /*
    * We don't throw on supplementary status codes here, instead we pass only
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
index 68caa76b68..274e706497 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
@@ -590,45 +590,59 @@ void checkStatus(JNIEnv *env, jobject jstub, OM_uint32 major,
  * Utility routine for initializing gss_buffer_t structure
  * with the byte[] in the specified jbyteArray object.
  * NOTE: must call resetGSSBuffer() to free up the resources
- * inside the gss_buffer_t structure.
  */
 void initGSSBuffer(JNIEnv *env, jbyteArray jbytes,
-                     gss_buffer_t cbytes) {
-
-  int len;
+                     gss_buffer_t cbytes, jboolean wantCopy)
+{
+  jboolean isCopy;
+  jint len;
   void* value;
 
   cbytes->length = 0;
   cbytes->value = NULL;
 
-  if (jbytes == NULL)
+  if (jbytes == NULL ||
+      (len = (*env)->GetArrayLength(env, jbytes)) == 0)
     return;
 
-  len = (*env)->GetArrayLength(env, jbytes);
+  cbytes->length = len;
+
+  if (wantCopy == JNI_FALSE) {
+    cbytes->value = (*env)->GetByteArrayElements(env, jbytes, &isCopy);
+    if (cbytes->value == NULL) {
+      throwOutOfMemoryError(env, NULL);
+    }
+    return;
+  }
+
   value = malloc(len);
   if (value == NULL) {
     throwOutOfMemoryError(env, NULL);
     return;
   }
+
   (*env)->GetByteArrayRegion(env, jbytes, 0, len, value);
   if ((*env)->ExceptionCheck(env)) {
     free(value);
     return;
   }
-  cbytes->length = len;
   cbytes->value = value;
 }
 
 /*
- * Utility routine for freeing the bytes malloc'ed
- * in initGSSBuffer() method.
- * NOTE: used in conjunction with initGSSBuffer(...).
+ * Utility routine for freeing the buffer obtained via initGSSBuffer().
+ * If jbytes is null this is a malloced copy.
  */
-void resetGSSBuffer(gss_buffer_t cbytes) {
-  if ((cbytes != NULL) && (cbytes != GSS_C_NO_BUFFER)) {
+void resetGSSBuffer(JNIEnv *env, jbyteArray jbytes, gss_buffer_t cbytes)
+{
+  if (cbytes->value == NULL)
+    return;
+  if (jbytes != NULL) {
+    (*env)->ReleaseByteArrayElements(env, jbytes, cbytes->value, JNI_ABORT);
+  } else if (cbytes->length > 0) {
     free(cbytes->value);
-    cbytes->length = 0;
     cbytes->value = NULL;
+    cbytes->length = 0;
   }
 }
 
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
index dd7a6019e3..7b35a9929e 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
@@ -39,8 +39,8 @@ extern "C" {
   extern void checkStatus(JNIEnv *, jobject, OM_uint32, OM_uint32, const char *);
   extern jint checkTime(OM_uint32);
   extern void throwOutOfMemoryError(JNIEnv *, const char*);
-  extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
-  extern void resetGSSBuffer(gss_buffer_t);
+  extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t, jboolean);
+  void resetGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
   void initGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
   void resetGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
 

commit 1e479bf45926a5d07f68fc44bf096a61198a424a
Author: Viktor Dukhovni <viktor@twosigma.com>
Date:   Fri Sep 21 17:02:11 2018 -0500

    Implement String to gss_buffer_t import

diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
index 76183c9445..68caa76b68 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
@@ -455,6 +455,14 @@ void throwOutOfMemoryError(JNIEnv *env, const char *message) {
     throwByName(env, "java/lang/OutOfMemoryError", message);
 }
 
+static jsize
+safe_jsize(size_t n)
+{
+    jsize res = (jsize)n;
+
+    return (res >= 0 && (size_t)res == n) ? res : -1;
+}
+
 /*
  * Utility routine for creating a java.lang.String object
  * using the specified gss_buffer_t structure. The specified
@@ -471,8 +479,7 @@ jstring getJavaString(JNIEnv *env, gss_buffer_t bytes) {
   }
 
   /* constructs the String object with new String(byte[]) */
-  len = (jsize)bytes->length;
-  if (len < 0 || bytes->length != (size_t)len) {
+  if ((len = safe_jsize(bytes->length)) < 0) {
     (*ftab->releaseBuffer)(&minor, bytes);
     return NULL;
   }
@@ -591,26 +598,25 @@ void initGSSBuffer(JNIEnv *env, jbyteArray jbytes,
   int len;
   void* value;
 
-  if (jbytes != NULL) {
-    len = (*env)->GetArrayLength(env, jbytes);
-    value = malloc(len);
-    if (value == NULL) {
-      throwOutOfMemoryError(env, NULL);
-      return;
-    } else {
-      (*env)->GetByteArrayRegion(env, jbytes, 0, len, value);
-      if ((*env)->ExceptionCheck(env)) {
-        free(value);
-        return;
-      } else {
-        cbytes->length = len;
-        cbytes->value = value;
-      }
-    }
-  } else {
-    cbytes->length = 0;
-    cbytes->value = NULL;
+  cbytes->length = 0;
+  cbytes->value = NULL;
+
+  if (jbytes == NULL)
+    return;
+
+  len = (*env)->GetArrayLength(env, jbytes);
+  value = malloc(len);
+  if (value == NULL) {
+    throwOutOfMemoryError(env, NULL);
+    return;
   }
+  (*env)->GetByteArrayRegion(env, jbytes, 0, len, value);
+  if ((*env)->ExceptionCheck(env)) {
+    free(value);
+    return;
+  }
+  cbytes->length = len;
+  cbytes->value = value;
 }
 
 /*
@@ -626,6 +632,40 @@ void resetGSSBuffer(gss_buffer_t cbytes) {
   }
 }
 
+/*
+ * Utility routine for initializing gss_buffer_t structure
+ * with a String.
+ * NOTE: need to call resetGSSBufferString(...) to free up
+ * the resources.
+ */
+void initGSSBufferString(JNIEnv* env, jstring jstr, gss_buffer_t buf)
+{
+  const char *s;
+
+  buf->length = 0;
+  buf->value = NULL;
+  if (jstr != NULL) {
+    s = (*env)->GetStringUTFChars(env, jstr, NULL);
+    if (s == NULL) {
+      throwOutOfMemoryError(env, NULL);
+    } else {
+      buf->length = strlen(s);
+      buf->value = (char *)s; /* Drop const */
+    }
+  }
+}
+
+/*
+ * Utility routine for unpinning/releasing the String
+ * associated with the specified jstring object.
+ * NOTE: used in conjunction with initGSSBufferString(...).
+ */
+void resetGSSBufferString(JNIEnv *env, jstring jstr, gss_buffer_t buf)
+{
+  if (jstr != NULL && buf->value != NULL)
+    (*env)->ReleaseStringUTFChars(env, jstr, buf->value);
+}
+
 /*
  * Utility routine for creating a jbyteArray object using
  * the byte[] value in specified gss_buffer_t structure.
@@ -642,13 +682,11 @@ jbyteArray getJavaBuffer(JNIEnv *env, gss_buffer_t cbytes, jboolean isToken) {
    */
   if (cbytes != GSS_C_NO_BUFFER &&
       (isToken == JNI_FALSE || cbytes->length > 0)) {
-    jsize len = (jsize)cbytes->length;
+    jsize len = safe_jsize(cbytes->length);
 
-    if (len < 0 || cbytes->length != (size_t)len) {
-      /* XXX: Throw exception */
-      return NULL;
+    if (len >= 0) {
+      result = (*env)->NewByteArray(env, len);
     }
-    result = (*env)->NewByteArray(env, len);
     if (result != NULL) {
       (*env)->SetByteArrayRegion(env, result, 0, len,
                                  cbytes->value);
@@ -790,8 +828,8 @@ jobjectArray getJavaOIDArray(JNIEnv *env, gss_OID_set cOidSet) {
   jsize i;
 
   if (cOidSet != NULL && cOidSet != GSS_C_NO_OID_SET) {
-    numOfOids = (jsize) cOidSet->count;
-    if (numOfOids < 0 || cOidSet->count != (size_t)numOfOids) {
+    numOfOids = safe_jsize(cOidSet->count);
+    if (numOfOids < 0) {
       return NULL;
     }
     jOidSet = (*env)->NewObjectArray(env, numOfOids, CLS_Oid, NULL);
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
index 9470c8d73a..dd7a6019e3 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
@@ -41,6 +41,8 @@ extern "C" {
   extern void throwOutOfMemoryError(JNIEnv *, const char*);
   extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
   extern void resetGSSBuffer(gss_buffer_t);
+  void initGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
+  void resetGSSBufferString(JNIEnv *, jstring, gss_buffer_t);
 
   extern gss_OID newGSSOID(JNIEnv *, jobject);
   extern void deleteGSSOID(gss_OID);

commit 4d9bca49718e592d20b603e464f032abcd8937f1
Author: Viktor Dukhovni <viktor@twosigma.com>
Date:   Fri Sep 21 14:41:56 2018 -0500

    Fix error handling in GSSLibStub
    
    Also improve object size handling in NativeUtil.

diff --git a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
index 79e1b57b96..4bb2ce1c74 100644
--- a/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
+++ b/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c
@@ -472,10 +472,9 @@ JNIEXPORT jbyteArray JNICALL
 Java_sun_security_jgss_wrapper_GSSLibStub_exportName(JNIEnv *env,
                                                      jobject jobj,
                                                      jlong pName) {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_name_t nameHdl, mNameHdl;
-  gss_buffer_desc outBuf;
-  jbyteArray jresult;
+  gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;
 
   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 
@@ -500,26 +499,16 @@ Java_sun_security_jgss_wrapper_GSSLibStub_exportName(JNIEnv *env,
     }
 
     major = (*ftab->exportName)(&minor, mNameHdl, &outBuf);
-    Java_sun_security_jgss_wrapper_GSSLibStub_releaseName
-                                        (env, jobj, ptr_to_jlong(mNameHdl));
-    if ((*env)->ExceptionCheck(env)) {
-      /* release intermediate buffers */
-      (*ftab->releaseBuffer)(&minor, &outBuf);
-      return NULL;
-    }
-  }
-
-  /* release intermediate buffers before checking status */
-  jresult = getJavaBuffer(env, &outBuf);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
+    (void) (*ftab->releaseName)(&dummy, &mNameHdl);
   }
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportName]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outBuf);
     return NULL;
   }
-  return jresult;
+  /* Map outBuf to byteArray result and release */
+  return getJavaBuffer(env, &outBuf, JNI_TRUE);
 }
 
 /*
@@ -533,7 +522,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_displayName(JNIEnv *env,
                                                       jlong pName) {
   OM_uint32 minor, major;
   gss_name_t nameHdl;
-  gss_buffer_desc outNameBuf;
+  gss_buffer_desc outNameBuf = GSS_C_EMPTY_BUFFER;
   gss_OID outNameType;
   jstring jname;
   jobject jtype;
@@ -854,7 +843,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
                                                       jbyteArray jinToken,
                                                       jobject jcontextSpi)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_cred_id_t credHdl ;
   gss_ctx_id_t contextHdl, contextHdlSave;
   gss_name_t targetName;
@@ -863,8 +852,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
   OM_uint32 time, aTime;
   gss_channel_bindings_t cb;
   gss_buffer_desc inToken;
-  gss_buffer_desc outToken;
-  jbyteArray jresult;
+  gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
 /* UNCOMMENT after SEAM bug#6287358 is backported to S10
   gss_OID aMech;
   jobject jMech;
@@ -938,23 +926,21 @@ Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
 */
     } else if (major & GSS_S_CONTINUE_NEEDED) {
       TRACE0("[GSSLibStub_initContext] context not established");
-      major -= GSS_S_CONTINUE_NEEDED;
+      major &= ~GSS_S_CONTINUE_NEEDED;
     }
   }
 
   /* release intermediate buffers before checking status */
   deleteGSSCB(cb);
   resetGSSBuffer(&inToken);
-  jresult = getJavaBuffer(env, &outToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_initContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outToken);
     return NULL;
   }
-  return jresult;
+  /* Map outToken to byteArray result and release */
+  return getJavaBuffer(env, &outToken, JNI_TRUE);
 }
 
 /*
@@ -970,23 +956,23 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
                                                         jbyteArray jinToken,
                                                         jobject jcontextSpi)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   OM_uint32 minor2, major2;
   gss_ctx_id_t contextHdl, contextHdlSave;
   gss_cred_id_t credHdl;
   gss_buffer_desc inToken;
   gss_channel_bindings_t cb;
-  gss_name_t srcName;
-  gss_buffer_desc outToken;
+  gss_name_t srcName = GSS_C_NO_NAME;
+  gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
   gss_OID aMech;
   OM_uint32 aFlags;
   OM_uint32 aTime;
-  gss_cred_id_t delCred;
+  gss_cred_id_t delCred = GSS_C_NO_CREDENTIAL;
   jobject jsrcName = NULL;
   jobject jdelCred;
-  jobject jMech;
+  jobject jMech = NULL;
   jboolean setTarget;
-  gss_name_t targetName;
+  gss_name_t targetName = GSS_C_NO_NAME;
   jobject jtargetName;
 
   TRACE0("[GSSLibStub_acceptContext]");
@@ -1003,8 +989,6 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
     resetGSSBuffer(&inToken);
     return NULL;
   }
-  srcName = targetName = GSS_C_NO_NAME;
-  delCred = GSS_C_NO_CREDENTIAL;
   setTarget = (credHdl == GSS_C_NO_CREDENTIAL);
   aFlags = 0;
 
@@ -1039,9 +1023,9 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
 
   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
     /* update member values if needed */
-    // WORKAROUND for a Heimdal bug
+    // WORKAROUND for an old Heimdal bug
     if (delCred == GSS_C_NO_CREDENTIAL) {
-        aFlags &= 0xfffffffe;
+        aFlags &= ~GSS_C_DELEG_FLAG;
     }
     (*env)->SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
     TRACE1("[GSSLibStub_acceptContext] set flags=0x%x", aFlags);
@@ -1065,6 +1049,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
 
       TRACE1("[GSSLibStub_acceptContext] set targetName=%" PRIuPTR "",
               (uintptr_t)targetName);
+      targetName = GSS_C_NO_NAME;
 
       (*env)->SetObjectField(env, jcontextSpi, FID_NativeGSSContext_targetName,
                              jtargetName);
@@ -1081,6 +1066,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
       }
 
       TRACE1("[GSSLibStub_acceptContext] set srcName=%" PRIuPTR "", (uintptr_t)srcName);
+      srcName = GSS_C_NO_NAME;
 
       (*env)->SetObjectField(env, jcontextSpi, FID_NativeGSSContext_srcName,
                              jsrcName);
@@ -1112,11 +1098,12 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
         if ((*env)->ExceptionCheck(env)) {
           goto error;
         }
+        TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",
+                (uintptr_t) delCred);
+        delCred = GSS_C_NO_CREDENTIAL;
         (*env)->SetObjectField(env, jcontextSpi,
                                FID_NativeGSSContext_delegatedCred,
                                jdelCred);
-        TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",
-                (uintptr_t) delCred);
 
         if ((*env)->ExceptionCheck(env)) {
           goto error;
@@ -1129,10 +1116,18 @@ Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
         (*env)->SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
                             getJavaTime(aTime));
       }
-      major -= GSS_S_CONTINUE_NEEDED;
+      major &= ~GSS_S_CONTINUE_NEEDED;
     }
   }
-  return getJavaBuffer(env, &outToken);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_acceptContext]");
+  if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outToken);
+    return NULL;
+  }
+
+  /* Map outToken to byteArray result and release */
+  return getJavaBuffer(env, &outToken, JNI_TRUE);
 
 error:
   (*ftab->releaseBuffer)(&minor, &outToken);
@@ -1158,12 +1153,14 @@ Java_sun_security_jgss_wrapper_GSSLibStub_inquireContext(JNIEnv *env,
                                                          jobject jobj,
                                                          jlong pContext)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
-  gss_name_t srcName, targetName;
-  OM_uint32 time;
-  OM_uint32 flags;
-  int isInitiator, isEstablished;
+  gss_name_t srcName = GSS_C_NO_NAME;
+  gss_name_t targetName = GSS_C_NO_NAME;
+  OM_uint32 time = 0;
+  OM_uint32 flags = 0;
+  int isInitiator = 0;
+  int isEstablished = 0;
   jlong result[6];
   jlongArray jresult;
 
@@ -1171,10 +1168,6 @@ Java_sun_security_jgss_wrapper_GSSLibStub_inquireContext(JNIEnv *env,
 
   TRACE1("[GSSLibStub_inquireContext] %" PRIuPTR "", (uintptr_t)contextHdl);
 
-  srcName = targetName = GSS_C_NO_NAME;
-  time = 0;
-  flags = isInitiator = isEstablished = 0;
-
   /* gss_inquire_context(...) => GSS_S_NO_CONTEXT(!) */
   major = (*ftab->inquireContext)(&minor, contextHdl, &srcName,
                               &targetName, &time, NULL, &flags,
@@ -1185,6 +1178,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_inquireContext(JNIEnv *env,
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseName)(&dummy, &srcName);
+    (void) (*ftab->releaseName)(&dummy, &targetName);
     return NULL;
   }
   result[0] = ptr_to_jlong(srcName);
@@ -1195,11 +1190,12 @@ Java_sun_security_jgss_wrapper_GSSLibStub_inquireContext(JNIEnv *env,
   result[5] = (jlong) getJavaTime(time);
 
   jresult = (*env)->NewLongArray(env, 6);
-  if (jresult == NULL) {
-    return NULL;
+  if (jresult != NULL) {
+    (*env)->SetLongArrayRegion(env, jresult, 0, 6, result);
   }
-  (*env)->SetLongArrayRegion(env, jresult, 0, 6, result);
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseName)(&dummy, &srcName);
+    (void) (*ftab->releaseName)(&dummy, &targetName);
     return NULL;
   }
   return jresult;
@@ -1245,7 +1241,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_getContextName(JNIEnv *env,
   jobject jobj, jlong pContext, jboolean isSrc)
 {
   OM_uint32 minor, major;
-  gss_name_t nameHdl;
+  gss_name_t nameHdl = GSS_C_NO_NAME;
   gss_ctx_id_t contextHdl;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
@@ -1253,7 +1249,6 @@ Java_sun_security_jgss_wrapper_GSSLibStub_getContextName(JNIEnv *env,
   TRACE2("[GSSLibStub_getContextName] %" PRIuPTR ", isSrc=%d",
           (uintptr_t)contextHdl, isSrc);
 
-  nameHdl = GSS_C_NO_NAME;
   if (isSrc == JNI_TRUE) {
     major = (*ftab->inquireContext)(&minor, contextHdl, &nameHdl, NULL,
                                 NULL, NULL, NULL,  NULL, NULL);
@@ -1351,6 +1346,7 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrapSizeLimit(JNIEnv *env,
   gss_ctx_id_t contextHdl;
   OM_uint32 outSize, maxInSize;
   gss_qop_t qop;
+  jint result;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1374,7 +1370,14 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrapSizeLimit(JNIEnv *env,
   if ((*env)->ExceptionCheck(env)) {
     return 0;
   }
-  return (jint) maxInSize;
+
+  /* Right-shift maxInSize until it fits into jint */
+  result = (jint)maxInSize;
+  while (result < 0 || maxInSize != (OM_uint32)result) {
+    result = (jint)(maxInSize >>= 1);
+  }
+
+  return result;
 }
 
 /*
@@ -1387,10 +1390,9 @@ Java_sun_security_jgss_wrapper_GSSLibStub_exportContext(JNIEnv *env,
                                                         jobject jobj,
                                                         jlong pContext)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
-  gss_buffer_desc interProcToken;
-  jbyteArray jresult;
+  gss_buffer_desc interProcToken = GSS_C_EMPTY_BUFFER;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1406,17 +1408,14 @@ Java_sun_security_jgss_wrapper_GSSLibStub_exportContext(JNIEnv *env,
   major =
     (*ftab->exportSecContext)(&minor, &contextHdl, &interProcToken);
 
-  /* release intermediate buffers */
-  jresult = getJavaBuffer(env, &interProcToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &interProcToken);
     return NULL;
   }
 
-  return jresult;
+  /* Map interProcToken to byteArray result and release */
+  return getJavaBuffer(env, &interProcToken, JNI_TRUE);
 }
 
 /*
@@ -1429,12 +1428,11 @@ Java_sun_security_jgss_wrapper_GSSLibStub_getMic(JNIEnv *env, jobject jobj,
                                                  jlong pContext, jint jqop,
                                                  jbyteArray jmsg)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
   gss_qop_t qop;
   gss_buffer_desc msg;
-  gss_buffer_desc msgToken;
-  jbyteArray jresult;
+  gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1458,16 +1456,14 @@ Java_sun_security_jgss_wrapper_GSSLibStub_getMic(JNIEnv *env, jobject jobj,
 
   /* release intermediate buffers */
   resetGSSBuffer(&msg);
-  jresult = getJavaBuffer(env, &msgToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
   checkStatus(env, jobj, major, minor, "[GSSLibStub_getMic]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
     return NULL;
   }
 
-  return jresult;
+  /* Map msgToken to byteArray result and release */
+  return getJavaBuffer(env, &msgToken, JNI_TRUE);
 }
 
 /*
@@ -1522,6 +1518,11 @@ Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
   resetGSSBuffer(&msg);
   resetGSSBuffer(&msgToken);
 
+  /*
+   * We don't throw on supplementary status codes here, instead we pass only
+   * GSS_ERROR(major) to checkStatus() and set the supplementary status in the
+   * message properties.
+   */
   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_verifyMic]");
   if ((*env)->ExceptionCheck(env)) {
     return;
@@ -1534,9 +1535,6 @@ Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
 
   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
                        minor);
-  if ((*env)->ExceptionCheck(env)) {
-    return;
-  }
 }
 
 /*
@@ -1551,11 +1549,11 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
                                                jbyteArray jmsg,
                                                jobject jprop)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   jboolean confFlag;
   gss_qop_t qop;
   gss_buffer_desc msg;
-  gss_buffer_desc msgToken;
+  gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;
   int confState;
   gss_ctx_id_t contextHdl;
   jbyteArray jresult;
@@ -1594,12 +1592,14 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
 
   /* release intermediate buffers */
   resetGSSBuffer(&msg);
-  jresult = getJavaBuffer(env, &msgToken);
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
     return NULL;
   }
 
-  checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
+  /* Map msgToken to byteArray result and release */
+  jresult = getJavaBuffer(env, &msgToken, JNI_TRUE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1607,7 +1607,8 @@ Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
                          (confState? JNI_TRUE:JNI_FALSE));
   if ((*env)->ExceptionCheck(env)) {
-    return NULL;
+    (*env)->DeleteLocalRef(env, jresult);
+    jresult = NULL;
   }
   return jresult;
 }
@@ -1624,10 +1625,10 @@ Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
                                                  jbyteArray jmsgToken,
                                                  jobject jprop)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
   gss_buffer_desc msgToken;
-  gss_buffer_desc msg;
+  gss_buffer_desc msg = GSS_C_EMPTY_BUFFER;
   int confState;
   gss_qop_t qop;
   jbyteArray jresult;
@@ -1657,12 +1658,23 @@ Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
 
   /* release intermediate buffers */
   resetGSSBuffer(&msgToken);
-  jresult = getJavaBuffer(env, &msg);
+
+  /*
+   * We don't throw on supplementary status codes here, instead we pass only
+   * GSS_ERROR(major) to checkStatus() and set the supplementary status in the
+   * message properties.
+   */
+  checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msg);
     return NULL;
   }
 
-  checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");
+  /*
+   * Map msg to byteArray result and release, zero length msg maps to empty
+   * byte array, not null.
+   */
+  jresult = getJavaBuffer(env, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1671,15 +1683,18 @@ Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
                          (confState != 0));
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
                          minor);
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
 
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
index b7ec48ba51..76183c9445 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
@@ -463,31 +463,34 @@ void throwOutOfMemoryError(JNIEnv *env, const char *message) {
 jstring getJavaString(JNIEnv *env, gss_buffer_t bytes) {
   jstring result = NULL;
   OM_uint32 minor;
-  int len;
+  jsize len;
   jbyteArray jbytes;
 
-  if (bytes != NULL) {
-    /* constructs the String object with new String(byte[])
-       NOTE: do NOT include the trailing NULL */
-    len = (int) bytes->length;
-    jbytes = (*env)->NewByteArray(env, len);
-    if (jbytes == NULL) {
-      goto finish;
-    }
+  if (bytes == NULL) {
+    return NULL;
+  }
 
-    (*env)->SetByteArrayRegion(env, jbytes, 0, len, (jbyte *) bytes->value);
-    if ((*env)->ExceptionCheck(env)) {
-      goto finish;
-    }
+  /* constructs the String object with new String(byte[]) */
+  len = (jsize)bytes->length;
+  if (len < 0 || bytes->length != (size_t)len) {
+    (*ftab->releaseBuffer)(&minor, bytes);
+    return NULL;
+  }
+  jbytes = (*env)->NewByteArray(env, len);
+  if (jbytes == NULL) {
+    (*ftab->releaseBuffer)(&minor, bytes);
+    return NULL;
+  }
 
+  (*env)->SetByteArrayRegion(env, jbytes, 0, len, (jbyte *) bytes->value);
+  if ((*env)->ExceptionCheck(env) == JNI_FALSE) {
     result = (*env)->NewObject(env, CLS_String, MID_String_ctor,
                                jbytes);
-  finish:
-    (*env)->DeleteLocalRef(env, jbytes);
-    (*ftab->releaseBuffer)(&minor, bytes);
-    return result;
-  } /* else fall through */
-  return NULL;
+  }
+
+  (*env)->DeleteLocalRef(env, jbytes);
+  (*ftab->releaseBuffer)(&minor, bytes);
+  return result;
 }
 /*
  * Utility routine for generate message for the specified minor
@@ -519,7 +522,7 @@ jstring getMinorMessage(JNIEnv *env, jobject jstub, OM_uint32 statusValue) {
  * not GSS_S_COMPLETE (i.e. 0).
  */
 void checkStatus(JNIEnv *env, jobject jstub, OM_uint32 major,
-                 OM_uint32 minor, char* methodName) {
+                 OM_uint32 minor, const char *methodName) {
   int callingErr, routineErr, supplementaryInfo;
   jint jmajor, jminor;
   char* msg;
@@ -629,27 +632,34 @@ void resetGSSBuffer(gss_buffer_t cbytes) {
  * NOTE: the specified gss_buffer_t structure is always
  * released.
  */
-jbyteArray getJavaBuffer(JNIEnv *env, gss_buffer_t cbytes) {
+jbyteArray getJavaBuffer(JNIEnv *env, gss_buffer_t cbytes, jboolean isToken) {
   jbyteArray result = NULL;
-  OM_uint32 minor; // don't care, just so it compiles
-
-  if (cbytes != NULL) {
-    if ((cbytes != GSS_C_NO_BUFFER) && (cbytes->length != 0)) {
-      result = (*env)->NewByteArray(env, (int) cbytes->length);
-      if (result == NULL) {
-        goto finish;
-      }
-      (*env)->SetByteArrayRegion(env, result, 0, (int) cbytes->length,
+  OM_uint32 dummy;
+
+  /*
+   * Zero length tokens map to NULL outputs, but otherwise to a zero-length
+   * Java byte array.
+   */
+  if (cbytes != GSS_C_NO_BUFFER &&
+      (isToken == JNI_FALSE || cbytes->length > 0)) {
+    jsize len = (jsize)cbytes->length;
+
+    if (len < 0 || cbytes->length != (size_t)len) {
+      /* XXX: Throw exception */
+      return NULL;
+    }
+    result = (*env)->NewByteArray(env, len);
+    if (result != NULL) {
+      (*env)->SetByteArrayRegion(env, result, 0, len,
                                  cbytes->value);
       if ((*env)->ExceptionCheck(env)) {
+        (*env)->DeleteLocalRef(env, result);
         result = NULL;
       }
     }
-  finish:
-    (*ftab->releaseBuffer)(&minor, cbytes);
-    return result;
   }
-  return NULL;
+  (void) (*ftab->releaseBuffer)(&dummy, cbytes);
+  return result;
 }
 
 /*
@@ -774,13 +784,16 @@ void deleteGSSOIDSet(gss_OID_set oidSet) {
  * using the specified gss_OID_set structure.
  */
 jobjectArray getJavaOIDArray(JNIEnv *env, gss_OID_set cOidSet) {
-  int numOfOids = 0;
+  jsize numOfOids = 0;
   jobjectArray jOidSet;
   jobject jOid;
-  int i;
+  jsize i;
 
   if (cOidSet != NULL && cOidSet != GSS_C_NO_OID_SET) {
-    numOfOids = (int) cOidSet->count;
+    numOfOids = (jsize) cOidSet->count;
+    if (numOfOids < 0 || cOidSet->count != (size_t)numOfOids) {
+      return NULL;
+    }
     jOidSet = (*env)->NewObjectArray(env, numOfOids, CLS_Oid, NULL);
     if ((*env)->ExceptionCheck(env)) {
       return NULL;
diff --git a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
index e77e862a6e..9470c8d73a 100644
--- a/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
+++ b/src/java.security.jgss/share/native/libj2gss/NativeUtil.h
@@ -36,7 +36,7 @@ extern "C" {
 #endif
   extern jint getJavaTime(OM_uint32);
   extern OM_uint32 getGSSTime(jint);
-  extern void checkStatus(JNIEnv *, jobject, OM_uint32, OM_uint32, char*);
+  extern void checkStatus(JNIEnv *, jobject, OM_uint32, OM_uint32, const char *);
   extern jint checkTime(OM_uint32);
   extern void throwOutOfMemoryError(JNIEnv *, const char*);
   extern void initGSSBuffer(JNIEnv *, jbyteArray, gss_buffer_t);
@@ -47,7 +47,7 @@ extern "C" {
   extern gss_OID_set newGSSOIDSet(gss_OID);
   extern void deleteGSSOIDSet(gss_OID_set);
 
-  extern jbyteArray getJavaBuffer(JNIEnv *, gss_buffer_t);
+  extern jbyteArray getJavaBuffer(JNIEnv *, gss_buffer_t, jboolean);
   extern jstring getJavaString(JNIEnv *, gss_buffer_t);
   extern jobject getJavaOID(JNIEnv *, gss_OID);
   extern jobjectArray getJavaOIDArray(JNIEnv *, gss_OID_set);

commit 003fb9005ab99e6934cc1a9242037fc6b4428c85
Author: Viktor Dukhovni <viktor@twosigma.com>
Date:   Tue Nov 10 21:32:45 2015 +0000

    Add missing dbgsysGetLastErrorString()

diff --git a/src/jdk.jdwp.agent/share/native/libjdwp/export/sys.h b/src/jdk.jdwp.agent/share/native/libjdwp/export/sys.h
index 9561112457..1caae50c67 100644
--- a/src/jdk.jdwp.agent/share/native/libjdwp/export/sys.h
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/export/sys.h
@@ -41,6 +41,7 @@ void    dbgsysBuildLibName(char *, int, const char *, const char *);
 void *  dbgsysLoadLibrary(const char *, char *err_buf, int err_buflen);
 void    dbgsysUnloadLibrary(void *);
 void *  dbgsysFindLibraryEntry(void *, const char *);
+int     dbgsysGetLastErrorString(char *, int);
 
 /* Implemented in exec_md.c */
 int     dbgsysExec(char *cmdLine);
diff --git a/src/jdk.jdwp.agent/unix/native/libjdwp/linker_md.c b/src/jdk.jdwp.agent/unix/native/libjdwp/linker_md.c
index 35b2814d5a..7703e30cf3 100644
--- a/src/jdk.jdwp.agent/unix/native/libjdwp/linker_md.c
+++ b/src/jdk.jdwp.agent/unix/native/libjdwp/linker_md.c
@@ -66,6 +66,28 @@ static void dll_build_name(char* buffer, size_t buflen,
     free(paths_copy);
 }
 
+int
+dbgsysGetLastErrorString(char *buf, int len)
+{
+    const char *s = dlerror();
+    size_t n;
+    size_t l = (size_t)len;
+
+    if (len <= 0)
+        return 0;
+
+    *buf = '\0';
+    if (s == NULL)
+        return 0;
+
+    n = strlen(s);
+    if (n >= l)
+        n = l - 1;
+    strncpy(buf, s, n);
+    buf[n] = '\0'; /* not actually needed */
+    return n;
+}
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
