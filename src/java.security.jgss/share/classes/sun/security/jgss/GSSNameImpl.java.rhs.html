<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>Make GSSName implement Principal (add getName())
Add getLocalName() GSSName method</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.jgss;
  27 
  28 import org.ietf.jgss.*;
  29 import sun.security.jgss.spi.*;
  30 import java.util.Set;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.Arrays;
  34 import java.io.IOException;
  35 import java.io.UnsupportedEncodingException;
  36 import sun.security.util.ObjectIdentifier;
  37 import sun.security.util.DerInputStream;
  38 import sun.security.util.DerOutputStream;
  39 
  40 /**
  41  * This is the implementation class for GSSName. Conceptually the
  42  * GSSName is a container with mechanism specific name elements. Each
  43  * name element is a representation of how that particular mechanism
  44  * would canonicalize this principal.
  45  *
  46  * Generally a GSSName is created by an application when it supplies
  47  * a sequence of bytes and a nametype that helps each mechanism
  48  * decide how to interpret those bytes.
  49  *
  50  * It is not necessary to create name elements for each available
  51  * mechanism at the time the application creates the GSSName. This
  52  * implementation does this lazily, as and when name elements for
  53  * mechanisms are required to be handed out. (Generally, other GSS
  54  * classes like GSSContext and GSSCredential request specific
  55  * elements depending on the mechanisms that they are dealing with.)
  56  * Assume that getting a mechanism to parse the applciation specified
  57  * bytes is an expensive call.
  58  *
  59  * When a GSSName is canonicalized wrt some mechanism, it is supposed
  60  * to discard all elements of other mechanisms and retain only the
  61  * element for this mechanism. In GSS terminology this is called a
  62  * Mechanism Name or MN. This implementation tries to retain the
  63  * application provided bytes and name type just in case the MN is
  64  * asked to produce an element for a mechanism that is different.
  65  *
  66  * When a GSSName is to be exported, the name element for the desired
  67  * mechanism is converted to a byte representation and written
  68  * out. It might happen that a name element for that mechanism cannot
  69  * be obtained. This happens when the mechanism is just not supported
  70  * in this GSS-API or when the mechanism is supported but bytes
  71  * corresponding to the nametypes that it understands are not
  72  * available in this GSSName.
  73  *
  74  * This class is safe for sharing. Each retrieval of a name element
  75  * from getElement() might potentially add a new element to the
  76  * hashmap of elements, but getElement() is synchronized.
  77  *
  78  * @author Mayank Upadhyay
  79  * @since 1.4
  80  */
  81 
  82 public class GSSNameImpl implements GSSName {
  83 
  84     /**
  85      * The old Oid used in RFC 2853. Now supported as
  86      * input parameters in:
  87      *
  88      * 1. The four overloaded GSSManager.createName(*) methods
  89      * 2. GSSManager.getMechsForName(Oid)
  90      *
  91      * Note that even if a GSSName is created with this old Oid,
  92      * its internal name type and getStringNameType() output are
  93      * always the new value.
  94      */
  95     final static Oid oldHostbasedServiceName;
  96 
  97     static {
  98         Oid tmp = null;
  99         try {
 100             tmp = new Oid("1.3.6.1.5.6.2");
 101         } catch (Exception e) {
 102             // should never happen
 103         }
 104         oldHostbasedServiceName = tmp;
 105     }
 106 
 107     private GSSManagerImpl gssManager = null;
 108 
 109     /*
 110      * Store whatever the application passed in. We will use this to
 111      * get individual mechanisms to create name elements as and when
 112      * needed.
 113      * Store both the String and the byte[]. Leave I18N to the
 114      * mechanism by allowing it to extract bytes from the String!
 115      */
 116 
 117     private String appNameStr = null;
 118     private byte[] appNameBytes = null;
 119     private Oid appNameType = null;
 120 
 121     /*
 122      * When we figure out what the printable name would be, we store
 123      * both the name and its type.
 124      */
 125 
 126     private String printableName = null;
 127     private Oid printableNameType = null;
 128 
 129     private HashMap&lt;Oid, GSSNameSpi&gt; elements = null;
 130     private GSSNameSpi mechElement = null;
 131 
 132     static GSSNameImpl wrapElement(GSSManagerImpl gssManager,
 133         GSSNameSpi mechElement) throws GSSException {
 134         return (mechElement == null ?
 135             null : new GSSNameImpl(gssManager, mechElement));
 136     }
 137 
 138     GSSNameImpl(GSSManagerImpl gssManager, GSSNameSpi mechElement) {
 139         this.gssManager = gssManager;
 140         appNameStr = printableName = mechElement.toString();
 141         appNameType = printableNameType = mechElement.getStringNameType();
 142         this.mechElement = mechElement;
 143         elements = new HashMap&lt;Oid, GSSNameSpi&gt;(1);
 144         elements.put(mechElement.getMechanism(), this.mechElement);
 145     }
 146 
 147     GSSNameImpl(GSSManagerImpl gssManager,
 148                        Object appName,
 149                        Oid appNameType)
 150         throws GSSException {
 151         this(gssManager, appName, appNameType, null);
 152     }
 153 
 154     GSSNameImpl(GSSManagerImpl gssManager,
 155                         Object appName,
 156                         Oid appNameType,
 157                         Oid mech)
 158         throws GSSException {
 159 
 160         if (oldHostbasedServiceName.equals(appNameType)) {
 161             appNameType = GSSName.NT_HOSTBASED_SERVICE;
 162         }
 163         if (appName == null)
 164             throw new GSSExceptionImpl(GSSException.BAD_NAME,
 165                                    "Cannot import null name");
 166         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 167         if (NT_EXPORT_NAME.equals(appNameType)) {
 168             importName(gssManager, appName);
 169         } else {
 170             init(gssManager, appName, appNameType, mech);
 171         }
 172     }
 173 
 174     private void init(GSSManagerImpl gssManager,
 175                       Object appName, Oid appNameType,
 176                       Oid mech)
 177         throws GSSException {
 178 
 179         this.gssManager = gssManager;
 180         this.elements =
 181                 new HashMap&lt;Oid, GSSNameSpi&gt;(gssManager.getMechs().length);
 182 
 183         if (appName instanceof String) {
 184             this.appNameStr = (String) appName;
 185             /*
 186              * If appNameType is null, then the nametype for this printable
 187              * string is determined only by interrogating the
 188              * mechanism. Thus, defer the setting of printableName and
 189              * printableNameType till later.
 190              */
 191             if (appNameType != null) {
 192                 printableName = appNameStr;
 193                 printableNameType = appNameType;
 194             }
 195         } else {
 196             this.appNameBytes = (byte[]) appName;
 197         }
 198 
 199         this.appNameType = appNameType;
 200 
 201         mechElement = getElement(mech);
 202 
 203         /*
 204          * printableName will be null if appName was in a byte[] or if
 205          * appName was in a String but appNameType was null.
 206          */
 207         if (printableName == null) {
 208             printableName = mechElement.toString();
 209             printableNameType = mechElement.getStringNameType();
 210         }
 211 
 212         /*
 213          *  At this point the GSSNameImpl has the following set:
 214          *   appNameStr or appNameBytes
 215          *   appNameType (could be null)
 216          *   printableName
 217          *   printableNameType
 218          *   mechElement (which also exists in the hashmap of elements)
 219          */
 220     }
 221 
 222     private void importName(GSSManagerImpl gssManager,
 223                             Object appName)
 224         throws GSSException {
 225 
 226         int pos = 0;
 227         byte[] bytes = null;
 228 
 229         if (appName instanceof String) {
 230             try {
 231                 bytes = ((String) appName).getBytes("UTF-8");
 232             } catch (UnsupportedEncodingException e) {
 233                 // Won't happen
 234             }
 235         } else
 236             bytes = (byte[]) appName;
 237 
 238         if ((bytes[pos++] != 0x04) ||
 239             (bytes[pos++] != 0x01))
 240             throw new GSSExceptionImpl(GSSException.BAD_NAME,
 241                                    "Exported name token id is corrupted!");
 242 
 243         int oidLen  = (((0xFF &amp; bytes[pos++]) &lt;&lt; 8) |
 244                        (0xFF &amp; bytes[pos++]));
 245         ObjectIdentifier temp = null;
 246         try {
 247             DerInputStream din = new DerInputStream(bytes, pos,
 248                                                     oidLen);
 249             temp = new ObjectIdentifier(din);
 250         } catch (IOException e) {
 251             throw new GSSExceptionImpl(GSSException.BAD_NAME,
 252                        "Exported name Object identifier is corrupted!");
 253         }
 254         Oid oid = new Oid(temp.toString());
 255         pos += oidLen;
 256         int mechPortionLen = (((0xFF &amp; bytes[pos++]) &lt;&lt; 24) |
 257                               ((0xFF &amp; bytes[pos++]) &lt;&lt; 16) |
 258                               ((0xFF &amp; bytes[pos++]) &lt;&lt; 8) |
 259                               (0xFF &amp; bytes[pos++]));
 260 
 261         if (mechPortionLen &lt; 0 || pos &gt; bytes.length - mechPortionLen) {
 262             throw new GSSExceptionImpl(GSSException.BAD_NAME,
 263                     "Exported name mech name is corrupted!");
 264         }
 265         byte[] mechPortion = new byte[mechPortionLen];
 266         System.arraycopy(bytes, pos, mechPortion, 0, mechPortionLen);
 267 
 268         init(gssManager, mechPortion, NT_EXPORT_NAME, oid);
 269     }
 270 
 271     public GSSName canonicalize(Oid mech) throws GSSException {
 272         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 273 
 274         return wrapElement(gssManager, getElement(mech));
 275     }
 276 
 277     /**
 278      * This method may return false negatives. But if it says two
 279      * names are equals, then there is some mechanism that
 280      * authenticates them as the same principal.
 281      */
 282     public boolean equals(GSSName other) throws GSSException {
 283 
 284         if (this.isAnonymous() || other.isAnonymous())
 285             return false;
 286 
 287         if (other == this)
 288             return true;
 289 
 290         if (! (other instanceof GSSNameImpl))
 291             return equals(gssManager.createName(other.toString(),
 292                                                 other.getStringNameType()));
 293 
 294         /*
 295          * XXX Do a comparison of the appNameStr/appNameBytes if
 296          * available. If that fails, then proceed with this test.
 297          */
 298 
 299         GSSNameImpl that = (GSSNameImpl) other;
 300 
 301         GSSNameSpi myElement = this.mechElement;
 302         GSSNameSpi element = that.mechElement;
 303 
 304         /*
 305          * XXX If they are not of the same mechanism type, convert both to
 306          * Kerberos since it is guaranteed to be present.
 307          */
 308         if ((myElement == null) &amp;&amp; (element != null)) {
 309             myElement = this.getElement(element.getMechanism());
 310         } else if ((myElement != null) &amp;&amp; (element == null)) {
 311             element = that.getElement(myElement.getMechanism());
 312         }
 313 
 314         if (myElement != null &amp;&amp; element != null) {
 315             return myElement.equals(element);
 316         }
 317 
 318         if ((this.appNameType != null) &amp;&amp;
 319             (that.appNameType != null)) {
 320             if (!this.appNameType.equals(that.appNameType)) {
 321                 return false;
 322             }
 323             byte[] myBytes = null;
 324             byte[] bytes = null;
 325             try {
 326                 myBytes =
 327                     (this.appNameStr != null ?
 328                      this.appNameStr.getBytes("UTF-8") :
 329                      this.appNameBytes);
 330                 bytes =
 331                     (that.appNameStr != null ?
 332                      that.appNameStr.getBytes("UTF-8") :
 333                      that.appNameBytes);
 334             } catch (UnsupportedEncodingException e) {
 335                 // Won't happen
 336             }
 337 
 338             return Arrays.equals(myBytes, bytes);
 339         }
 340 
 341         return false;
 342 
 343     }
 344 
 345     /**
 346      * Returns a hashcode value for this GSSName.
 347      *
 348      * @return a hashCode value
 349      */
 350     public int hashCode() {
 351         /*
 352          * XXX
 353          * In order to get this to work reliably and properly(!), obtain a
 354          * Kerberos name element for the name and then call hashCode on its
 355          * string representation. But this cannot be done if the nametype
 356          * is not one of those supported by the Kerberos provider and hence
 357          * this name cannot be imported by Kerberos. In that case return a
 358          * constant value!
 359          */
 360 
 361         return 1;
 362     }
 363 
 364     public boolean equals(Object another) {
 365 
 366         try {
 367             // XXX This can lead to an infinite loop. Extract info
 368             // and create a GSSNameImpl with it.
 369 
 370             if (another instanceof GSSName)
 371                 return equals((GSSName) another);
 372         } catch (GSSException e) {
 373             // Squelch it and return false
 374         }
 375 
 376             return false;
 377     }
 378 
 379     /**
 380      * Returns a flat name representation for this object. The name
 381      * format is defined in RFC 2743:
 382      *&lt;pre&gt;
 383      * Length           Name          Description
 384      * 2               TOK_ID          Token Identifier
 385      *                                 For exported name objects, this
 386      *                                 must be hex 04 01.
 387      * 2               MECH_OID_LEN    Length of the Mechanism OID
 388      * MECH_OID_LEN    MECH_OID        Mechanism OID, in DER
 389      * 4               NAME_LEN        Length of name
 390      * NAME_LEN        NAME            Exported name; format defined in
 391      *                                 applicable mechanism draft.
 392      *&lt;/pre&gt;
 393      *
 394      * Note that it is not required to canonicalize a name before
 395      * calling export(). i.e., the name need not be an MN. If it is
 396      * not an MN, an implementation defined algorithm can be used for
 397      * choosing the mechanism which should export this name.
 398      *
 399      * @return the flat name representation for this object
 400      * @exception GSSException with major codes NAME_NOT_MN, BAD_NAME,
 401      *  BAD_NAME, FAILURE.
 402      */
 403     public byte[] export() throws GSSException {
 404 
 405         if (mechElement == null) {
 406             /* Use default mech */
 407             mechElement = getElement(ProviderList.DEFAULT_MECH_OID);
 408         }
 409 
 410         byte[] mechPortion = mechElement.export();
 411         byte[] oidBytes = null;
 412         ObjectIdentifier oid = null;
 413 
 414         try {
 415             oid = new ObjectIdentifier
 416                 (mechElement.getMechanism().toString());
 417         } catch (IOException e) {
 418             throw new GSSExceptionImpl(GSSException.FAILURE,
 419                                        "Invalid OID String ");
 420         }
 421         DerOutputStream dout = new DerOutputStream();
 422         try {
 423             dout.putOID(oid);
 424         } catch (IOException e) {
 425             throw new GSSExceptionImpl(GSSException.FAILURE,
 426                                    "Could not ASN.1 Encode "
 427                                    + oid.toString());
 428         }
 429         oidBytes = dout.toByteArray();
 430 
 431         byte[] retVal = new byte[2
 432                                 + 2 + oidBytes.length
 433                                 + 4 + mechPortion.length];
 434         int pos = 0;
 435         retVal[pos++] = 0x04;
 436         retVal[pos++] = 0x01;
 437         retVal[pos++] = (byte) (oidBytes.length&gt;&gt;&gt;8);
 438         retVal[pos++] = (byte) oidBytes.length;
 439         System.arraycopy(oidBytes, 0, retVal, pos, oidBytes.length);
 440         pos += oidBytes.length;
 441         retVal[pos++] = (byte) (mechPortion.length&gt;&gt;&gt;24);
 442         retVal[pos++] = (byte) (mechPortion.length&gt;&gt;&gt;16);
 443         retVal[pos++] = (byte) (mechPortion.length&gt;&gt;&gt;8);
 444         retVal[pos++] = (byte)  mechPortion.length;
 445         System.arraycopy(mechPortion, 0, retVal, pos, mechPortion.length);
 446         return retVal;
 447     }
 448 
 449     public String toString() {
 450         return printableName;
<a name="1" id="anc1"></a><span class="new"> 451     }</span>
 452 
<a name="2" id="anc2"></a><span class="new"> 453     public String getName() {</span>
<span class="new"> 454         return printableName;</span>
<span class="new"> 455     }</span>
<span class="new"> 456 </span>
<span class="new"> 457     public String getName(Oid mech) throws GSSException {</span>
<span class="new"> 458         GSSNameSpi element = elements.get(mech);</span>
<span class="new"> 459         if (element == null) {</span>
<span class="new"> 460             throw new GSSExceptionImpl(GSSException.UNAVAILABLE,</span>
<span class="new"> 461                     "GSSName object does not have an element for the " +</span>
<span class="new"> 462                     "given mechanism");</span>
<span class="new"> 463         }</span>
<span class="new"> 464         return element.toString();</span>
<span class="new"> 465     }</span>
<span class="new"> 466 </span>
<span class="new"> 467     public String getLocalName() throws GSSException {</span>
<span class="new"> 468         String lname = null;</span>
<span class="new"> 469         Oid mech = null;</span>
<span class="new"> 470         Oid mech2 = null;</span>
<span class="new"> 471 </span>
<span class="new"> 472         for (GSSNameSpi v : elements.values()) {</span>
<span class="new"> 473             String mname = v.getLocalName();</span>
<span class="new"> 474             if (mname == null)</span>
<span class="new"> 475                 continue;</span>
<span class="new"> 476             if (lname == null) {</span>
<span class="new"> 477                 mech = v.getMechanism();</span>
<span class="new"> 478                 lname = mname;</span>
<span class="new"> 479                 continue;</span>
<span class="new"> 480             }</span>
<span class="new"> 481             if (!lname.equals(mname)) {</span>
<span class="new"> 482                 mech2 = v.getMechanism();</span>
<span class="new"> 483                 break;</span>
<span class="new"> 484             }</span>
<span class="new"> 485         }</span>
<span class="new"> 486         if (mech2 == null)</span>
<span class="new"> 487             return lname;</span>
<span class="new"> 488         throw new GSSExceptionImpl(GSSException.UNAVAILABLE,</span>
<span class="new"> 489                 "Localname conflict between mechanisms " +</span>
<span class="new"> 490                 mech + " and " + mech2);</span>
<span class="new"> 491     }</span>
<span class="new"> 492 </span>
<span class="new"> 493     public String getLocalName(Oid mech) throws GSSException {</span>
<span class="new"> 494         GSSNameSpi element = elements.get(mech);</span>
<span class="new"> 495         if (element == null) {</span>
<span class="new"> 496             throw new GSSExceptionImpl(GSSException.UNAVAILABLE,</span>
<span class="new"> 497                     "GSSName object does not have an element for the " +</span>
<span class="new"> 498                     "given mechanism");</span>
<span class="new"> 499         }</span>
<span class="new"> 500         return element.getLocalName();</span>
 501     }
 502 
 503     public Oid getStringNameType() throws GSSException {
 504         return printableNameType;
 505     }
 506 
 507     public boolean isAnonymous() {
 508         if (printableNameType == null) {
 509             return false;
 510         } else {
 511             return GSSName.NT_ANONYMOUS.equals(printableNameType);
 512         }
 513     }
 514 
 515     public boolean isMN() {
 516         return true; // Since always canonicalized for some mech
 517     }
 518 
 519     public synchronized GSSNameSpi getElement(Oid mechOid)
 520         throws GSSException {
 521 
 522         GSSNameSpi retVal = elements.get(mechOid);
 523 
 524         if (retVal == null) {
 525             if (appNameStr != null) {
 526                 retVal = gssManager.getNameElement
 527                     (appNameStr, appNameType, mechOid);
 528             } else {
 529                 retVal = gssManager.getNameElement
 530                     (appNameBytes, appNameType, mechOid);
 531             }
 532             elements.put(mechOid, retVal);
 533         }
 534         return retVal;
 535     }
 536 
 537     Set&lt;GSSNameSpi&gt; getElements() {
 538         return new HashSet&lt;GSSNameSpi&gt;(elements.values());
 539     }
 540 
 541     private static String getNameTypeStr(Oid nameTypeOid) {
 542 
 543         if (nameTypeOid == null)
 544             return "(NT is null)";
 545 
 546         if (nameTypeOid.equals(NT_USER_NAME))
 547             return "NT_USER_NAME";
 548         if (nameTypeOid.equals(NT_HOSTBASED_SERVICE))
 549             return "NT_HOSTBASED_SERVICE";
 550         if (nameTypeOid.equals(NT_EXPORT_NAME))
 551             return "NT_EXPORT_NAME";
 552         if (nameTypeOid.equals(GSSUtil.NT_GSS_KRB5_PRINCIPAL))
 553             return "NT_GSS_KRB5_PRINCIPAL";
 554         else
 555             return "Unknown";
 556     }
 557 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden"></input></form></body></html>
