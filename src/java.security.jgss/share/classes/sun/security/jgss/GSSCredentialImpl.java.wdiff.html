<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>ws Wdiff src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java</title>

    <meta http-equiv="cache-control" content="no-cache" />

    <style type='text/css' media='screen'>
      pre	{ margin: 2px; }

      body	{ background-color: #eeeeee; }

      hr	{ border: none 0; border-top: 1px solid #aaa; height: 1px; }

      .subtracted { color: brown }
      .added	{ color: blue }

      .elided	{ border: 1px solid #444; cursor: pointer; margin: 1px }

      table.hidebar { border: 1px solid #ff9900; background-color: #eee;
      		  text-align: center; border-collapse: collapse; }

      .hidebar td.active-down { border: 1px solid #ff9900;
		border-right: 1px solid #ccc; cursor: s-resize }

      .hidebar td.active-down:hover { background-color: #ffcc99; }

      .hidebar td.active-up { border: 1px solid #ff9900; cursor: n-resize;
		border-left: 1px solid #ccc; }

      .hidebar td.active-up:hover { background-color: #ffcc99; }

      .hidebar td.elided-label { font-style: italic; width: 12em; }

      .cmdbox	{ position: fixed; top: 0; right: 0;
	          border-left: solid 1px #444;
	          border-bottom: solid 1px #444;
      		  background-color: #ccc; text-align: center }

      .cmdbox td { background-color: #eee; border: 1px #444 outset;
		   cursor: pointer; padding: 3px 4px; }
      .cmdbox td:hover { background-color: #ffcc99;
 		outline: thin solid #ff9900; }

      a:hover { background-color: #ffcc99; }

      a.print { font-size: x-small; }
    </style>

    <style type='text/css' media='print'>
	pre { font-family: courier, monospace; font-size: 0.8em; }
	.cmdbox { display: none; }
        a.print { display: none; }
	.hidebar td.active-down { display: none; }
	.hidebar td.active-up { display: none; }
        .hidebar td.elided-label { font-style: italic; font-size: small; }
	table.hidebar { border: none; border-bottom: 1px dotted #000000; }
	span.added { font-weight: bold;
	         background-color: #eee; width: 100%; display: block; }
	span.subtracted { font-style: italic;
		 background-color: #eee; width: 100%; display: block; }
	.elided { display: none; }
        hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
    </style>

    <script type="text/javascript">
      function show_n_hide_dir(id_to_show, id_to_hide, dir) {
	      var elt_to_show = document.getElementById(id_to_show);
	      var elt_to_hide = document.getElementById(id_to_hide);
	      // When we're opening up, we need to make the bottoms of the
	      // elements appear to be the same.  So our invariant should be
	      // elt.offsetBottom - window.scrollY.
	      var preinvar = elt_to_hide.offsetHeight - window.scrollY;
	      elt_to_show.style.setProperty('display', '', '');
	      elt_to_hide.style.setProperty('display', 'none', '');
	      if (dir == 'up') {
		      var postinvar = elt_to_show.offsetHeight - window.scrollY;
		      window.scrollBy(0, postinvar - preinvar);
	      }
      }

      function handle_click(e) {
	      var eh = e.target;
	      var es = document.getElementById("hb-" + e.target.id);
	      eh.style.setProperty('display', 'none', '');
	      es.style.setProperty('display', '', '');
	      /* Scroll so new element is at cursor. */
	      window.scroll(0, es.offsetTop + (es.offsetHeight / 2)
	          - e.clientY);
      }

      function stripsearch(str) {
	q = str.indexOf("?");
	if (q != -1)
	  str = str.substr(0, q);
	return (str);
      }

      function split() {
        page = stripsearch(location.href);
	halfway = window.scrollY + window.innerHeight / 2 - 5;
	document.write('<frameset rows="50%,*">' +
	  '<frame src="' + page + "?" + window.scrollY + '" />' +
	  '<frame src="' + page + "?" + halfway + '" />' +
	  '</frameset>');
	document.close();
      }

      function closeframe() {
	page = stripsearch(location.href);

	otherf = window.parent.frames[0];
	if (otherf == window)
	  otherf = window.parent.frames[1];

	parent.location.replace(page + "?" + otherf.scrollY);
      }
    </script>
  </head>
  <body id='SUNWwebrev'>
    <a class="print" href="javascript:print()">Print this page</a>
    <pre>
Add JGSS JNI bindings for gss cred store functions
Add createCredential() with password
Also avoid memory allocation in newGSSOIDSet() renamed to makeGSSOIDset()
which now takes a singleton set argument and either assigns the requested
OID or with SPNEGO returns a static list of all the supported mechs. With
this we no longer need deleteGSSOIDSet().
</pre>
<hr />
    <table class='cmdbox'>
      <tr>
        <td onclick='split()'>Split</td>
	<td id='close' onclick='closeframe()'>Close</td>
      </tr>
      <tr><td colspan="2" onclick='open_or_close_all(1)'>Expand all</td></tr>
      <tr><td colspan="2" onclick='open_or_close_all(0)'>Collapse all</td></tr>
    </table>

    <script type='text/javascript'>
      if (window == top)
        document.getElementById('close').style.setProperty('display', 'none', '');
    </script>
<pre><span class='subtracted'>          --- old/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java
</span><span class='added'>          +++ new/src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java
</span></pre>
<pre id='elided1' class='elided' style='display: none'>   1    1  /*
   2    2   * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
   3    3   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4    4   *
   5    5   * This code is free software; you can redistribute it and/or modify it
   6    6   * under the terms of the GNU General Public License version 2 only, as
   7    7   * published by the Free Software Foundation.  Oracle designates this
   8    8   * particular file as subject to the "Classpath" exception as provided
   9    9   * by Oracle in the LICENSE file that accompanied this code.
  10   10   *
  11   11   * This code is distributed in the hope that it will be useful, but WITHOUT
  12   12   * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13   13   * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14   14   * version 2 for more details (a copy is included in the LICENSE file that
  15   15   * accompanied this code).
  16   16   *
  17   17   * You should have received a copy of the GNU General Public License version
  18   18   * 2 along with this work; if not, write to the Free Software Foundation,
  19   19   * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20   20   *
  21   21   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22   22   * or visit www.oracle.com if you need additional information or have any
  23   23   * questions.
  24   24   */
  25   25  
  26   26  package sun.security.jgss;
  27   27  
  28   28  import org.ietf.jgss.*;
  29   29  import sun.security.jgss.spi.*;
  30   30  
  31   31  import java.util.*;
  32   32  import sun.security.jgss.spnego.SpNegoCredElement;
  33   33  
  34   34  public class GSSCredentialImpl implements GSSCredential {
  35   35  
  36   36      private GSSManagerImpl gssManager = null;
  37   37      private boolean destroyed = false;
  38   38  
  39   39      /*
  40   40       * We store all elements in a hashtable, using &lt;oid, usage&gt; as the
  41   41       * key. This makes it easy to locate the specific kind of credential we
  42   42       * need. The implementation needs to be optimized for the case where
  43   43       * there is just one element (tempCred).
  44   44       */
  45   45      private Hashtable&lt;SearchKey, GSSCredentialSpi&gt; hashtable = null;
  46   46  
  47   47      // XXX Optimization for single mech usage
  48   48      private GSSCredentialSpi tempCred = null;
  49   49  
  50   50      public GSSCredentialImpl() {
  51   51          // Useless
  52   52      }
  53   53  
  54   54      // Used by new ExtendedGSSCredential.ExtendedGSSCredentialImpl(cred)
  55   55      protected GSSCredentialImpl(GSSCredentialImpl src) {
  56   56          this.gssManager = src.gssManager;
  57   57          this.destroyed = src.destroyed;
  58   58          this.hashtable = src.hashtable;
</pre>
<table id='hb-elided1' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided1", "hb-elided1", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">58 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided1", "hb-elided1", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre>  59   59          this.tempCred = src.tempCred;
  60   60      }
  61   61  
  62   62      GSSCredentialImpl(GSSManagerImpl gssManager, int usage)
  63   63          throws GSSException {
  64   64          this(gssManager, null, GSSCredential.DEFAULT_LIFETIME,
  65   65               (Oid[]) null, usage);
  66   66      }
  67   67  
  68   68      GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
<span class='subtracted'>  69      -                             int lifetime, Oid mech, int usage)
</span><span class='added'>       69 +                      int lifetime, Oid mech, int usage)
</span>  70   70          throws GSSException {
  71   71          if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
  72   72  
  73   73          init(gssManager);
<span class='subtracted'>  74      -        add(name, lifetime, lifetime, mech, usage);
</span><span class='added'>       74 +        String password = null;
       75 +        add(name, password, lifetime, lifetime, mech, usage);
       76 +    }
       77 +
       78 +    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
       79 +                      Map&lt;String,String&gt; store, int lifetime, Oid mech,
       80 +                      int usage)
       81 +        throws GSSException {
       82 +        if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
       83 +
       84 +        init(gssManager);
       85 +        add(name, store, lifetime, lifetime, mech, usage);
       86 +    }
       87 +
       88 +    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name, String password,
       89 +                      int lifetime, Oid mech, int usage)
       90 +        throws GSSException {
       91 +        if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
       92 +
       93 +        init(gssManager);
       94 +        add(name, password, lifetime, lifetime, mech, usage);
</span>  75   95      }
  76   96  
  77   97      GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
  78   98                        int lifetime, Oid[] mechs, int usage)
  79   99          throws GSSException {
<span class='added'>      100 +        this(gssManager, name, (String)null, lifetime, mechs, usage);
      101 +    }
      102 +
      103 +    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
      104 +                      Map&lt;String,String&gt; store, int lifetime,
      105 +                      Oid mechs[], int usage)
      106 +        throws GSSException {
      107 +        init(gssManager);
      108 +        boolean defaultList = false;
      109 +        if (mechs == null) {
      110 +            mechs = gssManager.getMechs();
      111 +            defaultList = true;
      112 +        }
      113 +
      114 +        for (int i = 0; i &lt; mechs.length; i++) {
      115 +            try {
      116 +                add(name, store, lifetime, lifetime, mechs[i], usage);
      117 +            } catch (GSSException e) {
      118 +                if (defaultList) {
      119 +                    // Try the next mechanism
      120 +                    GSSUtil.debug("Ignore " + e + " while acquring cred for "
      121 +                        + mechs[i]);
      122 +                    //e.printStackTrace();
      123 +                } else throw e; // else try the next mechanism
      124 +            }
      125 +        }
      126 +        if ((hashtable.size() == 0) || (usage != getUsage()))
      127 +            throw new GSSException(GSSException.NO_CRED);
      128 +    }
      129 +
      130 +    GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
      131 +                      String password, int lifetime, Oid mechs[], int usage)
      132 +        throws GSSException {
</span>  80  133          init(gssManager);
  81  134          boolean defaultList = false;
  82  135          if (mechs == null) {
  83  136              mechs = gssManager.getMechs();
  84  137              defaultList = true;
  85  138          }
  86  139  
  87  140          for (int i = 0; i &lt; mechs.length; i++) {
  88  141              try {
<span class='subtracted'>  89      -                add(name, lifetime, lifetime, mechs[i], usage);
</span><span class='added'>      142 +                add(name, password, lifetime, lifetime, mechs[i], usage);
</span>  90  143              } catch (GSSException e) {
  91  144                  if (defaultList) {
  92  145                      // Try the next mechanism
  93  146                      GSSUtil.debug("Ignore " + e + " while acquring cred for "
  94  147                          + mechs[i]);
  95  148                      //e.printStackTrace();
  96  149                  } else throw e; // else try the next mechanism
  97  150              }
  98  151          }
  99  152          if ((hashtable.size() == 0) || (usage != getUsage()))
</pre>
<pre id='elided2' class='elided' style='display: none'> 100  153              throw new GSSException(GSSException.NO_CRED);
 101  154      }
 102  155  
 103  156      // Wrap a mech cred into a GSS cred
 104  157      public GSSCredentialImpl(GSSManagerImpl gssManager,
 105  158                        GSSCredentialSpi mechElement) throws GSSException {
 106  159  
 107  160          init(gssManager);
 108  161          int usage = GSSCredential.ACCEPT_ONLY;
 109  162          if (mechElement.isInitiatorCredential()) {
 110  163              if (mechElement.isAcceptorCredential()) {
 111  164                  usage = GSSCredential.INITIATE_AND_ACCEPT;
 112  165              } else {
 113  166                  usage = GSSCredential.INITIATE_ONLY;
 114  167              }
 115  168          }
 116  169          SearchKey key = new SearchKey(mechElement.getMechanism(),
 117  170                                          usage);
 118  171          tempCred = mechElement;
 119  172          hashtable.put(key, tempCred);
 120  173          // More mechs that can use this cred, say, SPNEGO
 121  174          if (!GSSUtil.isSpNegoMech(mechElement.getMechanism())) {
 122  175              key = new SearchKey(GSSUtil.GSS_SPNEGO_MECH_OID, usage);
 123  176              hashtable.put(key, new SpNegoCredElement(mechElement));
 124  177          }
 125  178      }
 126  179  
 127  180      void init(GSSManagerImpl gssManager) {
 128  181          this.gssManager = gssManager;
 129  182          hashtable = new Hashtable&lt;SearchKey, GSSCredentialSpi&gt;(
 130  183                                                  gssManager.getMechs().length);
 131  184      }
 132  185  
 133  186      public void dispose() throws GSSException {
 134  187          if (!destroyed) {
 135  188              GSSCredentialSpi element;
 136  189              Enumeration&lt;GSSCredentialSpi&gt; values = hashtable.elements();
 137  190              while (values.hasMoreElements()) {
 138  191                  element = values.nextElement();
 139  192                  element.dispose();
 140  193              }
 141  194              destroyed = true;
 142  195          }
 143  196      }
 144  197  
 145  198      public GSSCredential impersonate(GSSName name) throws GSSException {
 146  199          if (destroyed) {
 147  200              throw new IllegalStateException("This credential is " +
 148  201                                          "no longer valid");
 149  202          }
 150  203          Oid mech = tempCred.getMechanism();
 151  204          GSSNameSpi nameElement = (name == null ? null :
 152  205                                    ((GSSNameImpl)name).getElement(mech));
 153  206          GSSCredentialSpi cred = tempCred.impersonate(nameElement);
 154  207          return (cred == null ?
 155  208              null : GSSManagerImpl.wrap(new GSSCredentialImpl(gssManager, cred)));
 156  209      }
 157  210  
 158  211      public GSSName getName() throws GSSException {
 159  212          if (destroyed) {
 160  213              throw new IllegalStateException("This credential is " +
 161  214                                          "no longer valid");
 162  215          }
 163  216          return GSSNameImpl.wrapElement(gssManager, tempCred.getName());
 164  217      }
 165  218  
 166  219      public GSSName getName(Oid mech) throws GSSException {
 167  220  
 168  221          if (destroyed) {
 169  222              throw new IllegalStateException("This credential is " +
 170  223                                          "no longer valid");
 171  224          }
 172  225  
 173  226          SearchKey key = null;
 174  227          GSSCredentialSpi element = null;
 175  228  
 176  229          if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 177  230  
 178  231          key = new SearchKey(mech, GSSCredential.INITIATE_ONLY);
 179  232          element = hashtable.get(key);
 180  233  
 181  234          if (element == null) {
 182  235              key = new SearchKey(mech, GSSCredential.ACCEPT_ONLY);
 183  236              element = hashtable.get(key);
 184  237          }
 185  238  
 186  239          if (element == null) {
 187  240              key = new SearchKey(mech, GSSCredential.INITIATE_AND_ACCEPT);
 188  241              element = hashtable.get(key);
 189  242          }
 190  243  
 191  244          if (element == null) {
 192  245              throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 193  246          }
 194  247  
 195  248          return GSSNameImpl.wrapElement(gssManager, element.getName());
 196  249  
 197  250      }
 198  251  
 199  252      /**
 200  253       * Returns the remaining lifetime of this credential. The remaining
 201  254       * lifetime is defined as the minimum lifetime, either for initiate or
 202  255       * for accept, across all elements contained in it. Not terribly
 203  256       * useful, but required by GSS-API.
 204  257       */
 205  258      public int getRemainingLifetime() throws GSSException {
 206  259  
 207  260          if (destroyed) {
 208  261              throw new IllegalStateException("This credential is " +
 209  262                                          "no longer valid");
 210  263          }
 211  264  
 212  265          SearchKey tempKey;
 213  266          GSSCredentialSpi tempCred;
 214  267          int tempLife = 0, tempInitLife = 0, tempAcceptLife = 0;
 215  268          int min = INDEFINITE_LIFETIME;
 216  269  
 217  270          for (Enumeration&lt;SearchKey&gt; e = hashtable.keys();
 218  271                                          e.hasMoreElements(); ) {
 219  272              tempKey = e.nextElement();
 220  273              tempCred = hashtable.get(tempKey);
 221  274              if (tempKey.getUsage() == INITIATE_ONLY)
 222  275                  tempLife = tempCred.getInitLifetime();
 223  276              else if (tempKey.getUsage() == ACCEPT_ONLY)
 224  277                  tempLife = tempCred.getAcceptLifetime();
 225  278              else {
 226  279                  tempInitLife = tempCred.getInitLifetime();
 227  280                  tempAcceptLife = tempCred.getAcceptLifetime();
 228  281                  tempLife = (tempInitLife &lt; tempAcceptLife ?
 229  282                              tempInitLife:
 230  283                              tempAcceptLife);
 231  284              }
 232  285              if (min &gt; tempLife)
 233  286                  min = tempLife;
 234  287          }
 235  288  
 236  289          return min;
 237  290      }
 238  291  
 239  292      public int getRemainingInitLifetime(Oid mech) throws GSSException {
 240  293  
 241  294          if (destroyed) {
 242  295              throw new IllegalStateException("This credential is " +
 243  296                                          "no longer valid");
 244  297          }
 245  298  
 246  299          GSSCredentialSpi element = null;
 247  300          SearchKey key = null;
 248  301          boolean found = false;
 249  302          int max = 0;
 250  303  
 251  304          if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 252  305  
 253  306          key = new SearchKey(mech, GSSCredential.INITIATE_ONLY);
 254  307          element = hashtable.get(key);
 255  308  
 256  309          if (element != null) {
 257  310              found = true;
 258  311              if (max &lt; element.getInitLifetime())
 259  312                  max = element.getInitLifetime();
 260  313          }
 261  314  
 262  315          key = new SearchKey(mech, GSSCredential.INITIATE_AND_ACCEPT);
 263  316          element = hashtable.get(key);
 264  317  
 265  318          if (element != null) {
 266  319              found = true;
 267  320              if (max &lt; element.getInitLifetime())
 268  321                  max = element.getInitLifetime();
 269  322          }
 270  323  
 271  324          if (!found) {
 272  325              throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 273  326          }
 274  327  
 275  328          return max;
 276  329  
 277  330      }
 278  331  
 279  332      public int getRemainingAcceptLifetime(Oid mech) throws GSSException {
 280  333  
 281  334          if (destroyed) {
 282  335              throw new IllegalStateException("This credential is " +
 283  336                                          "no longer valid");
 284  337          }
 285  338  
 286  339          GSSCredentialSpi element = null;
 287  340          SearchKey key = null;
 288  341          boolean found = false;
 289  342          int max = 0;
 290  343  
 291  344          if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 292  345  
 293  346          key = new SearchKey(mech, GSSCredential.ACCEPT_ONLY);
 294  347          element = hashtable.get(key);
 295  348  
 296  349          if (element != null) {
 297  350              found = true;
 298  351              if (max &lt; element.getAcceptLifetime())
 299  352                  max = element.getAcceptLifetime();
 300  353          }
 301  354  
 302  355          key = new SearchKey(mech, GSSCredential.INITIATE_AND_ACCEPT);
 303  356          element = hashtable.get(key);
 304  357  
 305  358          if (element != null) {
 306  359              found = true;
 307  360              if (max &lt; element.getAcceptLifetime())
 308  361                  max = element.getAcceptLifetime();
 309  362          }
 310  363  
 311  364          if (!found) {
 312  365              throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 313  366          }
 314  367  
 315  368          return max;
 316  369  
 317  370      }
 318  371  
 319  372      /**
 320  373       * Returns the usage mode for this credential. Returns
 321  374       * INITIATE_AND_ACCEPT if any one element contained in it supports
 322  375       * INITIATE_AND_ACCEPT or if two different elements exist where one
 323  376       * support INITIATE_ONLY and the other supports ACCEPT_ONLY.
 324  377       */
 325  378      public int getUsage() throws GSSException {
 326  379  
 327  380          if (destroyed) {
 328  381              throw new IllegalStateException("This credential is " +
 329  382                                          "no longer valid");
 330  383          }
 331  384  
 332  385          SearchKey tempKey;
 333  386          boolean initiate = false;
 334  387          boolean accept = false;
 335  388  
 336  389          for (Enumeration&lt;SearchKey&gt; e = hashtable.keys();
 337  390                                          e.hasMoreElements(); ) {
 338  391              tempKey = e.nextElement();
 339  392              if (tempKey.getUsage() == INITIATE_ONLY)
 340  393                  initiate = true;
 341  394              else if (tempKey.getUsage() == ACCEPT_ONLY)
 342  395                  accept = true;
 343  396              else
 344  397                  return INITIATE_AND_ACCEPT;
 345  398          }
 346  399          if (initiate) {
 347  400              if (accept)
 348  401                  return INITIATE_AND_ACCEPT;
 349  402              else
 350  403                  return INITIATE_ONLY;
 351  404          } else
 352  405              return ACCEPT_ONLY;
 353  406      }
 354  407  
 355  408      public int getUsage(Oid mech) throws GSSException {
 356  409  
 357  410          if (destroyed) {
 358  411              throw new IllegalStateException("This credential is " +
 359  412                                          "no longer valid");
 360  413          }
 361  414  
 362  415          GSSCredentialSpi element = null;
 363  416          SearchKey key = null;
 364  417          boolean initiate = false;
 365  418          boolean accept = false;
 366  419  
 367  420          if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 368  421  
 369  422          key = new SearchKey(mech, GSSCredential.INITIATE_ONLY);
 370  423          element = hashtable.get(key);
 371  424  
 372  425          if (element != null) {
 373  426              initiate = true;
 374  427          }
 375  428  
 376  429          key = new SearchKey(mech, GSSCredential.ACCEPT_ONLY);
 377  430          element = hashtable.get(key);
 378  431  
 379  432          if (element != null) {
 380  433              accept = true;
 381  434          }
 382  435  
 383  436          key = new SearchKey(mech, GSSCredential.INITIATE_AND_ACCEPT);
 384  437          element = hashtable.get(key);
 385  438  
 386  439          if (element != null) {
 387  440              initiate = true;
 388  441              accept = true;
 389  442          }
 390  443  
 391  444          if (initiate &amp;&amp; accept)
 392  445              return GSSCredential.INITIATE_AND_ACCEPT;
 393  446          else if (initiate)
 394  447              return GSSCredential.INITIATE_ONLY;
 395  448          else if (accept)
 396  449              return GSSCredential.ACCEPT_ONLY;
 397  450          else {
 398  451              throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 399  452          }
 400  453      }
 401  454  
 402  455      public Oid[] getMechs() throws GSSException {
 403  456  
 404  457          if (destroyed) {
 405  458              throw new IllegalStateException("This credential is " +
 406  459                                          "no longer valid");
 407  460          }
 408  461          Vector&lt;Oid&gt; result = new Vector&lt;Oid&gt;(hashtable.size());
 409  462  
</pre>
<table id='hb-elided2' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided2", "hb-elided2", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">310 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided2", "hb-elided2", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre> 410  463          for (Enumeration&lt;SearchKey&gt; e = hashtable.keys();
 411  464                                                  e.hasMoreElements(); ) {
 412  465              SearchKey tempKey = e.nextElement();
 413  466              result.addElement(tempKey.getMech());
 414  467          }
 415  468          return result.toArray(new Oid[0]);
 416  469      }
 417  470  
 418  471      public void add(GSSName name, int initLifetime, int acceptLifetime,
 419  472                      Oid mech, int usage) throws GSSException {
<span class='added'>      473 +        String password = null;
      474 +        add(name, password, initLifetime, acceptLifetime, mech, usage);
      475 +    }
      476 +
      477 +    public void add(GSSName name, Map&lt;String,String&gt; store, int initLifetime,
      478 +                    int acceptLifetime, Oid mech, int usage)
      479 +                    throws GSSException {
      480 +        add(name, (String)null, store, initLifetime, acceptLifetime,
      481 +            mech, usage);
      482 +    }
      483 +
      484 +    public void add(GSSName name, String password, int initLifetime,
      485 +                    int acceptLifetime, Oid mech, int usage)
      486 +                    throws GSSException {
      487 +        add(name, password, (Map&lt;String,String&gt;)null, initLifetime,
      488 +            acceptLifetime, mech, usage);
      489 +    }
      490 +
      491 +    private void add(GSSName name, String password, Map&lt;String,String&gt; store,
      492 +                    int initLifetime, int acceptLifetime, Oid mech, int usage)
      493 +                    throws GSSException {
</span> 420  494  
 421  495          if (destroyed) {
 422  496              throw new IllegalStateException("This credential is " +
 423  497                                          "no longer valid");
 424  498          }
 425  499          if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 426  500  
 427  501          SearchKey key = new SearchKey(mech, usage);
 428  502          if (hashtable.containsKey(key)) {
 429  503              throw new GSSExceptionImpl(GSSException.DUPLICATE_ELEMENT,
 430  504                                         "Duplicate element found: " +
 431  505                                         getElementStr(mech, usage));
 432  506          }
 433  507  
 434  508          // XXX If not instance of GSSNameImpl then throw exception
 435  509          // Application mixing GSS implementations
 436  510          GSSNameSpi nameElement = (name == null ? null :
 437  511                                    ((GSSNameImpl)name).getElement(mech));
 438  512  
<span class='subtracted'> 439      -        tempCred = gssManager.getCredentialElement(nameElement,
 440      -                                                   initLifetime,
 441      -                                                   acceptLifetime,
 442      -                                                   mech,
 443      -                                                   usage);
</span><span class='added'>      513 +        if (password == null &amp;&amp; store == null) {
      514 +            tempCred = gssManager.getCredentialElement(nameElement,
      515 +                                                       initLifetime,
      516 +                                                       acceptLifetime,
      517 +                                                       mech,
      518 +                                                       usage);
      519 +        } else if (password != null) {
      520 +            tempCred = gssManager.getCredentialElement(nameElement,
      521 +                                                       password,
      522 +                                                       initLifetime,
      523 +                                                       acceptLifetime,
      524 +                                                       mech,
      525 +                                                       usage);
      526 +        } else {
      527 +            tempCred = gssManager.getCredentialElement(nameElement,
      528 +                                                       store,
      529 +                                                       initLifetime,
      530 +                                                       acceptLifetime,
      531 +                                                       mech,
      532 +                                                       usage);
      533 +        }
</span> 444  534          /*
 445  535           * Not all mechanisms support the concept of one credential element
 446  536           * that can be used for both initiating and accepting a context. In
 447  537           * the event that an application requests usage INITIATE_AND_ACCEPT
 448  538           * for a credential from such a mechanism, the GSS framework will
 449  539           * need to obtain two different credential elements from the
 450  540           * mechanism, one that will have usage INITIATE_ONLY and another
 451  541           * that will have usage ACCEPT_ONLY. The mechanism will help the
 452  542           * GSS-API realize this by returning a credential element with
 453  543           * usage INITIATE_ONLY or ACCEPT_ONLY prompting it to make another
</pre>
<pre id='elided3' class='elided' style='display: none'> 454  544           * call to getCredentialElement, this time with the other usage
 455  545           * mode.
 456  546           */
 457  547  
 458  548          if (tempCred != null) {
 459  549              if (usage == GSSCredential.INITIATE_AND_ACCEPT &amp;&amp;
 460  550                  (!tempCred.isAcceptorCredential() ||
 461  551                  !tempCred.isInitiatorCredential())) {
 462  552  
 463  553                  int currentUsage;
 464  554                  int desiredUsage;
 465  555  
 466  556                  if (!tempCred.isInitiatorCredential()) {
</pre>
<table id='hb-elided3' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided3", "hb-elided3", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">13 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided3", "hb-elided3", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre> 467  557                      currentUsage = GSSCredential.ACCEPT_ONLY;
 468  558                      desiredUsage = GSSCredential.INITIATE_ONLY;
 469  559                  } else {
 470  560                      currentUsage = GSSCredential.INITIATE_ONLY;
 471  561                      desiredUsage = GSSCredential.ACCEPT_ONLY;
 472  562                  }
 473  563  
 474  564                  key = new SearchKey(mech, currentUsage);
 475  565                  hashtable.put(key, tempCred);
 476  566  
<span class='subtracted'> 477      -                tempCred = gssManager.getCredentialElement(nameElement,
 478      -                                                        initLifetime,
 479      -                                                        acceptLifetime,
 480      -                                                        mech,
 481      -                                                        desiredUsage);
</span><span class='added'>      567 +                if (store == null &amp;&amp; password == null) {
      568 +                    tempCred = gssManager.getCredentialElement(nameElement,
      569 +                                                               initLifetime,
      570 +                                                               acceptLifetime,
      571 +                                                               mech,
      572 +                                                               desiredUsage);
      573 +                } else if (password != null) {
      574 +                    tempCred = gssManager.getCredentialElement(nameElement,
      575 +                                                               password,
      576 +                                                               initLifetime,
      577 +                                                               acceptLifetime,
      578 +                                                               mech,
      579 +                                                               desiredUsage);
      580 +                } else {
      581 +                    tempCred = gssManager.getCredentialElement(nameElement,
      582 +                                                               store,
      583 +                                                               initLifetime,
      584 +                                                               acceptLifetime,
      585 +                                                               mech,
      586 +                                                               desiredUsage);
      587 +                }
</span> 482  588  
 483  589                  key = new SearchKey(mech, desiredUsage);
 484  590                  hashtable.put(key, tempCred);
 485  591              } else {
 486  592                  hashtable.put(key, tempCred);
 487  593              }
 488  594          }
 489  595      }
 490  596  
 491  597      public boolean equals(Object another) {
</pre>
<pre id='elided4' class='elided' style='display: none'> 492  598  
 493  599          if (destroyed) {
 494  600              throw new IllegalStateException("This credential is " +
 495  601                                          "no longer valid");
 496  602          }
 497  603  
 498  604          if (this == another) {
 499  605              return true;
 500  606          }
 501  607  
 502  608          if (!(another instanceof GSSCredentialImpl)) {
 503  609              return false;
 504  610          }
 505  611  
 506  612          // NOTE: The specification does not define the criteria to compare
 507  613          // credentials.
 508  614          /*
 509  615           * XXX
 510  616           * The RFC says: "Tests if this GSSCredential refers to the same
 511  617           * entity as the supplied object.  The two credentials must be
 512  618           * acquired over the same mechanisms and must refer to the same
 513  619           * principal.  Returns "true" if the two GSSCredentials refer to
 514  620           * the same entity; "false" otherwise."
 515  621           *
 516  622           * Well, when do two credentials refer to the same principal? Do
 517  623           * they need to have one GSSName in common for the different
 518  624           * GSSName's that the credential elements return? Or do all
 519  625           * GSSName's have to be in common when the names are exported with
 520  626           * their respective mechanisms for the credential elements?
 521  627           */
 522  628          return false;
 523  629  
 524  630      }
 525  631  
 526  632      /**
 527  633       * Returns a hashcode value for this GSSCredential.
 528  634       *
 529  635       * @return a hashCode value
 530  636       */
 531  637      public int hashCode() {
 532  638  
 533  639          if (destroyed) {
 534  640              throw new IllegalStateException("This credential is " +
 535  641                                          "no longer valid");
 536  642          }
 537  643  
 538  644          // NOTE: The specification does not define the criteria to compare
 539  645          // credentials.
 540  646          /*
 541  647           * XXX
 542  648           * Decide on a criteria for equals first then do this.
 543  649           */
 544  650          return 1;
 545  651      }
 546  652  
 547  653      /**
 548  654       * Returns the specified mechanism's credential-element.
 549  655       *
 550  656       * @param mechOid the oid for mechanism to retrieve
 551  657       * @param initiate boolean indicating if the function is
 552  658       *    to throw exception or return null when element is not
 553  659       *    found.
 554  660       * @return mechanism credential object
 555  661       * @exception GSSException of invalid mechanism
 556  662       */
 557  663      public GSSCredentialSpi getElement(Oid mechOid, boolean initiate)
 558  664          throws GSSException {
 559  665  
 560  666          if (destroyed) {
 561  667              throw new IllegalStateException("This credential is " +
 562  668                                          "no longer valid");
 563  669          }
 564  670  
 565  671          SearchKey key;
 566  672          GSSCredentialSpi element;
 567  673  
 568  674          if (mechOid == null) {
 569  675              /*
 570  676               * First see if the default mechanism satisfies the
 571  677               * desired usage.
 572  678               */
 573  679              mechOid = ProviderList.DEFAULT_MECH_OID;
 574  680              key = new SearchKey(mechOid,
 575  681                                   initiate? INITIATE_ONLY : ACCEPT_ONLY);
 576  682              element = hashtable.get(key);
 577  683              if (element == null) {
 578  684                  key = new SearchKey(mechOid, INITIATE_AND_ACCEPT);
 579  685                  element = hashtable.get(key);
 580  686                  if (element == null) {
 581  687                      /*
 582  688                       * Now just return any element that satisfies the
 583  689                       * desired usage.
 584  690                       */
 585  691                      Object[] elements = hashtable.entrySet().toArray();
 586  692                      for (int i = 0; i &lt; elements.length; i++) {
 587  693                          element = (GSSCredentialSpi)
 588  694                              ((Map.Entry)elements[i]).getValue();
 589  695                          if (element.isInitiatorCredential() == initiate)
 590  696                              break;
 591  697                      } // for loop
 592  698                  }
 593  699              }
 594  700          } else {
 595  701  
 596  702              if (initiate)
 597  703                  key = new SearchKey(mechOid, INITIATE_ONLY);
 598  704              else
 599  705                  key = new SearchKey(mechOid, ACCEPT_ONLY);
 600  706  
 601  707              element = hashtable.get(key);
 602  708  
 603  709              if (element == null) {
 604  710                  key = new SearchKey(mechOid, INITIATE_AND_ACCEPT);
 605  711                  element = hashtable.get(key);
 606  712              }
 607  713          }
 608  714  
 609  715          if (element == null)
 610  716              throw new GSSExceptionImpl(GSSException.NO_CRED,
 611  717                                         "No credential found for: " +
 612  718                                         getElementStr(mechOid,
 613  719                                         initiate? INITIATE_ONLY : ACCEPT_ONLY));
 614  720          return element;
 615  721      }
 616  722  
 617  723      Set&lt;GSSCredentialSpi&gt; getElements() {
 618  724          HashSet&lt;GSSCredentialSpi&gt; retVal =
 619  725                          new HashSet&lt;GSSCredentialSpi&gt;(hashtable.size());
 620  726          Enumeration&lt;GSSCredentialSpi&gt; values = hashtable.elements();
 621  727          while (values.hasMoreElements()) {
 622  728              GSSCredentialSpi o = values.nextElement();
 623  729              retVal.add(o);
 624  730          }
 625  731          return retVal;
 626  732      }
 627  733  
 628  734      private static String getElementStr(Oid mechOid, int usage) {
 629  735          String displayString = mechOid.toString();
 630  736          if (usage == GSSCredential.INITIATE_ONLY) {
 631  737              displayString =
</pre>
<table id='hb-elided4' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided4", "hb-elided4", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">140 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided4", "hb-elided4", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre> 632  738                  displayString.concat(" usage: Initiate");
 633  739          } else if (usage == GSSCredential.ACCEPT_ONLY) {
 634  740              displayString =
 635  741                  displayString.concat(" usage: Accept");
 636  742          } else {
 637  743              displayString =
 638  744                  displayString.concat(" usage: Initiate and Accept");
 639  745          }
 640  746          return displayString;
 641  747      }
<span class='added'>      748 +
      749 +    public void storeInto(int usage, Oid mech,
      750 +                          boolean overwrite, boolean defaultCred,
      751 +                          Map&lt;String,String&gt; store) throws GSSException {
      752 +        if (destroyed) {
      753 +            throw new IllegalStateException("This credential is " +
      754 +                                            "no longer valid");
      755 +        }
      756 +
      757 +        SearchKey key = null;
      758 +        GSSCredentialSpi element = null;
      759 +
      760 +        if (mech == null) {
      761 +            mech = ProviderList.DEFAULT_MECH_OID;
      762 +        }
      763 +
      764 +        key = new SearchKey(mech, usage);
      765 +        element = hashtable.get(key);
      766 +        if (element == null) {
      767 +            throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
      768 +        }
      769 +
      770 +        element.storeInto(usage, overwrite, defaultCred, store);
      771 +    }
      772 +
</span> 642  773  
 643  774      public String toString() {
 644  775  
 645  776          if (destroyed) {
 646  777              throw new IllegalStateException("This credential is " +
 647  778                                          "no longer valid");
 648  779          }
 649  780  
 650  781          GSSCredentialSpi element = null;
 651  782          StringBuilder sb = new StringBuilder("[GSSCredential: ");
</pre>
<pre id='elided5' class='elided' style='display: none'> 652  783          Object[] elements = hashtable.entrySet().toArray();
 653  784          for (int i = 0; i &lt; elements.length; i++) {
 654  785              try {
 655  786                  sb.append('\n');
 656  787                  element = (GSSCredentialSpi)
 657  788                      ((Map.Entry)elements[i]).getValue();
 658  789                  sb.append(element.getName());
 659  790                  sb.append(' ');
 660  791                  sb.append(element.getMechanism());
 661  792                  sb.append(element.isInitiatorCredential() ?
 662  793                            " Initiate" : "");
 663  794                  sb.append(element.isAcceptorCredential() ?
 664  795                            " Accept" : "");
 665  796                  sb.append(" [");
 666  797                  sb.append(element.getClass());
 667  798                  sb.append(']');
 668  799              } catch (GSSException e) {
 669  800                  // skip to next element
 670  801              }
 671  802          }
 672  803          sb.append(']');
 673  804          return sb.toString();
 674  805      }
 675  806  
 676  807      static class SearchKey {
 677  808          private Oid mechOid = null;
 678  809          private int usage = GSSCredential.INITIATE_AND_ACCEPT;
 679  810          public SearchKey(Oid mechOid, int usage) {
 680  811  
 681  812              this.mechOid = mechOid;
 682  813              this.usage = usage;
 683  814          }
 684  815          public Oid getMech() {
 685  816              return mechOid;
 686  817          }
 687  818          public int getUsage() {
 688  819              return usage;
 689  820          }
 690  821          public boolean equals(Object other) {
 691  822              if (! (other instanceof SearchKey))
 692  823                  return false;
 693  824              SearchKey that = (SearchKey) other;
 694  825              return ((this.mechOid.equals(that.mechOid)) &amp;&amp;
 695  826                      (this.usage == that.usage));
 696  827          }
 697  828          public int hashCode() {
 698  829              return mechOid.hashCode();
 699  830          }
 700  831      }
 701  832  
 702  833  }
</pre>
<table id='hb-elided5' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided5", "hb-elided5", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">51 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided5", "hb-elided5", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre id='linerefpre'><span id='lineref'>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></pre>
    <br clear="all" />
    <br />

    <script type="text/javascript">
      /* Assign event handlers and widths. */
      var w = document.getElementById('lineref').offsetWidth;
      for (var i = 1; i <= 5; ++i) {
	      var e = document.getElementById("elided" + i);
	      e.onclick = handle_click;
              e.style.setProperty('width', w + "px", '');

	      e = document.getElementById("hb-elided" + i);
              e.style.setProperty('width', w + "px", '');
      }

      /* Hide our line size reference. */
      document.getElementById('linerefpre').style.setProperty('display',
          'none', '');

      /* Scroll as indicated. */
      str = location.search;
      s = str.substring(1, str.length);
      if (s > 0)
        window.scroll(0, s);

      function open_or_close_all(open) {
	      for (var i = 1; i <= 5; ++i) {
		      var e = document.getElementById("hb-elided" + i);
		      e.style.setProperty("display", open ? "none" : "", "");

		      e = document.getElementById("elided" + i);
		      e.style.setProperty("display", open ? "" : "none", "");
	      }
      }
    </script>
  </body>
</html>
