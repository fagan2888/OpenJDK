<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>ws New src/java.security.jgss/share/classes/sun/security/jgss/GSSCredentialImpl.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.jgss;
  27 
  28 import org.ietf.jgss.*;
  29 import sun.security.jgss.spi.*;
  30 
  31 import java.util.*;
  32 import sun.security.jgss.spnego.SpNegoCredElement;
  33 
  34 public class GSSCredentialImpl implements GSSCredential {
  35 
  36     private GSSManagerImpl gssManager = null;
  37     private boolean destroyed = false;
  38 
  39     /*
  40      * We store all elements in a hashtable, using &lt;oid, usage&gt; as the
  41      * key. This makes it easy to locate the specific kind of credential we
  42      * need. The implementation needs to be optimized for the case where
  43      * there is just one element (tempCred).
  44      */
  45     private Hashtable&lt;SearchKey, GSSCredentialSpi&gt; hashtable = null;
  46 
  47     // XXX Optimization for single mech usage
  48     private GSSCredentialSpi tempCred = null;
  49 
  50     public GSSCredentialImpl() {
  51         // Useless
  52     }
  53 
  54     // Used by new ExtendedGSSCredential.ExtendedGSSCredentialImpl(cred)
  55     protected GSSCredentialImpl(GSSCredentialImpl src) {
  56         this.gssManager = src.gssManager;
  57         this.destroyed = src.destroyed;
  58         this.hashtable = src.hashtable;
  59         this.tempCred = src.tempCred;
  60     }
  61 
  62     GSSCredentialImpl(GSSManagerImpl gssManager, int usage)
  63         throws GSSException {
  64         this(gssManager, null, GSSCredential.DEFAULT_LIFETIME,
  65              (Oid[]) null, usage);
  66     }
  67 
  68     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
  69                       int lifetime, Oid mech, int usage)
  70         throws GSSException {
  71         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
  72 
  73         init(gssManager);
  74         String password = null;
  75         add(name, password, lifetime, lifetime, mech, usage);
  76     }
  77 
  78     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
  79                       Map&lt;String,String&gt; store, int lifetime, Oid mech,
  80                       int usage)
  81         throws GSSException {
  82         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
  83 
  84         init(gssManager);
  85         add(name, store, lifetime, lifetime, mech, usage);
  86     }
  87 
  88     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name, String password,
  89                       int lifetime, Oid mech, int usage)
  90         throws GSSException {
  91         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
  92 
  93         init(gssManager);
  94         add(name, password, lifetime, lifetime, mech, usage);
  95     }
  96 
  97     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
  98                       int lifetime, Oid[] mechs, int usage)
  99         throws GSSException {
 100         this(gssManager, name, (String)null, lifetime, mechs, usage);
 101     }
 102 
 103     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
 104                       Map&lt;String,String&gt; store, int lifetime,
 105                       Oid mechs[], int usage)
 106         throws GSSException {
 107         init(gssManager);
 108         boolean defaultList = false;
 109         if (mechs == null) {
 110             mechs = gssManager.getMechs();
 111             defaultList = true;
 112         }
 113 
 114         for (int i = 0; i &lt; mechs.length; i++) {
 115             try {
 116                 add(name, store, lifetime, lifetime, mechs[i], usage);
 117             } catch (GSSException e) {
 118                 if (defaultList) {
 119                     // Try the next mechanism
 120                     GSSUtil.debug("Ignore " + e + " while acquring cred for "
 121                         + mechs[i]);
 122                     //e.printStackTrace();
 123                 } else throw e; // else try the next mechanism
 124             }
 125         }
 126         if ((hashtable.size() == 0) || (usage != getUsage()))
 127             throw new GSSException(GSSException.NO_CRED);
 128     }
 129 
 130     GSSCredentialImpl(GSSManagerImpl gssManager, GSSName name,
 131                       String password, int lifetime, Oid mechs[], int usage)
 132         throws GSSException {
 133         init(gssManager);
 134         boolean defaultList = false;
 135         if (mechs == null) {
 136             mechs = gssManager.getMechs();
 137             defaultList = true;
 138         }
 139 
 140         for (int i = 0; i &lt; mechs.length; i++) {
 141             try {
 142                 add(name, password, lifetime, lifetime, mechs[i], usage);
 143             } catch (GSSException e) {
 144                 if (defaultList) {
 145                     // Try the next mechanism
 146                     GSSUtil.debug("Ignore " + e + " while acquring cred for "
 147                         + mechs[i]);
 148                     //e.printStackTrace();
 149                 } else throw e; // else try the next mechanism
 150             }
 151         }
 152         if ((hashtable.size() == 0) || (usage != getUsage()))
 153             throw new GSSException(GSSException.NO_CRED);
 154     }
 155 
 156     // Wrap a mech cred into a GSS cred
 157     public GSSCredentialImpl(GSSManagerImpl gssManager,
 158                       GSSCredentialSpi mechElement) throws GSSException {
 159 
 160         init(gssManager);
 161         int usage = GSSCredential.ACCEPT_ONLY;
 162         if (mechElement.isInitiatorCredential()) {
 163             if (mechElement.isAcceptorCredential()) {
 164                 usage = GSSCredential.INITIATE_AND_ACCEPT;
 165             } else {
 166                 usage = GSSCredential.INITIATE_ONLY;
 167             }
 168         }
 169         SearchKey key = new SearchKey(mechElement.getMechanism(),
 170                                         usage);
 171         tempCred = mechElement;
 172         hashtable.put(key, tempCred);
 173         // More mechs that can use this cred, say, SPNEGO
 174         if (!GSSUtil.isSpNegoMech(mechElement.getMechanism())) {
 175             key = new SearchKey(GSSUtil.GSS_SPNEGO_MECH_OID, usage);
 176             hashtable.put(key, new SpNegoCredElement(mechElement));
 177         }
 178     }
 179 
 180     void init(GSSManagerImpl gssManager) {
 181         this.gssManager = gssManager;
 182         hashtable = new Hashtable&lt;SearchKey, GSSCredentialSpi&gt;(
 183                                                 gssManager.getMechs().length);
 184     }
 185 
 186     public void dispose() throws GSSException {
 187         if (!destroyed) {
 188             GSSCredentialSpi element;
 189             Enumeration&lt;GSSCredentialSpi&gt; values = hashtable.elements();
 190             while (values.hasMoreElements()) {
 191                 element = values.nextElement();
 192                 element.dispose();
 193             }
 194             destroyed = true;
 195         }
 196     }
 197 
 198     public GSSCredential impersonate(GSSName name) throws GSSException {
 199         if (destroyed) {
 200             throw new IllegalStateException("This credential is " +
 201                                         "no longer valid");
 202         }
 203         Oid mech = tempCred.getMechanism();
 204         GSSNameSpi nameElement = (name == null ? null :
 205                                   ((GSSNameImpl)name).getElement(mech));
 206         GSSCredentialSpi cred = tempCred.impersonate(nameElement);
 207         return (cred == null ?
 208             null : GSSManagerImpl.wrap(new GSSCredentialImpl(gssManager, cred)));
 209     }
 210 
 211     public GSSName getName() throws GSSException {
 212         if (destroyed) {
 213             throw new IllegalStateException("This credential is " +
 214                                         "no longer valid");
 215         }
 216         return GSSNameImpl.wrapElement(gssManager, tempCred.getName());
 217     }
 218 
 219     public GSSName getName(Oid mech) throws GSSException {
 220 
 221         if (destroyed) {
 222             throw new IllegalStateException("This credential is " +
 223                                         "no longer valid");
 224         }
 225 
 226         SearchKey key = null;
 227         GSSCredentialSpi element = null;
 228 
 229         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 230 
 231         key = new SearchKey(mech, GSSCredential.INITIATE_ONLY);
 232         element = hashtable.get(key);
 233 
 234         if (element == null) {
 235             key = new SearchKey(mech, GSSCredential.ACCEPT_ONLY);
 236             element = hashtable.get(key);
 237         }
 238 
 239         if (element == null) {
 240             key = new SearchKey(mech, GSSCredential.INITIATE_AND_ACCEPT);
 241             element = hashtable.get(key);
 242         }
 243 
 244         if (element == null) {
 245             throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 246         }
 247 
 248         return GSSNameImpl.wrapElement(gssManager, element.getName());
 249 
 250     }
 251 
 252     /**
 253      * Returns the remaining lifetime of this credential. The remaining
 254      * lifetime is defined as the minimum lifetime, either for initiate or
 255      * for accept, across all elements contained in it. Not terribly
 256      * useful, but required by GSS-API.
 257      */
 258     public int getRemainingLifetime() throws GSSException {
 259 
 260         if (destroyed) {
 261             throw new IllegalStateException("This credential is " +
 262                                         "no longer valid");
 263         }
 264 
 265         SearchKey tempKey;
 266         GSSCredentialSpi tempCred;
 267         int tempLife = 0, tempInitLife = 0, tempAcceptLife = 0;
 268         int min = INDEFINITE_LIFETIME;
 269 
 270         for (Enumeration&lt;SearchKey&gt; e = hashtable.keys();
 271                                         e.hasMoreElements(); ) {
 272             tempKey = e.nextElement();
 273             tempCred = hashtable.get(tempKey);
 274             if (tempKey.getUsage() == INITIATE_ONLY)
 275                 tempLife = tempCred.getInitLifetime();
 276             else if (tempKey.getUsage() == ACCEPT_ONLY)
 277                 tempLife = tempCred.getAcceptLifetime();
 278             else {
 279                 tempInitLife = tempCred.getInitLifetime();
 280                 tempAcceptLife = tempCred.getAcceptLifetime();
 281                 tempLife = (tempInitLife &lt; tempAcceptLife ?
 282                             tempInitLife:
 283                             tempAcceptLife);
 284             }
 285             if (min &gt; tempLife)
 286                 min = tempLife;
 287         }
 288 
 289         return min;
 290     }
 291 
 292     public int getRemainingInitLifetime(Oid mech) throws GSSException {
 293 
 294         if (destroyed) {
 295             throw new IllegalStateException("This credential is " +
 296                                         "no longer valid");
 297         }
 298 
 299         GSSCredentialSpi element = null;
 300         SearchKey key = null;
 301         boolean found = false;
 302         int max = 0;
 303 
 304         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 305 
 306         key = new SearchKey(mech, GSSCredential.INITIATE_ONLY);
 307         element = hashtable.get(key);
 308 
 309         if (element != null) {
 310             found = true;
 311             if (max &lt; element.getInitLifetime())
 312                 max = element.getInitLifetime();
 313         }
 314 
 315         key = new SearchKey(mech, GSSCredential.INITIATE_AND_ACCEPT);
 316         element = hashtable.get(key);
 317 
 318         if (element != null) {
 319             found = true;
 320             if (max &lt; element.getInitLifetime())
 321                 max = element.getInitLifetime();
 322         }
 323 
 324         if (!found) {
 325             throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 326         }
 327 
 328         return max;
 329 
 330     }
 331 
 332     public int getRemainingAcceptLifetime(Oid mech) throws GSSException {
 333 
 334         if (destroyed) {
 335             throw new IllegalStateException("This credential is " +
 336                                         "no longer valid");
 337         }
 338 
 339         GSSCredentialSpi element = null;
 340         SearchKey key = null;
 341         boolean found = false;
 342         int max = 0;
 343 
 344         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 345 
 346         key = new SearchKey(mech, GSSCredential.ACCEPT_ONLY);
 347         element = hashtable.get(key);
 348 
 349         if (element != null) {
 350             found = true;
 351             if (max &lt; element.getAcceptLifetime())
 352                 max = element.getAcceptLifetime();
 353         }
 354 
 355         key = new SearchKey(mech, GSSCredential.INITIATE_AND_ACCEPT);
 356         element = hashtable.get(key);
 357 
 358         if (element != null) {
 359             found = true;
 360             if (max &lt; element.getAcceptLifetime())
 361                 max = element.getAcceptLifetime();
 362         }
 363 
 364         if (!found) {
 365             throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 366         }
 367 
 368         return max;
 369 
 370     }
 371 
 372     /**
 373      * Returns the usage mode for this credential. Returns
 374      * INITIATE_AND_ACCEPT if any one element contained in it supports
 375      * INITIATE_AND_ACCEPT or if two different elements exist where one
 376      * support INITIATE_ONLY and the other supports ACCEPT_ONLY.
 377      */
 378     public int getUsage() throws GSSException {
 379 
 380         if (destroyed) {
 381             throw new IllegalStateException("This credential is " +
 382                                         "no longer valid");
 383         }
 384 
 385         SearchKey tempKey;
 386         boolean initiate = false;
 387         boolean accept = false;
 388 
 389         for (Enumeration&lt;SearchKey&gt; e = hashtable.keys();
 390                                         e.hasMoreElements(); ) {
 391             tempKey = e.nextElement();
 392             if (tempKey.getUsage() == INITIATE_ONLY)
 393                 initiate = true;
 394             else if (tempKey.getUsage() == ACCEPT_ONLY)
 395                 accept = true;
 396             else
 397                 return INITIATE_AND_ACCEPT;
 398         }
 399         if (initiate) {
 400             if (accept)
 401                 return INITIATE_AND_ACCEPT;
 402             else
 403                 return INITIATE_ONLY;
 404         } else
 405             return ACCEPT_ONLY;
 406     }
 407 
 408     public int getUsage(Oid mech) throws GSSException {
 409 
 410         if (destroyed) {
 411             throw new IllegalStateException("This credential is " +
 412                                         "no longer valid");
 413         }
 414 
 415         GSSCredentialSpi element = null;
 416         SearchKey key = null;
 417         boolean initiate = false;
 418         boolean accept = false;
 419 
 420         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 421 
 422         key = new SearchKey(mech, GSSCredential.INITIATE_ONLY);
 423         element = hashtable.get(key);
 424 
 425         if (element != null) {
 426             initiate = true;
 427         }
 428 
 429         key = new SearchKey(mech, GSSCredential.ACCEPT_ONLY);
 430         element = hashtable.get(key);
 431 
 432         if (element != null) {
 433             accept = true;
 434         }
 435 
 436         key = new SearchKey(mech, GSSCredential.INITIATE_AND_ACCEPT);
 437         element = hashtable.get(key);
 438 
 439         if (element != null) {
 440             initiate = true;
 441             accept = true;
 442         }
 443 
 444         if (initiate &amp;&amp; accept)
 445             return GSSCredential.INITIATE_AND_ACCEPT;
 446         else if (initiate)
 447             return GSSCredential.INITIATE_ONLY;
 448         else if (accept)
 449             return GSSCredential.ACCEPT_ONLY;
 450         else {
 451             throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 452         }
 453     }
 454 
 455     public Oid[] getMechs() throws GSSException {
 456 
 457         if (destroyed) {
 458             throw new IllegalStateException("This credential is " +
 459                                         "no longer valid");
 460         }
 461         Vector&lt;Oid&gt; result = new Vector&lt;Oid&gt;(hashtable.size());
 462 
 463         for (Enumeration&lt;SearchKey&gt; e = hashtable.keys();
 464                                                 e.hasMoreElements(); ) {
 465             SearchKey tempKey = e.nextElement();
 466             result.addElement(tempKey.getMech());
 467         }
 468         return result.toArray(new Oid[0]);
 469     }
 470 
 471     public void add(GSSName name, int initLifetime, int acceptLifetime,
 472                     Oid mech, int usage) throws GSSException {
 473         String password = null;
 474         add(name, password, initLifetime, acceptLifetime, mech, usage);
 475     }
 476 
 477     public void add(GSSName name, Map&lt;String,String&gt; store, int initLifetime,
 478                     int acceptLifetime, Oid mech, int usage)
 479                     throws GSSException {
 480         add(name, (String)null, store, initLifetime, acceptLifetime,
 481             mech, usage);
 482     }
 483 
 484     public void add(GSSName name, String password, int initLifetime,
 485                     int acceptLifetime, Oid mech, int usage)
 486                     throws GSSException {
 487         add(name, password, (Map&lt;String,String&gt;)null, initLifetime,
 488             acceptLifetime, mech, usage);
 489     }
 490 
 491     private void add(GSSName name, String password, Map&lt;String,String&gt; store,
 492                     int initLifetime, int acceptLifetime, Oid mech, int usage)
 493                     throws GSSException {
 494 
 495         if (destroyed) {
 496             throw new IllegalStateException("This credential is " +
 497                                         "no longer valid");
 498         }
 499         if (mech == null) mech = ProviderList.DEFAULT_MECH_OID;
 500 
 501         SearchKey key = new SearchKey(mech, usage);
 502         if (hashtable.containsKey(key)) {
 503             throw new GSSExceptionImpl(GSSException.DUPLICATE_ELEMENT,
 504                                        "Duplicate element found: " +
 505                                        getElementStr(mech, usage));
 506         }
 507 
 508         // XXX If not instance of GSSNameImpl then throw exception
 509         // Application mixing GSS implementations
 510         GSSNameSpi nameElement = (name == null ? null :
 511                                   ((GSSNameImpl)name).getElement(mech));
 512 
 513         if (password == null &amp;&amp; store == null) {
 514             tempCred = gssManager.getCredentialElement(nameElement,
 515                                                        initLifetime,
 516                                                        acceptLifetime,
 517                                                        mech,
 518                                                        usage);
 519         } else if (password != null) {
 520             tempCred = gssManager.getCredentialElement(nameElement,
 521                                                        password,
 522                                                        initLifetime,
 523                                                        acceptLifetime,
 524                                                        mech,
 525                                                        usage);
 526         } else {
 527             tempCred = gssManager.getCredentialElement(nameElement,
 528                                                        store,
 529                                                        initLifetime,
 530                                                        acceptLifetime,
 531                                                        mech,
 532                                                        usage);
 533         }
 534         /*
 535          * Not all mechanisms support the concept of one credential element
 536          * that can be used for both initiating and accepting a context. In
 537          * the event that an application requests usage INITIATE_AND_ACCEPT
 538          * for a credential from such a mechanism, the GSS framework will
 539          * need to obtain two different credential elements from the
 540          * mechanism, one that will have usage INITIATE_ONLY and another
 541          * that will have usage ACCEPT_ONLY. The mechanism will help the
 542          * GSS-API realize this by returning a credential element with
 543          * usage INITIATE_ONLY or ACCEPT_ONLY prompting it to make another
 544          * call to getCredentialElement, this time with the other usage
 545          * mode.
 546          */
 547 
 548         if (tempCred != null) {
 549             if (usage == GSSCredential.INITIATE_AND_ACCEPT &amp;&amp;
 550                 (!tempCred.isAcceptorCredential() ||
 551                 !tempCred.isInitiatorCredential())) {
 552 
 553                 int currentUsage;
 554                 int desiredUsage;
 555 
 556                 if (!tempCred.isInitiatorCredential()) {
 557                     currentUsage = GSSCredential.ACCEPT_ONLY;
 558                     desiredUsage = GSSCredential.INITIATE_ONLY;
 559                 } else {
 560                     currentUsage = GSSCredential.INITIATE_ONLY;
 561                     desiredUsage = GSSCredential.ACCEPT_ONLY;
 562                 }
 563 
 564                 key = new SearchKey(mech, currentUsage);
 565                 hashtable.put(key, tempCred);
 566 
 567                 if (store == null &amp;&amp; password == null) {
 568                     tempCred = gssManager.getCredentialElement(nameElement,
 569                                                                initLifetime,
 570                                                                acceptLifetime,
 571                                                                mech,
 572                                                                desiredUsage);
 573                 } else if (password != null) {
 574                     tempCred = gssManager.getCredentialElement(nameElement,
 575                                                                password,
 576                                                                initLifetime,
 577                                                                acceptLifetime,
 578                                                                mech,
 579                                                                desiredUsage);
 580                 } else {
 581                     tempCred = gssManager.getCredentialElement(nameElement,
 582                                                                store,
 583                                                                initLifetime,
 584                                                                acceptLifetime,
 585                                                                mech,
 586                                                                desiredUsage);
 587                 }
 588 
 589                 key = new SearchKey(mech, desiredUsage);
 590                 hashtable.put(key, tempCred);
 591             } else {
 592                 hashtable.put(key, tempCred);
 593             }
 594         }
 595     }
 596 
 597     public boolean equals(Object another) {
 598 
 599         if (destroyed) {
 600             throw new IllegalStateException("This credential is " +
 601                                         "no longer valid");
 602         }
 603 
 604         if (this == another) {
 605             return true;
 606         }
 607 
 608         if (!(another instanceof GSSCredentialImpl)) {
 609             return false;
 610         }
 611 
 612         // NOTE: The specification does not define the criteria to compare
 613         // credentials.
 614         /*
 615          * XXX
 616          * The RFC says: "Tests if this GSSCredential refers to the same
 617          * entity as the supplied object.  The two credentials must be
 618          * acquired over the same mechanisms and must refer to the same
 619          * principal.  Returns "true" if the two GSSCredentials refer to
 620          * the same entity; "false" otherwise."
 621          *
 622          * Well, when do two credentials refer to the same principal? Do
 623          * they need to have one GSSName in common for the different
 624          * GSSName's that the credential elements return? Or do all
 625          * GSSName's have to be in common when the names are exported with
 626          * their respective mechanisms for the credential elements?
 627          */
 628         return false;
 629 
 630     }
 631 
 632     /**
 633      * Returns a hashcode value for this GSSCredential.
 634      *
 635      * @return a hashCode value
 636      */
 637     public int hashCode() {
 638 
 639         if (destroyed) {
 640             throw new IllegalStateException("This credential is " +
 641                                         "no longer valid");
 642         }
 643 
 644         // NOTE: The specification does not define the criteria to compare
 645         // credentials.
 646         /*
 647          * XXX
 648          * Decide on a criteria for equals first then do this.
 649          */
 650         return 1;
 651     }
 652 
 653     /**
 654      * Returns the specified mechanism's credential-element.
 655      *
 656      * @param mechOid the oid for mechanism to retrieve
 657      * @param initiate boolean indicating if the function is
 658      *    to throw exception or return null when element is not
 659      *    found.
 660      * @return mechanism credential object
 661      * @exception GSSException of invalid mechanism
 662      */
 663     public GSSCredentialSpi getElement(Oid mechOid, boolean initiate)
 664         throws GSSException {
 665 
 666         if (destroyed) {
 667             throw new IllegalStateException("This credential is " +
 668                                         "no longer valid");
 669         }
 670 
 671         SearchKey key;
 672         GSSCredentialSpi element;
 673 
 674         if (mechOid == null) {
 675             /*
 676              * First see if the default mechanism satisfies the
 677              * desired usage.
 678              */
 679             mechOid = ProviderList.DEFAULT_MECH_OID;
 680             key = new SearchKey(mechOid,
 681                                  initiate? INITIATE_ONLY : ACCEPT_ONLY);
 682             element = hashtable.get(key);
 683             if (element == null) {
 684                 key = new SearchKey(mechOid, INITIATE_AND_ACCEPT);
 685                 element = hashtable.get(key);
 686                 if (element == null) {
 687                     /*
 688                      * Now just return any element that satisfies the
 689                      * desired usage.
 690                      */
 691                     Object[] elements = hashtable.entrySet().toArray();
 692                     for (int i = 0; i &lt; elements.length; i++) {
 693                         element = (GSSCredentialSpi)
 694                             ((Map.Entry)elements[i]).getValue();
 695                         if (element.isInitiatorCredential() == initiate)
 696                             break;
 697                     } // for loop
 698                 }
 699             }
 700         } else {
 701 
 702             if (initiate)
 703                 key = new SearchKey(mechOid, INITIATE_ONLY);
 704             else
 705                 key = new SearchKey(mechOid, ACCEPT_ONLY);
 706 
 707             element = hashtable.get(key);
 708 
 709             if (element == null) {
 710                 key = new SearchKey(mechOid, INITIATE_AND_ACCEPT);
 711                 element = hashtable.get(key);
 712             }
 713         }
 714 
 715         if (element == null)
 716             throw new GSSExceptionImpl(GSSException.NO_CRED,
 717                                        "No credential found for: " +
 718                                        getElementStr(mechOid,
 719                                        initiate? INITIATE_ONLY : ACCEPT_ONLY));
 720         return element;
 721     }
 722 
 723     Set&lt;GSSCredentialSpi&gt; getElements() {
 724         HashSet&lt;GSSCredentialSpi&gt; retVal =
 725                         new HashSet&lt;GSSCredentialSpi&gt;(hashtable.size());
 726         Enumeration&lt;GSSCredentialSpi&gt; values = hashtable.elements();
 727         while (values.hasMoreElements()) {
 728             GSSCredentialSpi o = values.nextElement();
 729             retVal.add(o);
 730         }
 731         return retVal;
 732     }
 733 
 734     private static String getElementStr(Oid mechOid, int usage) {
 735         String displayString = mechOid.toString();
 736         if (usage == GSSCredential.INITIATE_ONLY) {
 737             displayString =
 738                 displayString.concat(" usage: Initiate");
 739         } else if (usage == GSSCredential.ACCEPT_ONLY) {
 740             displayString =
 741                 displayString.concat(" usage: Accept");
 742         } else {
 743             displayString =
 744                 displayString.concat(" usage: Initiate and Accept");
 745         }
 746         return displayString;
 747     }
 748 
 749     public void storeInto(int usage, Oid mech,
 750                           boolean overwrite, boolean defaultCred,
 751                           Map&lt;String,String&gt; store) throws GSSException {
 752         if (destroyed) {
 753             throw new IllegalStateException("This credential is " +
 754                                             "no longer valid");
 755         }
 756 
 757         SearchKey key = null;
 758         GSSCredentialSpi element = null;
 759 
 760         if (mech == null) {
 761             mech = ProviderList.DEFAULT_MECH_OID;
 762         }
 763 
 764         key = new SearchKey(mech, usage);
 765         element = hashtable.get(key);
 766         if (element == null) {
 767             throw new GSSExceptionImpl(GSSException.BAD_MECH, mech);
 768         }
 769 
 770         element.storeInto(usage, overwrite, defaultCred, store);
 771     }
 772 
 773 
 774     public String toString() {
 775 
 776         if (destroyed) {
 777             throw new IllegalStateException("This credential is " +
 778                                         "no longer valid");
 779         }
 780 
 781         GSSCredentialSpi element = null;
 782         StringBuilder sb = new StringBuilder("[GSSCredential: ");
 783         Object[] elements = hashtable.entrySet().toArray();
 784         for (int i = 0; i &lt; elements.length; i++) {
 785             try {
 786                 sb.append('\n');
 787                 element = (GSSCredentialSpi)
 788                     ((Map.Entry)elements[i]).getValue();
 789                 sb.append(element.getName());
 790                 sb.append(' ');
 791                 sb.append(element.getMechanism());
 792                 sb.append(element.isInitiatorCredential() ?
 793                           " Initiate" : "");
 794                 sb.append(element.isAcceptorCredential() ?
 795                           " Accept" : "");
 796                 sb.append(" [");
 797                 sb.append(element.getClass());
 798                 sb.append(']');
 799             } catch (GSSException e) {
 800                 // skip to next element
 801             }
 802         }
 803         sb.append(']');
 804         return sb.toString();
 805     }
 806 
 807     static class SearchKey {
 808         private Oid mechOid = null;
 809         private int usage = GSSCredential.INITIATE_AND_ACCEPT;
 810         public SearchKey(Oid mechOid, int usage) {
 811 
 812             this.mechOid = mechOid;
 813             this.usage = usage;
 814         }
 815         public Oid getMech() {
 816             return mechOid;
 817         }
 818         public int getUsage() {
 819             return usage;
 820         }
 821         public boolean equals(Object other) {
 822             if (! (other instanceof SearchKey))
 823                 return false;
 824             SearchKey that = (SearchKey) other;
 825             return ((this.mechOid.equals(that.mechOid)) &amp;&amp;
 826                     (this.usage == that.usage));
 827         }
 828         public int hashCode() {
 829             return mechOid.hashCode();
 830         }
 831     }
 832 
 833 }
</pre></body></html>
