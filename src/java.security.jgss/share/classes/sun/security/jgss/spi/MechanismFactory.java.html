<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>ws New src/java.security.jgss/share/classes/sun/security/jgss/spi/MechanismFactory.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.jgss.spi;
  27 
  28 import org.ietf.jgss.*;
  29 import java.security.Provider;
  30 import java.util.Map;
  31 
  32 /**
  33  * This interface is implemented by the factory class for every
  34  * plugin mechanism. The GSSManager locates an implementation of this
  35  * interface by querying the security providers installed on the
  36  * system. For a provider to support a mechanism defined by Oid x.y.z,
  37  * the provider master file would have to contain a mapping from the
  38  * property "GssApiMechanism.x.y.z" to an implementation class that serves
  39  * as the factory for that mechanism.
  40  * &lt;p&gt;
  41  * e.g., If a provider master file contained the a mapping from the
  42  * property "GssApiMechanism.1.2.840.113554.1.2.2" to the class name
  43  * "com.foo.krb5.Krb5GssFactory", then the GSS-API framework would assume
  44  * that com.foo.krb5.Krb5GssFactory implements the MechanismFactory
  45  * interface and that it can be used to obtain elements required by for
  46  * supporting this mechanism.
  47  *
  48  * @author Mayank Upadhyay
  49  */
  50 
  51 public interface MechanismFactory {
  52 
  53     /**
  54      * Returns the Oid of the mechanism that this factory supports.
  55      * @return the Oid
  56      */
  57     public Oid getMechanismOid();
  58 
  59     /**
  60      * Returns the provider that this factory came from.
  61      * @return the provider
  62      */
  63     public Provider getProvider();
  64 
  65     /**
  66      * Returns the GSS-API nametypes that this mechanism can
  67      * support. Having this method helps the GSS-Framework decide quickly
  68      * if a certain mechanism can be skipped when importing a name.
  69      * @return an array of the Oid's corresponding to the different GSS-API
  70      * nametypes supported
  71      * @see org.ietf.jgss.GSSName
  72      */
  73     public Oid[] getNameTypes() throws GSSException;
  74 
  75     /**
  76      * Creates a credential element for this mechanism to be included as
  77      * part of a GSSCredential implementation. A GSSCredential is
  78      * conceptually a container class of several credential elements from
  79      * different mechanisms. A GSS-API credential can be used either for
  80      * initiating GSS security contexts or for accepting them. This method
  81      * also accepts parameters that indicate what usage is expected and how
  82      * long the life of the credential should be. It is not necessary that
  83      * the mechanism honor the request for lifetime. An application will
  84      * always query an acquired GSSCredential to determine what lifetime it
  85      * got back.&lt;p&gt;
  86      *
  87      * &lt;b&gt;Not all mechanisms support the concept of one credential element
  88      * that can be used for both initiating and accepting a context. In the
  89      * event that an application requests usage INITIATE_AND_ACCEPT for a
  90      * credential from such a mechanism, the GSS framework will need to
  91      * obtain two different credential elements from the mechanism, one
  92      * that will have usage INITIATE_ONLY and another that will have usage
  93      * ACCEPT_ONLY. The mechanism will help the GSS-API realize this by
  94      * returning a credential element with usage INITIATE_ONLY or
  95      * ACCEPT_ONLY prompting it to make another call to
  96      * getCredentialElement, this time with the other usage mode. The
  97      * mechanism indicates the missing mode by returning a 0 lifetime for
  98      * it.&lt;/b&gt;
  99      *
 100      * @param name the mechanism level name element for the entity whose
 101      * credential is desired. A null value indicates that a mechanism
 102      * dependent default choice is to be made.
 103      * @param initLifetime indicates the lifetime (in seconds) that is
 104      * requested for this credential to be used at the context initiator's
 105      * end. This value should be ignored if the usage is
 106      * ACCEPT_ONLY. Predefined contants are available in the
 107      * org.ietf.jgss.GSSCredential interface.
 108      * @param acceptLifetime indicates the lifetime (in seconds) that is
 109      * requested for this credential to be used at the context acceptor's
 110      * end. This value should be ignored if the usage is
 111      * INITIATE_ONLY. Predefined contants are available in the
 112      * org.ietf.jgss.GSSCredential interface.
 113      * @param usage One of the values GSSCredential.INIATE_ONLY,
 114      * GSSCredential.ACCEPT_ONLY, and GSSCredential.INITIATE_AND_ACCEPT.
 115      * @see org.ietf.jgss.GSSCredential
 116      * @throws GSSException if one of the error situations described in RFC
 117      * 2743 with the GSS_Acquire_Cred or GSS_Add_Cred calls occurs.
 118      */
 119     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
 120       int initLifetime, int acceptLifetime, int usage) throws GSSException;
 121 
 122     /**
 123      * Creates a credential element using a password for this mechanism to be
 124      * included as part of a GSSCredential implementation. A GSSCredential is
 125      * conceptually a container class of several credential elements from
 126      * different mechanisms. A GSS-API credential can be used either for
 127      * initiating GSS security contexts or for accepting them. This method
 128      * also accepts parameters that indicate what usage is expected and how
 129      * long the life of the credential should be. It is not necessary that
 130      * the mechanism honor the request for lifetime. An application will
 131      * always query an acquired GSSCredential to determine what lifetime it
 132      * got back.&lt;p&gt;
 133      *
 134      * &lt;b&gt;Not all mechanisms support the concept of one credential element
 135      * that can be used for both initiating and accepting a context. In the
 136      * event that an application requests usage INITIATE_AND_ACCEPT for a
 137      * credential from such a mechanism, the GSS framework will need to
 138      * obtain two different credential elements from the mechanism, one
 139      * that will have usage INITIATE_ONLY and another that will have usage
 140      * ACCEPT_ONLY. The mechanism will help the GSS-API realize this by
 141      * returning a credential element with usage INITIATE_ONLY or
 142      * ACCEPT_ONLY prompting it to make another call to
 143      * getCredentialElement, this time with the other usage mode. The
 144      * mechanism indicates the missing mode by returning a 0 lifetime for
 145      * it.&lt;/b&gt;
 146      *
 147      * @param name the mechanism level name element for the entity whose
 148      * credential is desired. A null value indicates that a mechanism
 149      * dependent default choice is to be made.
 150      * @param password is the password for the entity whose credential
 151      * is desired.
 152      * @param initLifetime indicates the lifetime (in seconds) that is
 153      * requested for this credential to be used at the context initiator's
 154      * end. This value should be ignored if the usage is
 155      * ACCEPT_ONLY. Predefined contants are available in the
 156      * org.ietf.jgss.GSSCredential interface.
 157      * @param acceptLifetime indicates the lifetime (in seconds) that is
 158      * requested for this credential to be used at the context acceptor's
 159      * end. This value should be ignored if the usage is
 160      * INITIATE_ONLY. Predefined contants are available in the
 161      * org.ietf.jgss.GSSCredential interface.
 162      * @param usage One of the values GSSCredential.INIATE_ONLY,
 163      * GSSCredential.ACCEPT_ONLY, and GSSCredential.INITIATE_AND_ACCEPT.
 164      * @see org.ietf.jgss.GSSCredential
 165      * @throws GSSException if one of the error situations described in RFC
 166      * 2743 with the GSS_Acquire_Cred or GSS_Add_Cred calls occurs.
 167      */
 168     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
 169       String password, int initLifetime, int acceptLifetime, int usage)
 170         throws GSSException;
 171 
 172     /**
 173      * Creates a credential element using a "credential store" for this
 174      * mechanism to be included as part of a GSSCredential
 175      * implementation. A GSSCredential is conceptually a container class
 176      * of several credential elements from different mechanisms. A
 177      * GSS-API credential can be used either for initiating GSS security
 178      * contexts or for accepting them. This method also accepts
 179      * parameters that indicate what usage is expected and how long the
 180      * life of the credential should be. It is not necessary that the
 181      * mechanism honor the request for lifetime. An application will
 182      * always query an acquired GSSCredential to determine what lifetime
 183      * it got back.&lt;p&gt;
 184      *
 185      * &lt;b&gt;Not all mechanisms support the concept of one credential element
 186      * that can be used for both initiating and accepting a context. In the
 187      * event that an application requests usage INITIATE_AND_ACCEPT for a
 188      * credential from such a mechanism, the GSS framework will need to
 189      * obtain two different credential elements from the mechanism, one
 190      * that will have usage INITIATE_ONLY and another that will have usage
 191      * ACCEPT_ONLY. The mechanism will help the GSS-API realize this by
 192      * returning a credential element with usage INITIATE_ONLY or
 193      * ACCEPT_ONLY prompting it to make another call to
 194      * getCredentialElement, this time with the other usage mode. The
 195      * mechanism indicates the missing mode by returning a 0 lifetime for
 196      * it.&lt;/b&gt;
 197      *
 198      * @param name the mechanism level name element for the entity whose
 199      * credential is desired. A null value indicates that a mechanism
 200      * dependent default choice is to be made.
 201      * @param store is an array of even length whose elements at even
 202      * indices are keys, and whose elements at any odd index are the
 203      * values for the preceding keys. Keys supported by mechanisms
 204      * vary. This is mostly intended for use with the platform's native
 205      * GSS-API providers. Common keys include "keytab", "client_keytab",
 206      * "ccache", and "rcache". Consult the documentation for the
 207      * platform's native GSS-API providers.
 208      * @param initLifetime indicates the lifetime (in seconds) that is
 209      * requested for this credential to be used at the context initiator's
 210      * end. This value should be ignored if the usage is
 211      * ACCEPT_ONLY. Predefined contants are available in the
 212      * org.ietf.jgss.GSSCredential interface.
 213      * @param acceptLifetime indicates the lifetime (in seconds) that is
 214      * requested for this credential to be used at the context acceptor's
 215      * end. This value should be ignored if the usage is
 216      * INITIATE_ONLY. Predefined contants are available in the
 217      * org.ietf.jgss.GSSCredential interface.
 218      * @param usage One of the values GSSCredential.INIATE_ONLY,
 219      * GSSCredential.ACCEPT_ONLY, and GSSCredential.INITIATE_AND_ACCEPT.
 220      * @see org.ietf.jgss.GSSCredential
 221      * @throws GSSException if one of the error situations described in RFC
 222      * 2743 with the GSS_Acquire_Cred or GSS_Add_Cred calls occurs.
 223      */
 224     public GSSCredentialSpi getCredentialElement(GSSNameSpi name,
 225                                                  Map&lt;String,String&gt; store,
 226                                                  int initLifetime,
 227                                                  int acceptLifetime,
 228                                                  int usage)
 229         throws GSSException;
 230 
 231     /**
 232      * Stores a credential element into a specified location.
 233      *
 234      * @param cred The credential element to store.
 235      * @param usage The credential usage to store.
 236      * @param overwrite Whether to overwrite credentials found at the specified
 237      * location.
 238      * @param @defaultCred Whether to store the credentials as the default
 239      * credentials in the specified location.
 240      * @param store The location into which to store the credentials.
 241      */
 242     default void storeCredInto(GSSCredentialSpi cred, int usage,
 243                               boolean overwrite, boolean defaultCred,
 244                               Map&lt;String,String&gt; store) throws GSSException {
 245         throw new GSSException(GSSException.UNAVAILABLE, -1,
 246                 "The " + getMechanismOid() + "mechanism does not " +
 247                 "currently support storing GSS credentials handle " +
 248                 "elements into a \"credential store\"");
 249     }
 250 
 251     /**
 252      * Creates a name element for this mechanism to be included as part of
 253      * a GSSName implementation. A GSSName is conceptually a container
 254      * class of several name elements from different mechanisms. A GSSName
 255      * can be created either with a String or with a sequence of
 256      * bytes. This factory method accepts the name in a String. Such a name
 257      * can generally be assumed to be printable and may be returned from
 258      * the name element's toString() method.
 259      *
 260      * @param nameStr a string containing the characters describing this
 261      * entity to the mechanism
 262      * @param nameType an Oid serving as a clue as to how the mechanism should
 263      * interpret the nameStr
 264      * @throws GSSException if any of the errors described in RFC 2743 for
 265      * the GSS_Import_Name or GSS_Canonicalize_Name calls occur.
 266      */
 267     public GSSNameSpi getNameElement(String nameStr, Oid nameType)
 268         throws GSSException;
 269 
 270     /**
 271      * This is a variation of the factory method that accepts a String for
 272      * the characters that make up the name. Usually the String characters
 273      * are assumed to be printable. The bytes passed in to this method have
 274      * to be converted to characters using some encoding of the mechanism's
 275      * choice. It is recommended that UTF-8 be used. (Note that UTF-8
 276      * preserves the encoding for 7-bit ASCII characters.)
 277      * &lt;p&gt;
 278      * An exported name will generally be passed in using this method.
 279      *
 280      * @param name the bytes describing this entity to the mechanism
 281      * @param nameType an Oid serving as a clue as to how the mechanism should
 282      * interpret the nameStr
 283      * @throws GSSException if any of the errors described in RFC 2743 for
 284      * the GSS_Import_Name or GSS_Canonicalize_Name calls occur.
 285      */
 286     public GSSNameSpi getNameElement(byte[] name, Oid nameType)
 287         throws GSSException;
 288 
 289     /**
 290      * Creates a security context for this mechanism so that it can be used
 291      * on the context initiator's side.
 292      *
 293      * @param peer the name element from this mechanism that represents the
 294      * peer
 295      * @param myInitiatorCred a credential element for the context
 296      * initiator obtained previously from this mechanism. The identity of
 297      * the context initiator can be obtained from this credential. Passing
 298      * a value of null here indicates that a default entity of the
 299      * mechanism's choice should be assumed to be the context initiator and
 300      * that default credentials should be applied.
 301      * @param lifetime the requested lifetime (in seconds) for the security
 302      * context. Predefined contants are available in the
 303      * org.ietf.jgss.GSSContext interface.
 304      * @throws GSSException if any of the errors described in RFC 2743 in
 305      * the GSS_Init_Sec_Context call occur.
 306      */
 307     public GSSContextSpi getMechanismContext(GSSNameSpi peer,
 308                                              GSSCredentialSpi myInitiatorCred,
 309                                              int lifetime) throws GSSException;
 310 
 311     /**
 312      * Creates a security context for this mechanism so thatit can be used
 313      * on the context acceptor's side.
 314      *
 315      * @param myAcceptorCred a credential element for the context acceptor
 316      * obtained previously from this mechanism. The identity of the context
 317      * acceptor cna be obtained from this credential. Passing a value of
 318      * null here indicates that tha default entity of the mechanism's
 319      * choice should be assumed to be the context acceptor and default
 320      * credentials should be applied.
 321      *
 322      * @throws GSSException if any of the errors described in RFC 2743 in
 323      * the GSS_Accept_Sec_Context call occur.
 324      */
 325     public GSSContextSpi getMechanismContext(GSSCredentialSpi myAcceptorCred)
 326         throws GSSException;
 327 
 328     /**
 329      * Creates a security context from a previously exported (serialized)
 330      * security context. Note that this is different from Java
 331      * serialization and is defined at a mechanism level to interoperate
 332      * over the wire with non-Java implementations. Either the initiator or
 333      * the acceptor can export and then import a security context.
 334      * Implementations of mechanism contexts are not required to implement
 335      * exporting and importing.
 336      *
 337      * @param exportedContext the bytes representing this security context
 338      * @throws GSSException is any of the errors described in RFC 2743 in
 339      * the GSS_Import_Sec_Context call occur.
 340      */
 341     public GSSContextSpi getMechanismContext(byte[] exportedContext)
 342         throws GSSException;
 343 
 344 }
</pre></body></html>
