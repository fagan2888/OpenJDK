<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>ws Sdiff src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java</title>
</head><body id="SUNWwebrev">
<a class="print" href="javascript:print()">Print this page</a>
<pre>JGSS: Simplify context permissions checks
We were reacquiring the initiator/acceptor credential upon security
context full establishment in order to indirectly perform a permission
check on the srcName/targName once we find out what they are.  But this
is just one more way to end up failing, which happens with Heimdal when
using SPNEGO because we ask to acquire a Kerberos credentials using a
SPNEGO MN and that fails.
Also, there was a security bug here: if the permission check fails then
we raise, but if the application already has a context handle, then it
can use it anyways if it catches the exception!  The fix for this is to
dispose() when the permission check fails.
JGSS: Add comment about unnec. perm check
Fix SpNego multi-round-trip bug
There is only one token that we can extract an actual mechanism OID from
in the SPNEGO case when the native GSS library doesn't provide that
(though it should) in the API.  If the SPNEGO exchange ends up requiring
more than two tokens, then the previous code failed to establish a
security context.
Also, never raise if we cannot get an actual mech OID from SPNEGO
tokens.
Add actual mechanism to native GSSNameElement state</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  58     private static final int GSS_C_TRANS_FLAG = 256;
  59 
  60     private static final int NUM_OF_INQUIRE_VALUES = 6;
  61 
  62     private long pContext = 0; // Pointer to the gss_ctx_id_t structure
  63     private GSSNameElement srcName;
  64     private GSSNameElement targetName;
  65     private GSSCredElement cred;
  66     private GSSCredElement disposeCred;
  67     private boolean isInitiator;
  68     private boolean isEstablished;
  69     private Oid actualMech; // Assigned during context establishment
  70 
  71     private ChannelBinding cb;
  72     private GSSCredElement delegatedCred;
  73     private GSSCredElement disposeDelegatedCred;
  74     private int flags;
  75     private int lifetime = GSSCredential.DEFAULT_LIFETIME;
  76     private final GSSLibStub cStub;
  77 
<span class="changed">  78     private boolean skipDelegPermCheck;</span>
<span class="changed">  79     private boolean skipServicePermCheck;</span>
  80 
  81     // Retrieve the (preferred) mech out of SPNEGO tokens, i.e.
  82     // NegTokenInit &amp; NegTokenTarg
  83     private static Oid getMechFromSpNegoToken(byte[] token,
  84                                               boolean isInitiator)
  85         throws GSSException {
  86         Oid mech = null;
  87         if (isInitiator) {
  88             GSSHeader header = null;
  89             try {
  90                 header = new GSSHeader(new ByteArrayInputStream(token));
  91             } catch (IOException ioe) {
  92                 throw new GSSExceptionImpl(GSSException.FAILURE, ioe);
  93             }
  94             int negTokenLen = header.getMechTokenLength();
  95             byte[] negToken = new byte[negTokenLen];
  96             System.arraycopy(token, token.length-negTokenLen,
  97                              negToken, 0, negToken.length);
  98 
  99             NegTokenInit ntok = new NegTokenInit(negToken);
 100             if (ntok.getMechToken() != null) {
 101                 Oid[] mechList = ntok.getMechTypeList();
 102                 mech = mechList[0];
 103             }
 104         } else {
 105             NegTokenTarg ntok = new NegTokenTarg(token);
 106             mech = ntok.getSupportedMech();
 107         }
 108         return mech;
 109     }
 110 
 111     // Perform the Service permission check
 112     private void doServicePermCheck() throws GSSException {
 113         if (System.getSecurityManager() != null) {
<span class="changed"> 114             String action = (isInitiator? "initiate" : "accept");</span>
<span class="changed"> 115             // Need to check Service permission for accessing</span>
<span class="changed"> 116             // initiator cred for SPNEGO during context establishment</span>
<span class="changed"> 117             if (GSSUtil.isSpNegoMech(cStub.getMech()) &amp;&amp; isInitiator</span>
<span class="changed"> 118                 &amp;&amp; !isEstablished) {</span>
<span class="changed"> 119                 if (srcName == null) {</span>
<span class="changed"> 120                     // Check by creating default initiator KRB5 cred</span>
<span class="changed"> 121                     GSSCredElement tempCred =</span>
<span class="changed"> 122                         new GSSCredElement(null, lifetime,</span>
<span class="changed"> 123                                            GSSCredential.INITIATE_ONLY,</span>
<span class="changed"> 124                                            GSSLibStub.getInstance(GSSUtil.GSS_KRB5_MECH_OID));</span>
<span class="changed"> 125                     tempCred.dispose();</span>
<span class="changed"> 126                 } else {</span>
 127                     String tgsName = Krb5Util.getTGSName(srcName);
<span class="changed"> 128                     Krb5Util.checkServicePermission(tgsName, action);</span>
<span class="changed"> 129                 }</span>
<span class="changed"> 130             }</span>
 131             String targetStr = targetName.getKrbName();
<span class="changed"> 132             Krb5Util.checkServicePermission(targetStr, action);</span>
 133             skipServicePermCheck = true;
 134         }





 135     }
 136 
 137     // Perform the Delegation permission check
 138     private void doDelegPermCheck() throws GSSException {
 139         SecurityManager sm = System.getSecurityManager();
 140         if (sm != null) {


 141             String targetStr = targetName.getKrbName();
 142             String tgsStr = Krb5Util.getTGSName(targetName);
 143             StringBuilder sb = new StringBuilder("\"");
 144             sb.append(targetStr).append("\" \"");
 145             sb.append(tgsStr).append('\"');
 146             String krbPrincPair = sb.toString();
 147             SunNativeProvider.debug("Checking DelegationPermission (" +
 148                                     krbPrincPair + ")");
 149             DelegationPermission perm =
 150                 new DelegationPermission(krbPrincPair);
 151             sm.checkPermission(perm);
 152             skipDelegPermCheck = true;
 153         }
 154     }
 155 
 156     private byte[] retrieveToken(InputStream is, int mechTokenLen)
 157         throws GSSException {
 158         try {
 159             byte[] result = null;
 160             if (mechTokenLen != -1) {

</pre><hr></hr><pre>
 183             return result;
 184         } catch (IOException ioe) {
 185             throw new GSSExceptionImpl(GSSException.FAILURE, ioe);
 186         }
 187     }
 188 
 189     // Constructor for context initiator
 190     NativeGSSContext(GSSNameElement peer, GSSCredElement myCred,
 191                      int time, GSSLibStub stub) throws GSSException {
 192         if (peer == null) {
 193             throw new GSSException(GSSException.FAILURE, 1, "null peer");
 194         }
 195         cStub = stub;
 196         cred = myCred;
 197         disposeCred = null;
 198         targetName = peer;
 199         isInitiator = true;
 200         lifetime = time;
 201 
 202         if (GSSUtil.isKerberosMech(cStub.getMech())) {
<span class="removed"> 203             doServicePermCheck();</span>
 204             if (cred == null) {
 205                 disposeCred = cred =
 206                     new GSSCredElement(null, lifetime,
 207                             GSSCredential.INITIATE_ONLY, cStub);
 208             }
 209             srcName = cred.getName();

 210         }
 211     }
 212 
 213     // Constructor for context acceptor
 214     NativeGSSContext(GSSCredElement myCred, GSSLibStub stub)
 215         throws GSSException {
 216         cStub = stub;
 217         cred = myCred;
 218         disposeCred = null;
 219 
 220         if (cred != null) targetName = cred.getName();
 221 
 222         isInitiator = false;
 223         // Defer Service permission check for default acceptor cred
 224         // to acceptSecContext()
 225         if (GSSUtil.isKerberosMech(cStub.getMech()) &amp;&amp; targetName != null) {
 226             doServicePermCheck();
 227         }
 228 
 229         // srcName and potentially targetName (when myCred is null)
 230         // will be set in GSSLibStub.acceptContext(...)
 231     }
 232 
 233     // Constructor for imported context
 234     NativeGSSContext(long pCtxt, GSSLibStub stub) throws GSSException {
 235         assert(pContext != 0);
 236         pContext = pCtxt;
 237         cStub = stub;
 238 
 239         // Set everything except cred, cb, delegatedCred
 240         long[] info = cStub.inquireContext(pContext);
 241         if (info.length != NUM_OF_INQUIRE_VALUES) {
 242             throw new RuntimeException("Bug w/ GSSLibStub.inquireContext()");
 243         }
<span class="removed"> 244         srcName = new GSSNameElement(info[0], cStub);</span>
<span class="removed"> 245         targetName = new GSSNameElement(info[1], cStub);</span>
 246         isInitiator = (info[2] != 0);
 247         isEstablished = (info[3] != 0);
 248         flags = (int) info[4];
 249         lifetime = (int) info[5];







 250 
 251         // Do Service Permission check when importing SPNEGO context
<span class="changed"> 252         // just to be safe</span>


 253         Oid mech = cStub.getMech();
 254         if (GSSUtil.isSpNegoMech(mech) || GSSUtil.isKerberosMech(mech)) {
 255             doServicePermCheck();
 256         }
 257     }
 258 
 259     public Provider getProvider() {
 260         return SunNativeProvider.INSTANCE;
 261     }
 262 
 263     public byte[] initSecContext(InputStream is, int mechTokenLen)
 264         throws GSSException {
 265         byte[] outToken = null;
 266         if ((!isEstablished) &amp;&amp; (isInitiator)) {
 267             byte[] inToken = null;
 268             // Ignore the specified input stream on the first call
 269             if (pContext != 0) {
 270                 inToken = retrieveToken(is, mechTokenLen);
 271                 SunNativeProvider.debug("initSecContext=&gt; inToken len=" +
 272                     inToken.length);
 273             }
 274 
 275             if (!getCredDelegState()) skipDelegPermCheck = true;
 276 
 277             if (GSSUtil.isKerberosMech(cStub.getMech()) &amp;&amp; !skipDelegPermCheck) {
 278                 doDelegPermCheck();
 279             }
 280 
 281             long pCred = (cred == null? 0 : cred.pCred);
 282             outToken = cStub.initContext(pCred, targetName.pName,
 283                                          cb, inToken, this);
 284             SunNativeProvider.debug("initSecContext=&gt; outToken len=" +
 285                 (outToken == null ? 0 : outToken.length));
 286 
 287             // Only inspect the token when the permission check
 288             // has not been performed
<span class="changed"> 289             if (GSSUtil.isSpNegoMech(cStub.getMech()) &amp;&amp; outToken != null) {</span>


 290                 // WORKAROUND for SEAM bug#6287358










 291                 actualMech = getMechFromSpNegoToken(outToken, true);


 292 
<span class="changed"> 293                 if (GSSUtil.isKerberosMech(actualMech)) {</span>
 294                     if (!skipServicePermCheck) doServicePermCheck();
 295                     if (!skipDelegPermCheck) doDelegPermCheck();
 296                 }
<span class="removed"> 297             }</span>
 298 
 299             if (isEstablished) {




 300                 if (srcName == null) {
 301                     srcName = new GSSNameElement
<span class="changed"> 302                         (cStub.getContextName(pContext, true), cStub);</span>
<span class="changed"> 303                 }</span>
<span class="changed"> 304                 if (cred == null) {</span>
<span class="changed"> 305                     disposeCred = cred =</span>
<span class="changed"> 306                         new GSSCredElement(srcName, lifetime,</span>
<span class="changed"> 307                                 GSSCredential.INITIATE_ONLY, cStub);</span>
 308                 }

 309             }
 310         }
 311         return outToken;
 312     }
 313 
 314     public byte[] acceptSecContext(InputStream is, int mechTokenLen)
 315         throws GSSException {
 316         byte[] outToken = null;
 317         if ((!isEstablished) &amp;&amp; (!isInitiator)) {
 318             byte[] inToken = retrieveToken(is, mechTokenLen);
 319             SunNativeProvider.debug("acceptSecContext=&gt; inToken len=" +
 320                                     inToken.length);
 321             long pCred = (cred == null? 0 : cred.pCred);
 322             outToken = cStub.acceptContext(pCred, cb, inToken, this);
 323             disposeDelegatedCred = delegatedCred;
 324             SunNativeProvider.debug("acceptSecContext=&gt; outToken len=" +
 325                                     (outToken == null? 0 : outToken.length));
 326 
<span class="changed"> 327             if (targetName == null) {</span>
 328                 targetName = new GSSNameElement
<span class="changed"> 329                     (cStub.getContextName(pContext, false), cStub);</span>
<span class="changed"> 330                 // Replace the current default acceptor cred now that</span>
<span class="changed"> 331                 // the context acceptor name is available</span>
<span class="changed"> 332                 if (disposeCred != null) {</span>
<span class="changed"> 333                     disposeCred.dispose();</span>
 334                 }
<span class="changed"> 335                 disposeCred = cred =</span>
<span class="changed"> 336                     new GSSCredElement(targetName, lifetime,</span>
<span class="changed"> 337                             GSSCredential.ACCEPT_ONLY, cStub);</span>


 338             }
<span class="changed"> 339 </span>
<span class="changed"> 340             // Only inspect token when the permission check has not</span>
<span class="changed"> 341             // been performed</span>
<span class="changed"> 342             if (GSSUtil.isSpNegoMech(cStub.getMech()) &amp;&amp;</span>
<span class="changed"> 343                 (outToken != null) &amp;&amp; !skipServicePermCheck) {</span>
<span class="changed"> 344                 if (GSSUtil.isKerberosMech(getMechFromSpNegoToken</span>
<span class="changed"> 345                                            (outToken, false))) {</span>
 346                     doServicePermCheck();
<span class="removed"> 347                 }</span>
 348             }
 349         }
 350         return outToken;
 351     }
 352 
 353     public boolean isEstablished() {
 354         return isEstablished;
 355     }
 356 
 357     public void dispose() throws GSSException {
 358         if (disposeCred != null) {
 359             disposeCred.dispose();
 360         }
 361         if (disposeDelegatedCred != null) {
 362             disposeDelegatedCred.dispose();
 363         }
 364         disposeDelegatedCred = disposeCred = cred = null;
 365         srcName = null;
 366         targetName = null;
 367         delegatedCred = null;

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  58     private static final int GSS_C_TRANS_FLAG = 256;
  59 
  60     private static final int NUM_OF_INQUIRE_VALUES = 6;
  61 
  62     private long pContext = 0; // Pointer to the gss_ctx_id_t structure
  63     private GSSNameElement srcName;
  64     private GSSNameElement targetName;
  65     private GSSCredElement cred;
  66     private GSSCredElement disposeCred;
  67     private boolean isInitiator;
  68     private boolean isEstablished;
  69     private Oid actualMech; // Assigned during context establishment
  70 
  71     private ChannelBinding cb;
  72     private GSSCredElement delegatedCred;
  73     private GSSCredElement disposeDelegatedCred;
  74     private int flags;
  75     private int lifetime = GSSCredential.DEFAULT_LIFETIME;
  76     private final GSSLibStub cStub;
  77 
<span class="changed">  78     private boolean skipDelegPermCheck = false;</span>
<span class="changed">  79     private boolean skipServicePermCheck = false;</span>
  80 
  81     // Retrieve the (preferred) mech out of SPNEGO tokens, i.e.
  82     // NegTokenInit &amp; NegTokenTarg
  83     private static Oid getMechFromSpNegoToken(byte[] token,
  84                                               boolean isInitiator)
  85         throws GSSException {
  86         Oid mech = null;
  87         if (isInitiator) {
  88             GSSHeader header = null;
  89             try {
  90                 header = new GSSHeader(new ByteArrayInputStream(token));
  91             } catch (IOException ioe) {
  92                 throw new GSSExceptionImpl(GSSException.FAILURE, ioe);
  93             }
  94             int negTokenLen = header.getMechTokenLength();
  95             byte[] negToken = new byte[negTokenLen];
  96             System.arraycopy(token, token.length-negTokenLen,
  97                              negToken, 0, negToken.length);
  98 
  99             NegTokenInit ntok = new NegTokenInit(negToken);
 100             if (ntok.getMechToken() != null) {
 101                 Oid[] mechList = ntok.getMechTypeList();
 102                 mech = mechList[0];
 103             }
 104         } else {
 105             NegTokenTarg ntok = new NegTokenTarg(token);
 106             mech = ntok.getSupportedMech();
 107         }
 108         return mech;
 109     }
 110 
 111     // Perform the Service permission check
 112     private void doServicePermCheck() throws GSSException {
 113         if (System.getSecurityManager() != null) {
<span class="changed"> 114             try {</span>
<span class="changed"> 115                 if (isInitiator &amp;&amp; srcName != null) {</span>











 116                     String tgsName = Krb5Util.getTGSName(srcName);
<span class="changed"> 117                     Krb5Util.checkServicePermission(tgsName, "initiate");</span>
<span class="changed"> 118                     skipServicePermCheck = true;</span>
<span class="changed"> 119                 } else if (!isInitiator &amp;&amp; targetName != null) {</span>
 120                     String targetStr = targetName.getKrbName();
<span class="changed"> 121                     Krb5Util.checkServicePermission(targetStr, "accept");</span>
 122                     skipServicePermCheck = true;
 123                 }
<span class="new"> 124             } catch (GSSException ge) {</span>
<span class="new"> 125                 dispose();</span>
<span class="new"> 126                 throw ge;</span>
<span class="new"> 127             }</span>
<span class="new"> 128         }</span>
 129     }
 130 
 131     // Perform the Delegation permission check
 132     private void doDelegPermCheck() throws GSSException {
 133         SecurityManager sm = System.getSecurityManager();
 134         if (sm != null) {
<span class="new"> 135             if (targetName == null)</span>
<span class="new"> 136                 return;</span>
 137             String targetStr = targetName.getKrbName();
 138             String tgsStr = Krb5Util.getTGSName(targetName);
 139             StringBuilder sb = new StringBuilder("\"");
 140             sb.append(targetStr).append("\" \"");
 141             sb.append(tgsStr).append('\"');
 142             String krbPrincPair = sb.toString();
 143             SunNativeProvider.debug("Checking DelegationPermission (" +
 144                                     krbPrincPair + ")");
 145             DelegationPermission perm =
 146                 new DelegationPermission(krbPrincPair);
 147             sm.checkPermission(perm);
 148             skipDelegPermCheck = true;
 149         }
 150     }
 151 
 152     private byte[] retrieveToken(InputStream is, int mechTokenLen)
 153         throws GSSException {
 154         try {
 155             byte[] result = null;
 156             if (mechTokenLen != -1) {

</pre><hr></hr><pre>
 179             return result;
 180         } catch (IOException ioe) {
 181             throw new GSSExceptionImpl(GSSException.FAILURE, ioe);
 182         }
 183     }
 184 
 185     // Constructor for context initiator
 186     NativeGSSContext(GSSNameElement peer, GSSCredElement myCred,
 187                      int time, GSSLibStub stub) throws GSSException {
 188         if (peer == null) {
 189             throw new GSSException(GSSException.FAILURE, 1, "null peer");
 190         }
 191         cStub = stub;
 192         cred = myCred;
 193         disposeCred = null;
 194         targetName = peer;
 195         isInitiator = true;
 196         lifetime = time;
 197 
 198         if (GSSUtil.isKerberosMech(cStub.getMech())) {

 199             if (cred == null) {
 200                 disposeCred = cred =
 201                     new GSSCredElement(null, lifetime,
 202                             GSSCredential.INITIATE_ONLY, cStub);
 203             }
 204             srcName = cred.getName();
<span class="new"> 205             doServicePermCheck();</span>
 206         }
 207     }
 208 
 209     // Constructor for context acceptor
 210     NativeGSSContext(GSSCredElement myCred, GSSLibStub stub)
 211         throws GSSException {
 212         cStub = stub;
 213         cred = myCred;
 214         disposeCred = null;
 215 
 216         if (cred != null) targetName = cred.getName();
 217 
 218         isInitiator = false;
 219         // Defer Service permission check for default acceptor cred
 220         // to acceptSecContext()
 221         if (GSSUtil.isKerberosMech(cStub.getMech()) &amp;&amp; targetName != null) {
 222             doServicePermCheck();
 223         }
 224 
 225         // srcName and potentially targetName (when myCred is null)
 226         // will be set in GSSLibStub.acceptContext(...)
 227     }
 228 
 229     // Constructor for imported context
 230     NativeGSSContext(long pCtxt, GSSLibStub stub) throws GSSException {
 231         assert(pContext != 0);
 232         pContext = pCtxt;
 233         cStub = stub;
 234 
 235         // Set everything except cred, cb, delegatedCred
 236         long[] info = cStub.inquireContext(pContext);
 237         if (info.length != NUM_OF_INQUIRE_VALUES) {
 238             throw new RuntimeException("Bug w/ GSSLibStub.inquireContext()");
 239         }


 240         isInitiator = (info[2] != 0);
 241         isEstablished = (info[3] != 0);
 242         flags = (int) info[4];
 243         lifetime = (int) info[5];
<span class="new"> 244         if (isEstablished) {</span>
<span class="new"> 245             srcName = new GSSNameElement(info[0], actualMech, cStub);</span>
<span class="new"> 246             targetName = new GSSNameElement(info[1], actualMech, cStub);</span>
<span class="new"> 247         } else {</span>
<span class="new"> 248             srcName = null;</span>
<span class="new"> 249             targetName = null;</span>
<span class="new"> 250         }</span>
 251 
 252         // Do Service Permission check when importing SPNEGO context
<span class="changed"> 253         // just to be safe.  WAT, no.  If the caller has an exported sec</span>
<span class="changed"> 254         // context token, it's because someone gave it to it, therefore there's</span>
<span class="changed"> 255         // no need to do any further permission checking.  REMOVE!</span>
 256         Oid mech = cStub.getMech();
 257         if (GSSUtil.isSpNegoMech(mech) || GSSUtil.isKerberosMech(mech)) {
 258             doServicePermCheck();
 259         }
 260     }
 261 
 262     public Provider getProvider() {
 263         return SunNativeProvider.INSTANCE;
 264     }
 265 
 266     public byte[] initSecContext(InputStream is, int mechTokenLen)
 267         throws GSSException {
 268         byte[] outToken = null;
 269         if ((!isEstablished) &amp;&amp; (isInitiator)) {
 270             byte[] inToken = null;
 271             // Ignore the specified input stream on the first call
 272             if (pContext != 0) {
 273                 inToken = retrieveToken(is, mechTokenLen);
 274                 SunNativeProvider.debug("initSecContext=&gt; inToken len=" +
 275                     inToken.length);
 276             }
 277 
 278             if (!getCredDelegState()) skipDelegPermCheck = true;
 279 
 280             if (GSSUtil.isKerberosMech(cStub.getMech()) &amp;&amp; !skipDelegPermCheck) {
 281                 doDelegPermCheck();
 282             }
 283 
 284             long pCred = (cred == null? 0 : cred.pCred);
 285             outToken = cStub.initContext(pCred, targetName.pName,
 286                                          cb, inToken, this);
 287             SunNativeProvider.debug("initSecContext=&gt; outToken len=" +
 288                 (outToken == null ? 0 : outToken.length));
 289 
 290             // Only inspect the token when the permission check
 291             // has not been performed
<span class="changed"> 292             if (!GSSUtil.isSpNegoMech(cStub.getMech())) {</span>
<span class="changed"> 293                 actualMech = cStub.getMech();</span>
<span class="changed"> 294             } else if (actualMech == null &amp;&amp; outToken != null) {</span>
 295                 // WORKAROUND for SEAM bug#6287358
<span class="new"> 296                 //</span>
<span class="new"> 297                 // This is where some C GSS SPNEGO implementations fail to make</span>
<span class="new"> 298                 // the real actual mechanism available.</span>
<span class="new"> 299                 // getMechFromSpNegoToken() does the horrible, no good, very</span>
<span class="new"> 300                 // bad thing its name says it does.  For now we retain this bit</span>
<span class="new"> 301                 // of evil.</span>
<span class="new"> 302                 //</span>
<span class="new"> 303                 // XXX Time to remove this workaround.  It's been 20</span>
<span class="new"> 304                 // years.</span>
<span class="new"> 305                 try {</span>
 306                     actualMech = getMechFromSpNegoToken(outToken, true);
<span class="new"> 307                 } catch (GSSException e) { }</span>
<span class="new"> 308             }</span>
 309 
<span class="changed"> 310             if (actualMech != null &amp;&amp; GSSUtil.isKerberosMech(actualMech)) {</span>
 311                 if (!skipServicePermCheck) doServicePermCheck();
 312                 if (!skipDelegPermCheck) doDelegPermCheck();
 313             }

 314 
 315             if (isEstablished) {
<span class="new"> 316                 // XXX We should attempt to get actualMech from the cStub here,</span>
<span class="new"> 317                 // and take it even if we got a semblance of an actualMech from</span>
<span class="new"> 318                 // the SPNEGO token, as long as the one returned by the cStub</span>
<span class="new"> 319                 // isn't the SPNEGO OID.</span>
 320                 if (srcName == null) {
 321                     srcName = new GSSNameElement
<span class="changed"> 322                         (cStub.getContextName(pContext, true), actualMech,</span>
<span class="changed"> 323                          cStub);</span>




 324                 }
<span class="new"> 325                 if (!skipServicePermCheck) doServicePermCheck();</span>
 326             }
 327         }
 328         return outToken;
 329     }
 330 
 331     public byte[] acceptSecContext(InputStream is, int mechTokenLen)
 332         throws GSSException {
 333         byte[] outToken = null;
 334         if ((!isEstablished) &amp;&amp; (!isInitiator)) {
 335             byte[] inToken = retrieveToken(is, mechTokenLen);
 336             SunNativeProvider.debug("acceptSecContext=&gt; inToken len=" +
 337                                     inToken.length);
 338             long pCred = (cred == null? 0 : cred.pCred);
 339             outToken = cStub.acceptContext(pCred, cb, inToken, this);
 340             disposeDelegatedCred = delegatedCred;
 341             SunNativeProvider.debug("acceptSecContext=&gt; outToken len=" +
 342                                     (outToken == null? 0 : outToken.length));
 343 
<span class="changed"> 344             if (isEstablished &amp;&amp; targetName == null) {</span>
 345                 targetName = new GSSNameElement
<span class="changed"> 346                     (cStub.getContextName(pContext, false), actualMech, cStub);</span>




 347             }
<span class="changed"> 348             if (GSSUtil.isSpNegoMech(cStub.getMech()) &amp;&amp; outToken != null &amp;&amp;</span>
<span class="changed"> 349                 actualMech == null) {</span>
<span class="changed"> 350                 try {</span>
<span class="changed"> 351                     actualMech = getMechFromSpNegoToken(outToken, true);</span>
<span class="changed"> 352                 } catch (GSSException e) { }</span>
 353             }
<span class="changed"> 354             if (isEstablished &amp;&amp; targetName != null &amp;&amp; !skipServicePermCheck) {</span>






 355                 doServicePermCheck();

 356             }
 357         }
 358         return outToken;
 359     }
 360 
 361     public boolean isEstablished() {
 362         return isEstablished;
 363     }
 364 
 365     public void dispose() throws GSSException {
 366         if (disposeCred != null) {
 367             disposeCred.dispose();
 368         }
 369         if (disposeDelegatedCred != null) {
 370             disposeDelegatedCred.dispose();
 371         }
 372         disposeDelegatedCred = disposeCred = cred = null;
 373         srcName = null;
 374         targetName = null;
 375         delegatedCred = null;

</pre><hr></hr>
</pre></td>
</tr></table>
</body></html>
