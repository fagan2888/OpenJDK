<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>ws Old src/java.security.jgss/share/native/libj2gss/gssapi.h</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /* This is the gssapi.h prologue. */
  27 /* It contains some choice pieces of autoconf.h */
  28 #define GSS_SIZEOF_INT 4
  29 #define GSS_SIZEOF_LONG 4
  30 #define GSS_SIZEOF_SHORT 2
  31 
  32 #ifndef _GSSAPI_H_
  33 #define _GSSAPI_H_
  34 
  35 #if defined(__MACH__) &amp;&amp; defined(__APPLE__)
  36 #       include &lt;TargetConditionals.h&gt;
  37 #       if TARGET_RT_MAC_CFM
  38 #               error "Use KfM 4.0 SDK headers for CFM compilation."
  39 #       endif
  40 #endif
  41 
  42 #ifdef __cplusplus
  43 extern "C" {
  44 #endif /* __cplusplus */
  45 
  46 #if TARGET_OS_MAC
  47 #    pragma pack(push,2)
  48 #endif
  49 
  50 /*
  51  * First, include stddef.h to get size_t defined.
  52  */
  53 #include &lt;stddef.h&gt;
  54 
  55 /*
  56  * POSIX says that sys/types.h is where size_t is defined.
  57  */
  58 #include &lt;sys/types.h&gt;
  59 
  60 struct gss_name_struct;
  61 typedef struct gss_name_struct * gss_name_t;
  62 typedef const struct gss_name_struct *gss_const_name_t;
  63 
  64 struct gss_cred_id_struct;
  65 typedef struct gss_cred_id_struct * gss_cred_id_t;
  66 typedef const struct gss_cred_id_struct *gss_const_cred_id_t;
  67 
  68 struct gss_ctx_id_struct;
  69 typedef struct gss_ctx_id_struct * gss_ctx_id_t;
  70 typedef const struct gss_ctx_id_struct *gss_const_ctx_id_t;
  71 
  72 /*
  73  * The following type must be defined as the smallest natural unsigned integer
  74  * supported by the platform that has at least 32 bits of precision.
  75  */
  76 #if (GSS_SIZEOF_SHORT == 4)
  77 typedef unsigned short gss_uint32;
  78 typedef short gss_int32;
  79 #elif (GSS_SIZEOF_INT == 4)
  80 typedef unsigned int gss_uint32;
  81 typedef int gss_int32;
  82 #elif (GSS_SIZEOF_LONG == 4)
  83 typedef unsigned long gss_uint32;
  84 typedef long gss_int32;
  85 #endif
  86 
  87 typedef gss_uint32      OM_uint32;
  88 
  89 typedef struct gss_OID_desc_struct {
  90       OM_uint32 length;
  91       void *elements;
  92 } gss_OID_desc, *gss_OID;
  93 typedef const gss_OID_desc * gss_const_OID;
  94 
  95 typedef struct gss_OID_set_desc_struct  {
  96       size_t  count;
  97       gss_OID elements;
  98 } gss_OID_set_desc, *gss_OID_set;
  99 typedef const gss_OID_set_desc * gss_const_OID_set;
 100 
 101 typedef struct gss_buffer_desc_struct {
 102       size_t length;
 103       void *value;
 104 } gss_buffer_desc, *gss_buffer_t;
 105 typedef const gss_buffer_desc * gss_const_buffer_t;
 106 
 107 typedef struct gss_channel_bindings_struct {
 108       OM_uint32 initiator_addrtype;
 109       gss_buffer_desc initiator_address;
 110       OM_uint32 acceptor_addrtype;
 111       gss_buffer_desc acceptor_address;
 112       gss_buffer_desc application_data;
 113 } *gss_channel_bindings_t;
 114 typedef const struct gss_channel_bindings_struct *gss_const_channel_bindings_t;
 115 
 116 /*
 117  * For now, define a QOP-type as an OM_uint32
 118  */
 119 typedef OM_uint32       gss_qop_t;
 120 typedef int             gss_cred_usage_t;
 121 
 122 /*
 123  * Flag bits for context-level services.
 124  */
 125 #define GSS_C_DELEG_FLAG 1
 126 #define GSS_C_MUTUAL_FLAG 2
 127 #define GSS_C_REPLAY_FLAG 4
 128 #define GSS_C_SEQUENCE_FLAG 8
 129 #define GSS_C_CONF_FLAG 16
 130 #define GSS_C_INTEG_FLAG 32
 131 #define GSS_C_ANON_FLAG 64
 132 #define GSS_C_PROT_READY_FLAG 128
 133 #define GSS_C_TRANS_FLAG 256
 134 #define GSS_C_DELEG_POLICY_FLAG 32768
 135 
 136 /*
 137  * Credential usage options
 138  */
 139 #define GSS_C_BOTH 0
 140 #define GSS_C_INITIATE 1
 141 #define GSS_C_ACCEPT 2
 142 
 143 /*
 144  * Status code types for gss_display_status
 145  */
 146 #define GSS_C_GSS_CODE 1
 147 #define GSS_C_MECH_CODE 2
 148 
 149 /*
 150  * The constant definitions for channel-bindings address families
 151  */
 152 #define GSS_C_AF_UNSPEC     0
 153 #define GSS_C_AF_LOCAL      1
 154 #define GSS_C_AF_INET       2
 155 #define GSS_C_AF_IMPLINK    3
 156 #define GSS_C_AF_PUP        4
 157 #define GSS_C_AF_CHAOS      5
 158 #define GSS_C_AF_NS         6
 159 #define GSS_C_AF_NBS        7
 160 #define GSS_C_AF_ECMA       8
 161 #define GSS_C_AF_DATAKIT    9
 162 #define GSS_C_AF_CCITT      10
 163 #define GSS_C_AF_SNA        11
 164 #define GSS_C_AF_DECnet     12
 165 #define GSS_C_AF_DLI        13
 166 #define GSS_C_AF_LAT        14
 167 #define GSS_C_AF_HYLINK     15
 168 #define GSS_C_AF_APPLETALK  16
 169 #define GSS_C_AF_BSC        17
 170 #define GSS_C_AF_DSS        18
 171 #define GSS_C_AF_OSI        19
 172 #define GSS_C_AF_X25        21
 173 
 174 #define GSS_C_AF_NULLADDR   255
 175 
 176 /*
 177  * Various Null values.
 178  */
 179 #define GSS_C_NO_NAME ((gss_name_t) 0)
 180 #define GSS_C_NO_BUFFER ((gss_buffer_t) 0)
 181 #define GSS_C_NO_OID ((gss_OID) 0)
 182 #define GSS_C_NO_OID_SET ((gss_OID_set) 0)
 183 #define GSS_C_NO_CONTEXT ((gss_ctx_id_t) 0)
 184 #define GSS_C_NO_CREDENTIAL ((gss_cred_id_t) 0)
 185 #define GSS_C_NO_CHANNEL_BINDINGS ((gss_channel_bindings_t) 0)
 186 #define GSS_C_EMPTY_BUFFER {0, NULL}
 187 
 188 /*
 189  * Some alternate names for a couple of the above values.  These are defined
 190  * for V1 compatibility.
 191  */
 192 #define GSS_C_NULL_OID          GSS_C_NO_OID
 193 #define GSS_C_NULL_OID_SET      GSS_C_NO_OID_SET
 194 
 195 /*
 196  * Define the default Quality of Protection for per-message services.  Note
 197  * that an implementation that offers multiple levels of QOP may either reserve
 198  * a value (for example zero, as assumed here) to mean "default protection", or
 199  * alternatively may simply equate GSS_C_QOP_DEFAULT to a specific explicit
 200  * QOP value.  However a value of 0 should always be interpreted by a GSSAPI
 201  * implementation as a request for the default protection level.
 202  */
 203 #define GSS_C_QOP_DEFAULT 0
 204 
 205 /*
 206  * Expiration time of 2^32-1 seconds means infinite lifetime for a
 207  * credential or security context
 208  */
 209 #define GSS_C_INDEFINITE ((OM_uint32) 0xfffffffful)
 210 
 211 
 212 /* Major status codes */
 213 
 214 #define GSS_S_COMPLETE 0
 215 
 216 /*
 217  * Some "helper" definitions to make the status code macros obvious.
 218  */
 219 #define GSS_C_CALLING_ERROR_OFFSET 24
 220 #define GSS_C_ROUTINE_ERROR_OFFSET 16
 221 #define GSS_C_SUPPLEMENTARY_OFFSET 0
 222 #define GSS_C_CALLING_ERROR_MASK ((OM_uint32) 0377ul)
 223 #define GSS_C_ROUTINE_ERROR_MASK ((OM_uint32) 0377ul)
 224 #define GSS_C_SUPPLEMENTARY_MASK ((OM_uint32) 0177777ul)
 225 
 226 /*
 227  * The macros that test status codes for error conditions.  Note that the
 228  * GSS_ERROR() macro has changed slightly from the V1 GSSAPI so that it now
 229  * evaluates its argument only once.
 230  */
 231 #define GSS_CALLING_ERROR(x) \
 232   ((x) &amp; (GSS_C_CALLING_ERROR_MASK &lt;&lt; GSS_C_CALLING_ERROR_OFFSET))
 233 #define GSS_ROUTINE_ERROR(x) \
 234   ((x) &amp; (GSS_C_ROUTINE_ERROR_MASK &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET))
 235 #define GSS_SUPPLEMENTARY_INFO(x) \
 236   ((x) &amp; (GSS_C_SUPPLEMENTARY_MASK &lt;&lt; GSS_C_SUPPLEMENTARY_OFFSET))
 237 #define GSS_ERROR(x) \
 238   ((x) &amp; ((GSS_C_CALLING_ERROR_MASK &lt;&lt; GSS_C_CALLING_ERROR_OFFSET) | \
 239           (GSS_C_ROUTINE_ERROR_MASK &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)))
 240 
 241 /*
 242  * Now the actual status code definitions
 243  */
 244 
 245 /*
 246  * Calling errors:
 247  */
 248 #define GSS_S_CALL_INACCESSIBLE_READ \
 249                              (((OM_uint32) 1ul) &lt;&lt; GSS_C_CALLING_ERROR_OFFSET)
 250 #define GSS_S_CALL_INACCESSIBLE_WRITE \
 251                              (((OM_uint32) 2ul) &lt;&lt; GSS_C_CALLING_ERROR_OFFSET)
 252 #define GSS_S_CALL_BAD_STRUCTURE \
 253                              (((OM_uint32) 3ul) &lt;&lt; GSS_C_CALLING_ERROR_OFFSET)
 254 
 255 /*
 256  * Routine errors:
 257  */
 258 #define GSS_S_BAD_MECH (((OM_uint32) 1ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 259 #define GSS_S_BAD_NAME (((OM_uint32) 2ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 260 #define GSS_S_BAD_NAMETYPE (((OM_uint32) 3ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 261 #define GSS_S_BAD_BINDINGS (((OM_uint32) 4ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 262 #define GSS_S_BAD_STATUS (((OM_uint32) 5ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 263 #define GSS_S_BAD_SIG (((OM_uint32) 6ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 264 #define GSS_S_NO_CRED (((OM_uint32) 7ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 265 #define GSS_S_NO_CONTEXT (((OM_uint32) 8ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 266 #define GSS_S_DEFECTIVE_TOKEN (((OM_uint32) 9ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 267 #define GSS_S_DEFECTIVE_CREDENTIAL \
 268      (((OM_uint32) 10ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 269 #define GSS_S_CREDENTIALS_EXPIRED \
 270      (((OM_uint32) 11ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 271 #define GSS_S_CONTEXT_EXPIRED \
 272      (((OM_uint32) 12ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 273 #define GSS_S_FAILURE (((OM_uint32) 13ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 274 #define GSS_S_BAD_QOP (((OM_uint32) 14ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 275 #define GSS_S_UNAUTHORIZED (((OM_uint32) 15ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 276 #define GSS_S_UNAVAILABLE (((OM_uint32) 16ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 277 #define GSS_S_DUPLICATE_ELEMENT \
 278      (((OM_uint32) 17ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 279 #define GSS_S_NAME_NOT_MN \
 280      (((OM_uint32) 18ul) &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
 281 
 282 /*
 283  * Supplementary info bits:
 284  */
 285 #define GSS_S_CONTINUE_NEEDED (1 &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 0))
 286 #define GSS_S_DUPLICATE_TOKEN (1 &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 1))
 287 #define GSS_S_OLD_TOKEN (1 &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 2))
 288 #define GSS_S_UNSEQ_TOKEN (1 &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 3))
 289 #define GSS_S_GAP_TOKEN (1 &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 4))
 290 
 291 
 292 /*
 293  * Finally, function prototypes for the GSSAPI routines.
 294  */
 295 
 296 #if defined (_WIN32) &amp;&amp; defined (_MSC_VER)
 297 # ifdef GSS_DLL_FILE
 298 #  define GSS_DLLIMP __declspec(dllexport)
 299 # else
 300 #  define GSS_DLLIMP __declspec(dllimport)
 301 # endif
 302 #else
 303 # define GSS_DLLIMP
 304 #endif
 305 
 306 /* Reserved static storage for GSS_oids.  Comments are quotes from RFC 2744.
 307  *
 308  * The implementation must reserve static storage for a
 309  * gss_OID_desc object containing the value
 310  * {10, (void *)"\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x01"},
 311  * corresponding to an object-identifier value of
 312  * {iso(1) member-body(2) United States(840) mit(113554)
 313  * infosys(1) gssapi(2) generic(1) user_name(1)}.  The constant
 314  * GSS_C_NT_USER_NAME should be initialized to point
 315  * to that gss_OID_desc.
 316  */
 317 GSS_DLLIMP extern gss_OID GSS_C_NT_USER_NAME;
 318 
 319 /*
 320  * The implementation must reserve static storage for a
 321  * gss_OID_desc object containing the value
 322  * {10, (void *)"\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x02"},
 323  * corresponding to an object-identifier value of
 324  * {iso(1) member-body(2) United States(840) mit(113554)
 325  * infosys(1) gssapi(2) generic(1) machine_uid_name(2)}.
 326  * The constant GSS_C_NT_MACHINE_UID_NAME should be
 327  * initialized to point to that gss_OID_desc.
 328  */
 329 GSS_DLLIMP extern gss_OID GSS_C_NT_MACHINE_UID_NAME;
 330 
 331 /*
 332  * The implementation must reserve static storage for a
 333  * gss_OID_desc object containing the value
 334  * {10, (void *)"\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x03"},
 335  * corresponding to an object-identifier value of
 336  * {iso(1) member-body(2) United States(840) mit(113554)
 337  * infosys(1) gssapi(2) generic(1) string_uid_name(3)}.
 338  * The constant GSS_C_NT_STRING_UID_NAME should be
 339  * initialized to point to that gss_OID_desc.
 340  */
 341 GSS_DLLIMP extern gss_OID GSS_C_NT_STRING_UID_NAME;
 342 
 343 /*
 344  * The implementation must reserve static storage for a
 345  * gss_OID_desc object containing the value
 346  * {6, (void *)"\x2b\x06\x01\x05\x06\x02"},
 347  * corresponding to an object-identifier value of
 348  * {iso(1) org(3) dod(6) internet(1) security(5)
 349  * nametypes(6) gss-host-based-services(2)).  The constant
 350  * GSS_C_NT_HOSTBASED_SERVICE_X should be initialized to point
 351  * to that gss_OID_desc.  This is a deprecated OID value, and
 352  * implementations wishing to support hostbased-service names
 353  * should instead use the GSS_C_NT_HOSTBASED_SERVICE OID,
 354  * defined below, to identify such names;
 355  * GSS_C_NT_HOSTBASED_SERVICE_X should be accepted a synonym
 356  * for GSS_C_NT_HOSTBASED_SERVICE when presented as an input
 357  * parameter, but should not be emitted by GSS-API
 358  * implementations
 359  */
 360 GSS_DLLIMP extern gss_OID GSS_C_NT_HOSTBASED_SERVICE_X;
 361 
 362 /*
 363  * The implementation must reserve static storage for a
 364  * gss_OID_desc object containing the value
 365  * {10, (void *)"\x2a\x86\x48\x86\xf7\x12"
 366  *              "\x01\x02\x01\x04"}, corresponding to an
 367  * object-identifier value of {iso(1) member-body(2)
 368  * Unites States(840) mit(113554) infosys(1) gssapi(2)
 369  * generic(1) service_name(4)}.  The constant
 370  * GSS_C_NT_HOSTBASED_SERVICE should be initialized
 371  * to point to that gss_OID_desc.
 372  */
 373 GSS_DLLIMP extern gss_OID GSS_C_NT_HOSTBASED_SERVICE;
 374 
 375 /*
 376  * The implementation must reserve static storage for a
 377  * gss_OID_desc object containing the value
 378  * {6, (void *)"\x2b\x06\01\x05\x06\x03"},
 379  * corresponding to an object identifier value of
 380  * {1(iso), 3(org), 6(dod), 1(internet), 5(security),
 381  * 6(nametypes), 3(gss-anonymous-name)}.  The constant
 382  * and GSS_C_NT_ANONYMOUS should be initialized to point
 383  * to that gss_OID_desc.
 384  */
 385 GSS_DLLIMP extern gss_OID GSS_C_NT_ANONYMOUS;
 386 
 387 
 388 /*
 389  * The implementation must reserve static storage for a
 390  * gss_OID_desc object containing the value
 391  * {6, (void *)"\x2b\x06\x01\x05\x06\x04"},
 392  * corresponding to an object-identifier value of
 393  * {1(iso), 3(org), 6(dod), 1(internet), 5(security),
 394  * 6(nametypes), 4(gss-api-exported-name)}.  The constant
 395  * GSS_C_NT_EXPORT_NAME should be initialized to point
 396  * to that gss_OID_desc.
 397  */
 398 GSS_DLLIMP extern gss_OID GSS_C_NT_EXPORT_NAME;
 399 
 400 
 401 /* Function Prototypes */
 402 
 403 GSS_DLLIMP OM_uint32 gss_acquire_cred(
 404         OM_uint32 *,            /* minor_status */
 405         gss_const_name_t,       /* desired_name */
 406         OM_uint32,              /* time_req */
 407         gss_const_OID_set,      /* desired_mechs */
 408         gss_cred_usage_t,       /* cred_usage */
 409         gss_cred_id_t *,        /* output_cred_handle */
 410         gss_OID_set *,          /* actual_mechs */
 411         OM_uint32 *             /* time_rec */
 412 );
 413 
 414 GSS_DLLIMP OM_uint32 gss_release_cred(
 415         OM_uint32 *,            /* minor_status */
 416         gss_cred_id_t *         /* cred_handle */
 417 );
 418 
 419 GSS_DLLIMP OM_uint32 gss_init_sec_context(
 420         OM_uint32 *,            /* minor_status */
 421         gss_const_cred_id_t,    /* claimant_cred_handle */
 422         gss_ctx_id_t *,         /* context_handle */
 423         gss_const_name_t,       /* target_name */
 424         gss_const_OID,          /* mech_type */
 425         OM_uint32,              /* req_flags */
 426         OM_uint32,              /* time_req */
 427         gss_const_channel_bindings_t, /* input_chan_bindings */
 428         gss_const_buffer_t,     /* input_token */
 429         gss_OID *,              /* actual_mech_type */
 430         gss_buffer_t,           /* output_token */
 431         OM_uint32 *,            /* ret_flags */
 432         OM_uint32 *             /* time_rec */
 433 );
 434 
 435 GSS_DLLIMP OM_uint32 gss_accept_sec_context(
 436         OM_uint32 *,            /* minor_status */
 437         gss_ctx_id_t *,         /* context_handle */
 438         gss_const_cred_id_t,    /* acceptor_cred_handle */
 439         gss_const_buffer_t,     /* input_token_buffer */
 440         gss_const_channel_bindings_t, /* input_chan_bindings */
 441         gss_name_t *,           /* src_name */
 442         gss_OID *,              /* mech_type */
 443         gss_buffer_t,           /* output_token */
 444         OM_uint32 *,            /* ret_flags */
 445         OM_uint32 *,            /* time_rec */
 446         gss_cred_id_t *         /* delegated_cred_handle */
 447 );
 448 
 449 GSS_DLLIMP OM_uint32 gss_process_context_token(
 450         OM_uint32 *,            /* minor_status */
 451         gss_const_ctx_id_t,     /* context_handle */
 452         gss_const_buffer_t      /* token_buffer */
 453 );
 454 
 455 GSS_DLLIMP OM_uint32 gss_delete_sec_context(
 456         OM_uint32 *,            /* minor_status */
 457         gss_ctx_id_t *,         /* context_handle */
 458         gss_buffer_t            /* output_token */
 459 );
 460 
 461 GSS_DLLIMP OM_uint32 gss_context_time(
 462         OM_uint32 *,            /* minor_status */
 463         gss_const_ctx_id_t,     /* context_handle */
 464         OM_uint32 *             /* time_rec */
 465 );
 466 
 467 /* New for V2 */
 468 GSS_DLLIMP OM_uint32 gss_get_mic(
 469         OM_uint32 *,            /* minor_status */
 470         gss_const_ctx_id_t,     /* context_handle */
 471         gss_qop_t,              /* qop_req */
 472         gss_const_buffer_t,     /* message_buffer */
 473         gss_buffer_t            /* message_token */
 474 );
 475 
 476 /* New for V2 */
 477 GSS_DLLIMP OM_uint32 gss_verify_mic(
 478         OM_uint32 *,            /* minor_status */
 479         gss_const_ctx_id_t,     /* context_handle */
 480         gss_const_buffer_t,     /* message_buffer */
 481         gss_const_buffer_t,     /* message_token */
 482         gss_qop_t *             /* qop_state */
 483 );
 484 
 485 /* New for V2 */
 486 GSS_DLLIMP OM_uint32 gss_wrap(
 487         OM_uint32 *,            /* minor_status */
 488         gss_const_ctx_id_t,     /* context_handle */
 489         int,                    /* conf_req_flag */
 490         gss_qop_t,              /* qop_req */
 491         gss_const_buffer_t,     /* input_message_buffer */
 492         int *,                  /* conf_state */
 493         gss_buffer_t            /* output_message_buffer */
 494 );
 495 
 496 /* New for V2 */
 497 GSS_DLLIMP OM_uint32 gss_unwrap(
 498         OM_uint32 *,            /* minor_status */
 499         gss_const_ctx_id_t,     /* context_handle */
 500         gss_const_buffer_t,     /* input_message_buffer */
 501         gss_buffer_t,           /* output_message_buffer */
 502         int *,                  /* conf_state */
 503         gss_qop_t *             /* qop_state */
 504 );
 505 
 506 GSS_DLLIMP OM_uint32 gss_display_status(
 507         OM_uint32 *,            /* minor_status */
 508         OM_uint32,              /* status_value */
 509         int,                    /* status_type */
 510         gss_const_OID,          /* mech_type (used to be const) */
 511         OM_uint32 *,            /* message_context */
 512         gss_buffer_t            /* status_string */
 513 );
 514 
 515 GSS_DLLIMP OM_uint32 gss_indicate_mechs(
 516         OM_uint32 *,            /* minor_status */
 517         gss_OID_set *           /* mech_set */
 518 );
 519 
 520 GSS_DLLIMP OM_uint32 gss_compare_name(
 521         OM_uint32 *,            /* minor_status */
 522         gss_const_name_t,       /* name1 */
 523         gss_const_name_t,       /* name2 */
 524         int *                   /* name_equal */
 525 );
 526 
 527 GSS_DLLIMP OM_uint32 gss_display_name(
 528         OM_uint32 *,            /* minor_status */
 529         gss_const_name_t,       /* input_name */
 530         gss_buffer_t,           /* output_name_buffer */
 531         gss_OID *               /* output_name_type */
 532 );
 533 
 534 GSS_DLLIMP OM_uint32 gss_import_name(
 535         OM_uint32 *,            /* minor_status */
 536         gss_const_buffer_t,     /* input_name_buffer */
 537         gss_const_OID,          /* input_name_type(used to be const) */
 538         gss_name_t *            /* output_name */
 539 );
 540 
 541 GSS_DLLIMP OM_uint32 gss_release_name(
 542         OM_uint32 *,            /* minor_status */
 543         gss_name_t *            /* input_name */
 544 );
 545 
 546 GSS_DLLIMP OM_uint32 gss_release_buffer(
 547         OM_uint32 *,            /* minor_status */
 548         gss_buffer_t            /* buffer */
 549 );
 550 
 551 GSS_DLLIMP OM_uint32 gss_release_oid_set(
 552         OM_uint32 *,            /* minor_status */
 553         gss_OID_set *           /* set */
 554 );
 555 
 556 GSS_DLLIMP OM_uint32 gss_inquire_cred(
 557         OM_uint32 *,            /* minor_status */
 558         gss_const_cred_id_t,    /* cred_handle */
 559         gss_name_t *,           /* name */
 560         OM_uint32 *,            /* lifetime */
 561         gss_cred_usage_t *,     /* cred_usage */
 562         gss_OID_set *           /* mechanisms */
 563 );
 564 
 565 /* Last argument new for V2 */
 566 GSS_DLLIMP OM_uint32 gss_inquire_context(
 567         OM_uint32 *,            /* minor_status */
 568         gss_const_ctx_id_t,     /* context_handle */
 569         gss_name_t *,           /* src_name */
 570         gss_name_t *,           /* targ_name */
 571         OM_uint32 *,            /* lifetime_rec */
 572         gss_OID *,              /* mech_type */
 573         OM_uint32 *,            /* ctx_flags */
 574         int *,                  /* locally_initiated */
 575         int *                   /* open */
 576 );
 577 
 578 /* New for V2 */
 579 GSS_DLLIMP OM_uint32 gss_wrap_size_limit(
 580         OM_uint32 *,            /* minor_status */
 581         gss_const_ctx_id_t,     /* context_handle */
 582         int,                    /* conf_req_flag */
 583         gss_qop_t,              /* qop_req */
 584         OM_uint32,              /* req_output_size */
 585         OM_uint32 *             /* max_input_size */
 586 );
 587 
 588 /* New for V2 */
 589 GSS_DLLIMP OM_uint32 gss_add_cred(
 590         OM_uint32 *,            /* minor_status */
 591         gss_const_cred_id_t,    /* input_cred_handle */
 592         gss_const_name_t,       /* desired_name */
 593         gss_const_OID,          /* desired_mech */
 594         gss_cred_usage_t,       /* cred_usage */
 595         OM_uint32,              /* initiator_time_req */
 596         OM_uint32,              /* acceptor_time_req */
 597         gss_cred_id_t *,        /* output_cred_handle */
 598         gss_OID_set *,          /* actual_mechs */
 599         OM_uint32 *,            /* initiator_time_rec */
 600         OM_uint32 *             /* acceptor_time_rec */
 601 );
 602 
 603 /* New for V2 */
 604 GSS_DLLIMP OM_uint32 gss_inquire_cred_by_mech(
 605         OM_uint32 *,            /* minor_status */
 606         gss_const_cred_id_t,    /* cred_handle */
 607         gss_const_OID,          /* mech_type */
 608         gss_name_t *,           /* name */
 609         OM_uint32 *,            /* initiator_lifetime */
 610         OM_uint32 *,            /* acceptor_lifetime */
 611         gss_cred_usage_t *      /* cred_usage */
 612 );
 613 
 614 /* New for V2 */
 615 GSS_DLLIMP OM_uint32 gss_export_sec_context(
 616         OM_uint32 *,            /* minor_status */
 617         gss_ctx_id_t *,         /* context_handle */
 618         gss_buffer_t            /* interprocess_token */
 619 );
 620 
 621 /* New for V2 */
 622 GSS_DLLIMP OM_uint32 gss_import_sec_context(
 623         OM_uint32 *,            /* minor_status */
 624         gss_const_buffer_t,     /* interprocess_token */
 625         gss_ctx_id_t *          /* context_handle */
 626 );
 627 
 628 /* New for V2 */
 629 GSS_DLLIMP OM_uint32 gss_release_oid(
 630         OM_uint32 *,            /* minor_status */
 631         gss_OID *               /* oid */
 632 );
 633 
 634 /* New for V2 */
 635 GSS_DLLIMP OM_uint32 gss_create_empty_oid_set(
 636         OM_uint32 *,            /* minor_status */
 637         gss_OID_set *           /* oid_set */
 638 );
 639 
 640 /* New for V2 */
 641 GSS_DLLIMP OM_uint32 gss_add_oid_set_member(
 642         OM_uint32 *,            /* minor_status */
 643         gss_const_OID,          /* member_oid */
 644         gss_OID_set *           /* oid_set */
 645 );
 646 
 647 /* New for V2 */
 648 GSS_DLLIMP OM_uint32 gss_test_oid_set_member(
 649         OM_uint32 *,            /* minor_status */
 650         gss_const_OID,          /* member */
 651         gss_const_OID_set,      /* set */
 652         int *                   /* present */
 653 );
 654 
 655 /* New for V2 */
 656 GSS_DLLIMP OM_uint32 gss_str_to_oid(
 657         OM_uint32 *,            /* minor_status */
 658         gss_const_buffer_t,     /* oid_str */
 659         gss_OID *               /* oid */
 660 );
 661 
 662 /* New for V2 */
 663 GSS_DLLIMP OM_uint32 gss_oid_to_str(
 664         OM_uint32 *,            /* minor_status */
 665         gss_OID,                /* oid */
 666         gss_buffer_t            /* oid_str */
 667 );
 668 
 669 /* New for V2 */
 670 GSS_DLLIMP OM_uint32 gss_inquire_names_for_mech(
 671         OM_uint32 *,            /* minor_status */
 672         gss_const_OID,          /* mechanism */
 673         gss_OID_set *           /* name_types */
 674 );
 675 
 676 /* New for V2 */
 677 GSS_DLLIMP OM_uint32 gss_export_name(
 678         OM_uint32  *,           /* minor_status */
 679         gss_const_name_t,       /* input_name */
 680         gss_buffer_t            /* exported_name */
 681 );
 682 
 683 /* New for V2 */
 684 GSS_DLLIMP OM_uint32 gss_duplicate_name(
 685         OM_uint32  *,           /* minor_status */
 686         gss_const_name_t,       /* input_name */
 687         gss_name_t *            /* dest_name */
 688 );
 689 
 690 /* New for V2 */
 691 GSS_DLLIMP OM_uint32 gss_canonicalize_name(
 692         OM_uint32  *,           /* minor_status */
 693         gss_const_name_t,       /* input_name */
 694         gss_const_OID,          /* mech_type */
 695         gss_name_t *            /* output_name */
 696 );
 697 
 698 #if TARGET_OS_MAC
 699 #    pragma pack(pop)
 700 #endif
 701 
 702 #ifdef __cplusplus
 703 }
 704 #endif
 705 
 706 #endif /* _GSSAPI_H_ */
</pre></body></html>
