<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>ws Sdiff src/java.security.jgss/share/native/libj2gss/GSSLibStub.c</title>
</head><body id="SUNWwebrev">
<a class="print" href="javascript:print()">Print this page</a>
<pre>Add JGSS JNI bindings for gss cred store functions
fixup SEAM bug uncomments
Add createCredential() with password
Also avoid memory allocation in newGSSOIDSet() renamed to makeGSSOIDset()
which now takes a singleton set argument and either assigns the requested
OID or with SPNEGO returns a static list of all the supported mechs. With
this we no longer need deleteGSSOIDSet().
Add getLocalName() GSSName method
Add actual mechanism to native GSSNameElement state
Fix loss of GSS_S_FAILURE major status in importContext
Revert initGSSBuffer to JDK7 non-copy behaviour
Fix error handling in GSSLibStub
Also improve object size handling in NativeUtil.</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 132         break;
 133       }
 134     }
 135     (*env)-&gt;ReleaseByteArrayElements(env, jbytes, bytes, 0);
 136 
 137     if (found != 1) {
 138       checkStatus(env, NULL, GSS_S_BAD_MECH, 0, "[GSSLibStub_getMechPtr]");
 139       return ptr_to_jlong(NULL);
 140     } else {
 141       return ptr_to_jlong(cOid);
 142     }
 143   } else {
 144     return ptr_to_jlong(GSS_C_NO_OID);
 145   }
 146 }
 147 
 148 /*
 149  * Utility routine which releases the specified gss_channel_bindings_t
 150  * structure.
 151  */
<span class="changed"> 152 void deleteGSSCB(gss_channel_bindings_t cb) {</span>
<span class="changed"> 153 </span>
 154   if (cb == GSS_C_NO_CHANNEL_BINDINGS) return;
 155 
 156   /* release initiator address */
 157   if (cb-&gt;initiator_addrtype != GSS_C_AF_NULLADDR) {
<span class="changed"> 158     resetGSSBuffer(&amp;(cb-&gt;initiator_address));</span>
 159   }
 160   /* release acceptor address */
 161   if (cb-&gt;acceptor_addrtype != GSS_C_AF_NULLADDR) {
<span class="changed"> 162     resetGSSBuffer(&amp;(cb-&gt;acceptor_address));</span>
 163   }
 164   /* release application data */
<span class="changed"> 165   if (cb-&gt;application_data.length != 0) {</span>
<span class="changed"> 166     resetGSSBuffer(&amp;(cb-&gt;application_data));</span>
 167   }
 168   free(cb);
 169 }
 170 
 171 /*
 172  * Utility routine which creates a gss_channel_bindings_t structure
 173  * using the specified org.ietf.jgss.ChannelBinding object.
 174  * NOTE: must call deleteGSSCB() to free up the resources.
 175  */
 176 gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
 177   gss_channel_bindings_t cb;
 178   jobject jinetAddr;
 179   jbyteArray value;
 180 
 181   if (jcb == NULL) {
 182     return GSS_C_NO_CHANNEL_BINDINGS;
 183   }
 184 
 185   cb = malloc(sizeof(struct gss_channel_bindings_struct));
 186   if (cb == NULL) {
 187     throwOutOfMemoryError(env,NULL);
 188     return NULL;
 189   }
 190 
<span class="changed"> 191   // initialize addrtype in CB first</span>
 192   cb-&gt;initiator_addrtype = GSS_C_AF_NULLADDR;
 193   cb-&gt;acceptor_addrtype = GSS_C_AF_NULLADDR;


 194 
 195   // addresses needs to be initialized to empty
 196   memset(&amp;cb-&gt;initiator_address, 0, sizeof(cb-&gt;initiator_address));
 197   memset(&amp;cb-&gt;acceptor_address, 0, sizeof(cb-&gt;acceptor_address));
 198 
 199   /* set up initiator address */
 200   jinetAddr = (*env)-&gt;CallObjectMethod(env, jcb,
 201       MID_ChannelBinding_getInitiatorAddr);
 202   if ((*env)-&gt;ExceptionCheck(env)) {
 203     goto cleanup;
 204   }
 205   if (jinetAddr != NULL) {
 206     value = (*env)-&gt;CallObjectMethod(env, jinetAddr,
 207                                      MID_InetAddress_getAddr);
 208     if ((*env)-&gt;ExceptionCheck(env)) {
 209       goto cleanup;
 210     }
<span class="changed"> 211     cb-&gt;initiator_addrtype = GSS_C_AF_INET;</span>
<span class="changed"> 212     initGSSBuffer(env, value, &amp;(cb-&gt;initiator_address));</span>
 213     if ((*env)-&gt;ExceptionCheck(env)) {
 214       goto cleanup;
 215     }

 216   }
 217   /* set up acceptor address */
 218   jinetAddr = (*env)-&gt;CallObjectMethod(env, jcb,
 219       MID_ChannelBinding_getAcceptorAddr);
 220   if ((*env)-&gt;ExceptionCheck(env)) {
 221     goto cleanup;
 222   }
 223   if (jinetAddr != NULL) {
 224     value = (*env)-&gt;CallObjectMethod(env, jinetAddr,
 225                                      MID_InetAddress_getAddr);
 226     if ((*env)-&gt;ExceptionCheck(env)) {
 227       goto cleanup;
 228     }
<span class="changed"> 229     cb-&gt;acceptor_addrtype = GSS_C_AF_INET;</span>
<span class="changed"> 230     initGSSBuffer(env, value, &amp;(cb-&gt;acceptor_address));</span>
 231     if ((*env)-&gt;ExceptionCheck(env)) {
 232       goto cleanup;
 233     }

 234   }
 235   /* set up application data */
 236   value = (*env)-&gt;CallObjectMethod(env, jcb,
 237                                    MID_ChannelBinding_getAppData);
 238   if ((*env)-&gt;ExceptionCheck(env)) {
 239     goto cleanup;
 240   }
<span class="changed"> 241   initGSSBuffer(env, value, &amp;(cb-&gt;application_data));</span>
 242   if ((*env)-&gt;ExceptionCheck(env)) {
 243     goto cleanup;
 244   }
 245   return cb;
 246 cleanup:
<span class="changed"> 247   deleteGSSCB(cb);</span>
 248   return NULL;
 249 }
 250 
 251 /*
 252  * Utility routine for storing the supplementary information
 253  * into the specified org.ietf.jgss.MessageProp object.
 254  */
 255 void setSupplementaryInfo(JNIEnv *env, jobject jstub, jobject jprop,
 256                           int suppInfo, int minor) {
 257   jboolean isDuplicate, isOld, isUnseq, hasGap;
 258   jstring minorMsg;
 259 
 260   if (suppInfo != GSS_S_COMPLETE) {
 261     isDuplicate = ((suppInfo &amp; GSS_S_DUPLICATE_TOKEN) != 0);
 262     isOld = ((suppInfo &amp; GSS_S_OLD_TOKEN) != 0);
 263     isUnseq = ((suppInfo &amp; GSS_S_UNSEQ_TOKEN) != 0);
 264     hasGap = ((suppInfo &amp; GSS_S_GAP_TOKEN) != 0);
 265     minorMsg = getMinorMessage(env, jstub, minor);
 266     if ((*env)-&gt;ExceptionCheck(env)) {
 267       return;

</pre><hr></hr><pre>
 278  * Signature: ()[Lorg/ietf/jgss/Oid;
 279  */
 280 JNIEXPORT jobjectArray JNICALL
 281 Java_sun_security_jgss_wrapper_GSSLibStub_indicateMechs(JNIEnv *env,
 282                                                         jclass jcls)
 283 {
 284   if (ftab-&gt;mechs != NULL &amp;&amp; ftab-&gt;mechs != GSS_C_NO_OID_SET) {
 285     return getJavaOIDArray(env, ftab-&gt;mechs);
 286   } else return NULL;
 287 }
 288 
 289 /*
 290  * Class:     sun_security_jgss_wrapper_GSSLibStub
 291  * Method:    inquireNamesForMech
 292  * Signature: ()[Lorg/ietf/jgss/Oid;
 293  */
 294 JNIEXPORT jobjectArray JNICALL
 295 Java_sun_security_jgss_wrapper_GSSLibStub_inquireNamesForMech(JNIEnv *env,
 296                                                               jobject jobj)
 297 {
<span class="changed"> 298   OM_uint32 minor, major;</span>
 299   gss_OID mech;
 300   gss_OID_set nameTypes;
 301   jobjectArray result;
 302 
 303   if (ftab-&gt;inquireNamesForMech != NULL) {
 304     mech = (gss_OID)jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
 305     nameTypes = GSS_C_NO_OID_SET;
 306 
 307     /* gss_inquire_names_for_mech(...) =&gt; N/A */
 308     major = (*ftab-&gt;inquireNamesForMech)(&amp;minor, mech, &amp;nameTypes);
 309 
 310     /* release intermediate buffers before checking status */
 311     result = getJavaOIDArray(env, nameTypes);
<span class="changed"> 312     deleteGSSOIDSet(nameTypes);</span>
 313     if ((*env)-&gt;ExceptionCheck(env)) {
 314       return NULL;
 315     }
 316 
 317     checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireNamesForMech]");
 318     if ((*env)-&gt;ExceptionCheck(env)) {
 319       return NULL;
 320     }
 321     return result;
 322   }
 323   return NULL;
 324 }
 325 
 326 /*
 327  * Class:     sun_security_jgss_wrapper_GSSLibStub
 328  * Method:    releaseName
 329  * Signature: (J)V
 330  */
 331 JNIEXPORT void JNICALL
 332 Java_sun_security_jgss_wrapper_GSSLibStub_releaseName(JNIEnv *env,

</pre><hr></hr><pre>
 349 
 350 /*
 351  * Class:     sun_security_jgss_wrapper_GSSLibStub
 352  * Method:    importName
 353  * Signature: ([BLorg/ietf/jgss/Oid;)J
 354  */
 355 JNIEXPORT jlong JNICALL
 356 Java_sun_security_jgss_wrapper_GSSLibStub_importName(JNIEnv *env,
 357                                                      jobject jobj,
 358                                                      jbyteArray jnameVal,
 359                                                      jobject jnameType)
 360 {
 361   OM_uint32 minor, major;
 362   gss_buffer_desc nameVal;
 363   gss_OID nameType;
 364   gss_name_t nameHdl;
 365   nameHdl = GSS_C_NO_NAME;
 366 
 367   TRACE0("[GSSLibStub_importName]");
 368 
<span class="changed"> 369   initGSSBuffer(env, jnameVal, &amp;nameVal);</span>
 370   if ((*env)-&gt;ExceptionCheck(env)) {
 371       return jlong_zero;
 372   }
 373 
 374   nameType = newGSSOID(env, jnameType);
 375   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed"> 376     resetGSSBuffer(&amp;nameVal);</span>
 377     return jlong_zero;
 378   }
 379 
 380   /* gss_import_name(...) =&gt; GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME,
 381      GSS_S_BAD_MECH */
 382   major = (*ftab-&gt;importName)(&amp;minor, &amp;nameVal, nameType, &amp;nameHdl);
 383 
 384   TRACE1("[GSSLibStub_importName] %" PRIuPTR  "", (uintptr_t) nameHdl);
 385 
 386   /* release intermediate buffers */
 387   deleteGSSOID(nameType);
<span class="changed"> 388   resetGSSBuffer(&amp;nameVal);</span>
 389 
 390   checkStatus(env, jobj, major, minor, "[GSSLibStub_importName]");
 391   if ((*env)-&gt;ExceptionCheck(env)) {
 392     return jlong_zero;
 393   }
 394   return ptr_to_jlong(nameHdl);
 395 }
 396 
 397 
 398 /*
 399  * Class:     sun_security_jgss_wrapper_GSSLibStub
 400  * Method:    compareName
 401  * Signature: (JJ)Z
 402  */
 403 JNIEXPORT jboolean JNICALL
 404 Java_sun_security_jgss_wrapper_GSSLibStub_compareName(JNIEnv *env,
 405                                                       jobject jobj,
 406                                                       jlong pName1,
 407                                                       jlong pName2)
 408 {

</pre><hr></hr><pre>
 455     TRACE1("[GSSLibStub_canonicalizeName] MN=%" PRIuPTR "", (uintptr_t)mnNameHdl);
 456 
 457     checkStatus(env, jobj, major, minor, "[GSSLibStub_canonicalizeName]");
 458     if ((*env)-&gt;ExceptionCheck(env)) {
 459       return ptr_to_jlong(GSS_C_NO_NAME);
 460     }
 461     return ptr_to_jlong(mnNameHdl);
 462   }
 463   return ptr_to_jlong(GSS_C_NO_NAME);
 464 }
 465 
 466 /*
 467  * Class:     sun_security_jgss_wrapper_GSSLibStub
 468  * Method:    exportName
 469  * Signature: (J)[B
 470  */
 471 JNIEXPORT jbyteArray JNICALL
 472 Java_sun_security_jgss_wrapper_GSSLibStub_exportName(JNIEnv *env,
 473                                                      jobject jobj,
 474                                                      jlong pName) {
<span class="changed"> 475   OM_uint32 minor, major;</span>
 476   gss_name_t nameHdl, mNameHdl;
<span class="changed"> 477   gss_buffer_desc outBuf;</span>
<span class="changed"> 478   jbyteArray jresult;</span>
 479 
 480   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 481 
 482   TRACE1("[GSSLibStub_exportName] %ld", (long) pName);
 483 
 484   /* gss_export_name(...) =&gt; GSS_S_NAME_NOT_MN, GSS_S_BAD_NAMETYPE,
 485      GSS_S_BAD_NAME */
 486   major = (*ftab-&gt;exportName)(&amp;minor, nameHdl, &amp;outBuf);
 487 
 488   /* canonicalize the internal name to MN and retry */
 489   if (major == GSS_S_NAME_NOT_MN) {
 490     /* release intermediate buffers before retrying */
 491     (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outBuf);
 492 
 493     TRACE0("[GSSLibStub_exportName] canonicalize and re-try");
 494 
 495     mNameHdl = (gss_name_t)jlong_to_ptr(
 496         Java_sun_security_jgss_wrapper_GSSLibStub_canonicalizeName
 497                                         (env, jobj, pName));
 498     if ((*env)-&gt;ExceptionCheck(env)) {
 499         return NULL;
 500     }
 501 
 502     major = (*ftab-&gt;exportName)(&amp;minor, mNameHdl, &amp;outBuf);
<span class="changed"> 503     Java_sun_security_jgss_wrapper_GSSLibStub_releaseName</span>
<span class="changed"> 504                                         (env, jobj, ptr_to_jlong(mNameHdl));</span>
<span class="changed"> 505     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="changed"> 506       /* release intermediate buffers */</span>
<span class="changed"> 507       (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outBuf);</span>
<span class="changed"> 508       return NULL;</span>
<span class="changed"> 509     }</span>
 510   }
 511 
<span class="changed"> 512   /* release intermediate buffers before checking status */</span>
<span class="changed"> 513   jresult = getJavaBuffer(env, &amp;outBuf);</span>
 514   if ((*env)-&gt;ExceptionCheck(env)) {

 515     return NULL;
 516   }



 517 
<span class="changed"> 518   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportName]");</span>
<span class="changed"> 519   if ((*env)-&gt;ExceptionCheck(env)) {</span>




















 520     return NULL;
 521   }
<span class="changed"> 522   return jresult;</span>




































 523 }
 524 
 525 /*
 526  * Class:     sun_security_jgss_wrapper_GSSLibStub
 527  * Method:    displayName
 528  * Signature: (J)[Ljava/lang/Object;
 529  */
 530 JNIEXPORT jobjectArray JNICALL
 531 Java_sun_security_jgss_wrapper_GSSLibStub_displayName(JNIEnv *env,
 532                                                       jobject jobj,
 533                                                       jlong pName) {
 534   OM_uint32 minor, major;
 535   gss_name_t nameHdl;
<span class="changed"> 536   gss_buffer_desc outNameBuf;</span>
 537   gss_OID outNameType;
 538   jstring jname;
 539   jobject jtype;
 540   jobjectArray jresult;
 541 
 542   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 543 
 544   TRACE1("[GSSLibStub_displayName] %ld", (long) pName);
 545 
 546   if (nameHdl == GSS_C_NO_NAME) {
 547     checkStatus(env, jobj, GSS_S_BAD_NAME, 0, "[GSSLibStub_displayName]");
 548     return NULL;
 549   }
 550 
 551   /* gss_display_name(...) =&gt; GSS_S_BAD_NAME */
 552   major = (*ftab-&gt;displayName)(&amp;minor, nameHdl, &amp;outNameBuf, &amp;outNameType);
 553 
 554   /* release intermediate buffers before checking status */
 555   jname = getJavaString(env, &amp;outNameBuf);
 556   if ((*env)-&gt;ExceptionCheck(env)) {

</pre><hr></hr><pre>
 571   /* return immediately if an exception has occurred */
 572   if ((*env)-&gt;ExceptionCheck(env)) {
 573     return NULL;
 574   }
 575 
 576   (*env)-&gt;SetObjectArrayElement(env, jresult, 0, jname);
 577   if ((*env)-&gt;ExceptionCheck(env)) {
 578     return NULL;
 579   }
 580   (*env)-&gt;SetObjectArrayElement(env, jresult, 1, jtype);
 581   if ((*env)-&gt;ExceptionCheck(env)) {
 582     return NULL;
 583   }
 584 
 585   return jresult;
 586 }
 587 
 588 /*
 589  * Class:     sun_security_jgss_wrapper_GSSLibStub
 590  * Method:    acquireCred
<span class="changed"> 591  * Signature: (JII)J</span>
 592  */
 593 JNIEXPORT jlong JNICALL
 594 Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
 595                                                       jobject jobj,
 596                                                       jlong pName,


 597                                                       jint reqTime,
 598                                                       jint usage)
 599 {
 600   OM_uint32 minor, major;
 601   gss_OID mech;

 602   gss_OID_set mechs;
 603   gss_cred_usage_t credUsage;
 604   gss_name_t nameHdl;
 605   gss_cred_id_t credHdl;
 606   credHdl = GSS_C_NO_CREDENTIAL;
 607 
 608   TRACE0("[GSSLibStub_acquireCred]");
 609 
 610   mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
<span class="changed"> 611   mechs = newGSSOIDSet(mech);</span>
 612   credUsage = (gss_cred_usage_t) usage;
 613   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 614 
 615   TRACE2("[GSSLibStub_acquireCred] pName=%ld, usage=%d", (long)pName, usage);
 616 
 617   /* gss_acquire_cred(...) =&gt; GSS_S_BAD_MECH, GSS_S_BAD_NAMETYPE,
 618      GSS_S_BAD_NAME, GSS_S_CREDENTIALS_EXPIRED, GSS_S_NO_CRED */
<span class="changed"> 619   major =</span>
<span class="changed"> 620     (*ftab-&gt;acquireCred)(&amp;minor, nameHdl, reqTime, mechs,</span>
<span class="changed"> 621                      credUsage, &amp;credHdl, NULL, NULL);</span>
<span class="changed"> 622   /* release intermediate buffers */</span>
<span class="changed"> 623   deleteGSSOIDSet(mechs);</span>









































 624 
 625   TRACE1("[GSSLibStub_acquireCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
 626 
 627   checkStatus(env, jobj, major, minor, "[GSSLibStub_acquireCred]");
 628   if ((*env)-&gt;ExceptionCheck(env)) {
 629     return jlong_zero;
 630   }
 631   return ptr_to_jlong(credHdl);
 632 }
 633 
 634 /*
 635  * Class:     sun_security_jgss_wrapper_GSSLibStub


























































 636  * Method:    releaseCred
 637  * Signature: (J)J
 638  */
 639 JNIEXPORT jlong JNICALL
 640 Java_sun_security_jgss_wrapper_GSSLibStub_releaseCred(JNIEnv *env,
 641                                                       jobject jobj,
 642                                                       jlong pCred)
 643 {
 644   OM_uint32 minor, major;
 645   gss_cred_id_t credHdl;
 646 
 647   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
 648 
 649   TRACE1("[GSSLibStub_releaseCred] %ld", (long int)pCred);
 650 
 651   if (credHdl != GSS_C_NO_CREDENTIAL) {
 652     /* gss_release_cred(...) =&gt; GSS_S_NO_CRED(!) */
 653     major = (*ftab-&gt;releaseCred)(&amp;minor, &amp;credHdl);
 654 
 655     checkStatus(env, jobj, major, minor, "[GSSLibStub_releaseCred]");

</pre><hr></hr><pre>
 775   return (jint) usage;
 776 }
 777 /*
 778  * Class:     sun_security_jgss_wrapper_GSSLibStub
 779  * Method:    importContext
 780  * Signature: ([B)Lsun/security/jgss/wrapper/NativeGSSContext;
 781  */
 782 JNIEXPORT jobject JNICALL
 783 Java_sun_security_jgss_wrapper_GSSLibStub_importContext(JNIEnv *env,
 784                                                         jobject jobj,
 785                                                         jbyteArray jctxtToken)
 786 {
 787   OM_uint32 minor, major;
 788   gss_buffer_desc ctxtToken;
 789   gss_ctx_id_t contextHdl;
 790   gss_OID mech, mech2;
 791 
 792   TRACE0("[GSSLibStub_importContext]");
 793 
 794   contextHdl = GSS_C_NO_CONTEXT;
<span class="changed"> 795   initGSSBuffer(env, jctxtToken, &amp;ctxtToken);</span>
 796   if ((*env)-&gt;ExceptionCheck(env)) {
 797     return NULL;
 798   }
 799 
 800   /* gss_import_sec_context(...) =&gt; GSS_S_NO_CONTEXT, GSS_S_DEFECTIVE_TOKEN,
 801      GSS_S_UNAVAILABLE, GSS_S_UNAUTHORIZED */
 802   major = (*ftab-&gt;importSecContext)(&amp;minor, &amp;ctxtToken, &amp;contextHdl);
 803 
 804   TRACE1("[GSSLibStub_importContext] pContext=%" PRIuPTR "", (uintptr_t) contextHdl);
 805 
 806   /* release intermediate buffers */
<span class="changed"> 807   resetGSSBuffer(&amp;ctxtToken);</span>
 808 
 809   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext]");
 810   /* return immediately if an exception has occurred */
 811   if ((*env)-&gt;ExceptionCheck(env)) {
 812     return NULL;
 813   }
 814 
 815   /* now that the context has been imported, proceed to find out
 816      its mech */
 817   major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, NULL, NULL,
 818                               NULL, &amp;mech, NULL, NULL, NULL);
 819 
 820   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext] getMech");
 821   /* return immediately if an exception has occurred */
 822   if ((*env)-&gt;ExceptionCheck(env)) {
 823     return NULL;
 824   }
 825 
 826   mech2 = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj,
 827       FID_GSSLibStub_pMech));
 828 
 829   if (sameMech(mech, mech2) == JNI_TRUE) {
 830     /* mech match - return the context object */
 831     return (*env)-&gt;NewObject(env, CLS_NativeGSSContext,
 832                                  MID_NativeGSSContext_ctor,
 833                                  ptr_to_jlong(contextHdl), jobj);
 834   } else {
 835     /* mech mismatch - clean up then return null */
 836     major = (*ftab-&gt;deleteSecContext)(&amp;minor, &amp;contextHdl, GSS_C_NO_BUFFER);
<span class="changed"> 837     checkStatus(env, jobj, major, minor,</span>
 838         "[GSSLibStub_importContext] cleanup");
 839     return NULL;
 840   }
 841 }
 842 
 843 /*
 844  * Class:     sun_security_jgss_wrapper_GSSLibStub
 845  * Method:    initContext
 846  * Signature: (JJLorg/ietf/jgss/ChannelBinding;[BLsun/security/jgss/wrapper/NativeGSSContext;)[B
 847  */
 848 JNIEXPORT jbyteArray JNICALL
 849 Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
 850                                                       jobject jobj,
 851                                                       jlong pCred,
 852                                                       jlong pName,
 853                                                       jobject jcb,
 854                                                       jbyteArray jinToken,
 855                                                       jobject jcontextSpi)
 856 {
<span class="changed"> 857   OM_uint32 minor, major;</span>
 858   gss_cred_id_t credHdl ;
 859   gss_ctx_id_t contextHdl, contextHdlSave;
 860   gss_name_t targetName;
 861   gss_OID mech;
 862   OM_uint32 flags, aFlags;
 863   OM_uint32 time, aTime;
 864   gss_channel_bindings_t cb;
 865   gss_buffer_desc inToken;
<span class="changed"> 866   gss_buffer_desc outToken;</span>
<span class="changed"> 867   jbyteArray jresult;</span>
<span class="changed"> 868 /* UNCOMMENT after SEAM bug#6287358 is backported to S10</span>
 869   gss_OID aMech;
 870   jobject jMech;
<span class="removed"> 871 */</span>
 872 
 873   TRACE0("[GSSLibStub_initContext]");
 874 
 875   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
 876   contextHdl = contextHdlSave = (gss_ctx_id_t) jlong_to_ptr(
 877     (*env)-&gt;GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
 878   targetName = (gss_name_t) jlong_to_ptr(pName);
 879   mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
 880   flags = (OM_uint32) (*env)-&gt;GetIntField(env, jcontextSpi,
 881                                           FID_NativeGSSContext_flags);
 882   time = getGSSTime((*env)-&gt;GetIntField(env, jcontextSpi,
 883                                         FID_NativeGSSContext_lifetime));
 884   cb = newGSSCB(env, jcb);
 885   if ((*env)-&gt;ExceptionCheck(env)) {
 886     return NULL;
 887   }
 888 
<span class="changed"> 889   initGSSBuffer(env, jinToken, &amp;inToken);</span>
 890   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed"> 891     deleteGSSCB(cb);</span>
 892     return NULL;
 893   }
 894 
 895   TRACE2( "[GSSLibStub_initContext] before: pCred=%" PRIuPTR ", pContext=%" PRIuPTR "",
 896           (uintptr_t)credHdl, (uintptr_t)contextHdl);
 897 
 898   /* gss_init_sec_context(...) =&gt; GSS_S_CONTINUE_NEEDED(!),
 899      GSS_S_DEFECTIVE_TOKEN, GSS_S_NO_CRED, GSS_S_DEFECTIVE_CREDENTIAL(!),
 900      GSS_S_CREDENTIALS_EXPIRED, GSS_S_BAD_BINDINGS, GSS_S_BAD_MIC,
 901      GSS_S_OLD_TOKEN, GSS_S_DUPLICATE_TOKEN, GSS_S_NO_CONTEXT(!),
 902      GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME(!), GSS_S_BAD_MECH */
 903   major = (*ftab-&gt;initSecContext)(&amp;minor, credHdl,
 904                                  &amp;contextHdl, targetName, mech,
<span class="changed"> 905                                  flags, time, cb, &amp;inToken, NULL /*aMech*/,</span>
 906                                  &amp;outToken, &amp;aFlags, &amp;aTime);
 907 
 908   TRACE2("[GSSLibStub_initContext] after: pContext=%" PRIuPTR ", outToken len=%ld",
 909             (uintptr_t)contextHdl, (long)outToken.length);
 910 
 911   // update context handle with the latest value if changed
 912   // this is to work with both MIT and Solaris. Former deletes half-built
 913   // context if error occurs
 914   if (contextHdl != contextHdlSave) {
 915     (*env)-&gt;SetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext,
 916                          ptr_to_jlong(contextHdl));
 917     TRACE1("[GSSLibStub_initContext] set pContext=%" PRIuPTR "", (uintptr_t)contextHdl);
 918   }
 919 
 920   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
 921     /* update member values if needed */
 922     (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
 923     TRACE1("[GSSLibStub_initContext] set flags=0x%x", aFlags);
 924 
 925     if (major == GSS_S_COMPLETE) {
 926       (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
 927                           getJavaTime(aTime));
 928       TRACE0("[GSSLibStub_initContext] context established");
 929 
 930       (*env)-&gt;SetBooleanField(env, jcontextSpi,
 931                               FID_NativeGSSContext_isEstablished,
 932                               JNI_TRUE);
 933 
<span class="changed"> 934 /* UNCOMMENT after SEAM bug#6287358 is backported to S10</span>
<span class="changed"> 935       jMech = getJavaOID(env, aMech);</span>
 936       (*env)-&gt;SetObjectField(env, jcontextSpi,
 937                              FID_NativeGSSContext_actualMech, jMech);
<span class="changed"> 938 */</span>
 939     } else if (major &amp; GSS_S_CONTINUE_NEEDED) {
 940       TRACE0("[GSSLibStub_initContext] context not established");
<span class="changed"> 941       major -= GSS_S_CONTINUE_NEEDED;</span>
 942     }
 943   }
 944 
 945   /* release intermediate buffers before checking status */
<span class="changed"> 946   deleteGSSCB(cb);</span>
<span class="changed"> 947   resetGSSBuffer(&amp;inToken);</span>
<span class="changed"> 948   jresult = getJavaBuffer(env, &amp;outToken);</span>
<span class="changed"> 949   if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="changed"> 950     return NULL;</span>
<span class="changed"> 951   }</span>
 952 
 953   checkStatus(env, jobj, major, minor, "[GSSLibStub_initContext]");
 954   if ((*env)-&gt;ExceptionCheck(env)) {

 955     return NULL;
 956   }
<span class="changed"> 957   return jresult;</span>

 958 }
 959 
 960 /*
 961  * Class:     sun_security_jgss_wrapper_GSSLibStub
 962  * Method:    acceptContext
 963  * Signature: (JLorg/ietf/jgss/ChannelBinding;[BLsun/security/jgss/wrapper/NativeGSSContext;)[B
 964  */
 965 JNIEXPORT jbyteArray JNICALL
 966 Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
 967                                                         jobject jobj,
 968                                                         jlong pCred,
 969                                                         jobject jcb,
 970                                                         jbyteArray jinToken,
 971                                                         jobject jcontextSpi)
 972 {
<span class="changed"> 973   OM_uint32 minor, major;</span>
 974   OM_uint32 minor2, major2;
 975   gss_ctx_id_t contextHdl, contextHdlSave;
 976   gss_cred_id_t credHdl;
 977   gss_buffer_desc inToken;
 978   gss_channel_bindings_t cb;
<span class="changed"> 979   gss_name_t srcName;</span>
<span class="changed"> 980   gss_buffer_desc outToken;</span>
 981   gss_OID aMech;
 982   OM_uint32 aFlags;
 983   OM_uint32 aTime;
<span class="changed"> 984   gss_cred_id_t delCred;</span>
 985   jobject jsrcName = NULL;
 986   jobject jdelCred;
<span class="changed"> 987   jobject jMech;</span>
 988   jboolean setTarget;
<span class="changed"> 989   gss_name_t targetName;</span>
 990   jobject jtargetName;
 991 
 992   TRACE0("[GSSLibStub_acceptContext]");
 993 
 994   contextHdl = contextHdlSave = (gss_ctx_id_t)jlong_to_ptr(
 995     (*env)-&gt;GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
 996   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
<span class="changed"> 997   initGSSBuffer(env, jinToken, &amp;inToken);</span>
 998   if ((*env)-&gt;ExceptionCheck(env)) {
 999     return NULL;
1000   }
1001   cb = newGSSCB(env, jcb);
1002   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed">1003     resetGSSBuffer(&amp;inToken);</span>
1004     return NULL;
1005   }
<span class="removed">1006   srcName = targetName = GSS_C_NO_NAME;</span>
<span class="removed">1007   delCred = GSS_C_NO_CREDENTIAL;</span>
1008   setTarget = (credHdl == GSS_C_NO_CREDENTIAL);
1009   aFlags = 0;
1010 
1011   TRACE2( "[GSSLibStub_acceptContext] before: pCred=%" PRIuPTR ", pContext=%" PRIuPTR "",
1012           (uintptr_t) credHdl, (uintptr_t) contextHdl);
1013 
1014   /* gss_accept_sec_context(...) =&gt; GSS_S_CONTINUE_NEEDED(!),
1015      GSS_S_DEFECTIVE_TOKEN, GSS_S_DEFECTIVE_CREDENTIAL(!),
1016      GSS_S_NO_CRED, GSS_S_CREDENTIALS_EXPIRED, GSS_S_BAD_BINDINGS,
1017      GSS_S_NO_CONTEXT(!), GSS_S_BAD_MIC, GSS_S_OLD_TOKEN,
1018      GSS_S_DUPLICATE_TOKEN, GSS_S_BAD_MECH */
1019   major =
1020     (*ftab-&gt;acceptSecContext)(&amp;minor, &amp;contextHdl, credHdl,
1021                            &amp;inToken, cb, &amp;srcName, &amp;aMech, &amp;outToken,
1022                            &amp;aFlags, &amp;aTime, &amp;delCred);
1023   /* release intermediate buffers before checking status */
1024 
<span class="changed">1025   deleteGSSCB(cb);</span>
<span class="changed">1026   resetGSSBuffer(&amp;inToken);</span>
1027 
1028   TRACE3("[GSSLibStub_acceptContext] after: pCred=%" PRIuPTR ", pContext=%" PRIuPTR ", pDelegCred=%" PRIuPTR "",
1029         (uintptr_t)credHdl, (uintptr_t)contextHdl, (uintptr_t) delCred);
1030 
1031   // update context handle with the latest value if changed
1032   // this is to work with both MIT and Solaris. Former deletes half-built
1033   // context if error occurs
1034   if (contextHdl != contextHdlSave) {
1035     (*env)-&gt;SetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext,
1036                          ptr_to_jlong(contextHdl));
1037     TRACE1("[GSSLibStub_acceptContext] set pContext=%" PRIuPTR "", (uintptr_t)contextHdl);
1038   }
1039 
1040   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
1041     /* update member values if needed */
<span class="changed">1042     // WORKAROUND for a Heimdal bug</span>










1043     if (delCred == GSS_C_NO_CREDENTIAL) {
<span class="changed">1044         aFlags &amp;= 0xfffffffe;</span>
1045     }
1046     (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
1047     TRACE1("[GSSLibStub_acceptContext] set flags=0x%x", aFlags);
1048 
1049     if (setTarget) {
1050       major2 = (*ftab-&gt;inquireContext)(&amp;minor2, contextHdl, NULL,
1051                               &amp;targetName, NULL, NULL, NULL,
1052                               NULL, NULL);
1053       checkStatus(env, jobj, major2, minor2,
1054                     "[GSSLibStub_acceptContext] inquire");
1055       if ((*env)-&gt;ExceptionCheck(env)) {
1056          goto error;
1057       }
1058 
1059       jtargetName = (*env)-&gt;NewObject(env, CLS_GSSNameElement,
1060                                 MID_GSSNameElement_ctor,
<span class="changed">1061                                 ptr_to_jlong(targetName), jobj);</span>
1062       if ((*env)-&gt;ExceptionCheck(env)) {
1063         goto error;
1064       }
1065 
1066       TRACE1("[GSSLibStub_acceptContext] set targetName=%" PRIuPTR "",
1067               (uintptr_t)targetName);

1068 
1069       (*env)-&gt;SetObjectField(env, jcontextSpi, FID_NativeGSSContext_targetName,
1070                              jtargetName);
1071       if ((*env)-&gt;ExceptionCheck(env)) {
1072         goto error;
1073       }
1074     }
1075     if (srcName != GSS_C_NO_NAME) {
1076       jsrcName = (*env)-&gt;NewObject(env, CLS_GSSNameElement,
1077                                    MID_GSSNameElement_ctor,
<span class="changed">1078                                    ptr_to_jlong(srcName), jobj);</span>
1079       if ((*env)-&gt;ExceptionCheck(env)) {
1080         goto error;
1081       }
1082 
1083       TRACE1("[GSSLibStub_acceptContext] set srcName=%" PRIuPTR "", (uintptr_t)srcName);

1084 
1085       (*env)-&gt;SetObjectField(env, jcontextSpi, FID_NativeGSSContext_srcName,
1086                              jsrcName);
1087       if ((*env)-&gt;ExceptionCheck(env)) {
1088         goto error;
1089       }
1090     }
1091     if (major == GSS_S_COMPLETE) {
1092       TRACE0("[GSSLibStub_acceptContext] context established");
1093 
1094       (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
1095                           getJavaTime(aTime));
1096       (*env)-&gt;SetBooleanField(env, jcontextSpi,
1097                               FID_NativeGSSContext_isEstablished,
1098                               JNI_TRUE);
<span class="removed">1099       jMech = getJavaOID(env, aMech);</span>
<span class="removed">1100       if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="removed">1101         goto error;</span>
<span class="removed">1102       }</span>
<span class="removed">1103       (*env)-&gt;SetObjectField(env, jcontextSpi,</span>
<span class="removed">1104                              FID_NativeGSSContext_actualMech, jMech);</span>
1105       if ((*env)-&gt;ExceptionCheck(env)) {
1106         goto error;
1107       }
1108       if (delCred != GSS_C_NO_CREDENTIAL) {
1109         jdelCred = (*env)-&gt;NewObject(env, CLS_GSSCredElement,
1110                                      MID_GSSCredElement_ctor,
1111                                      ptr_to_jlong(delCred), jsrcName, jMech);
1112         if ((*env)-&gt;ExceptionCheck(env)) {
1113           goto error;
1114         }



1115         (*env)-&gt;SetObjectField(env, jcontextSpi,
1116                                FID_NativeGSSContext_delegatedCred,
1117                                jdelCred);
<span class="removed">1118         TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",</span>
<span class="removed">1119                 (uintptr_t) delCred);</span>
1120 
1121         if ((*env)-&gt;ExceptionCheck(env)) {
1122           goto error;
1123         }
1124       }
1125     } else if (major &amp; GSS_S_CONTINUE_NEEDED) {
1126       TRACE0("[GSSLibStub_acceptContext] context not established");
1127 
1128       if (aFlags &amp; GSS_C_PROT_READY_FLAG) {
1129         (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
1130                             getJavaTime(aTime));
1131       }
<span class="changed">1132       major -= GSS_S_CONTINUE_NEEDED;</span>
1133     }
1134   }
<span class="changed">1135   return getJavaBuffer(env, &amp;outToken);</span>








1136 
1137 error:
1138   (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outToken);
1139   if (srcName != GSS_C_NO_NAME) {
1140     (*ftab-&gt;releaseName)(&amp;minor, &amp;srcName);
1141   }
1142   if (targetName != GSS_C_NO_NAME) {
1143     (*ftab-&gt;releaseName)(&amp;minor, &amp;targetName);
1144   }
1145   if (delCred != GSS_C_NO_CREDENTIAL) {
1146     (*ftab-&gt;releaseCred) (&amp;minor, &amp;delCred);
1147   }
1148   return NULL;
1149 }
1150 
1151 /*
1152  * Class:     sun_security_jgss_wrapper_GSSLibStub
1153  * Method:    inquireContext
1154  * Signature: (J)[J
1155  */
1156 JNIEXPORT jlongArray JNICALL
1157 Java_sun_security_jgss_wrapper_GSSLibStub_inquireContext(JNIEnv *env,
1158                                                          jobject jobj,
1159                                                          jlong pContext)
1160 {
<span class="changed">1161   OM_uint32 minor, major;</span>
1162   gss_ctx_id_t contextHdl;
<span class="changed">1163   gss_name_t srcName, targetName;</span>
<span class="changed">1164   OM_uint32 time;</span>
<span class="changed">1165   OM_uint32 flags;</span>
<span class="changed">1166   int isInitiator, isEstablished;</span>


1167   jlong result[6];
1168   jlongArray jresult;
1169 
1170   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1171 
1172   TRACE1("[GSSLibStub_inquireContext] %" PRIuPTR "", (uintptr_t)contextHdl);
1173 
<span class="removed">1174   srcName = targetName = GSS_C_NO_NAME;</span>
<span class="removed">1175   time = 0;</span>
<span class="removed">1176   flags = isInitiator = isEstablished = 0;</span>
<span class="removed">1177 </span>
1178   /* gss_inquire_context(...) =&gt; GSS_S_NO_CONTEXT(!) */
1179   major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, &amp;srcName,
1180                               &amp;targetName, &amp;time, NULL, &amp;flags,
1181                               &amp;isInitiator, &amp;isEstablished);
1182   /* update member values if needed */
1183   TRACE2("[GSSLibStub_inquireContext] srcName %" PRIuPTR ", targetName %" PRIuPTR "",
1184       (uintptr_t)srcName, (uintptr_t)targetName);
1185 
1186   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContext]");
1187   if ((*env)-&gt;ExceptionCheck(env)) {


1188     return NULL;
1189   }
1190   result[0] = ptr_to_jlong(srcName);
1191   result[1] = ptr_to_jlong(targetName);
1192   result[2] = (jlong) isInitiator;
1193   result[3] = (jlong) isEstablished;
1194   result[4] = (jlong) flags;
1195   result[5] = (jlong) getJavaTime(time);
1196 
1197   jresult = (*env)-&gt;NewLongArray(env, 6);
<span class="changed">1198   if (jresult == NULL) {</span>
<span class="changed">1199     return NULL;</span>
<span class="changed">1200   }</span>
1201   (*env)-&gt;SetLongArrayRegion(env, jresult, 0, 6, result);

1202   if ((*env)-&gt;ExceptionCheck(env)) {


1203     return NULL;
1204   }
1205   return jresult;
1206 }
1207 
1208 /*
1209  * Class:     sun_security_jgss_wrapper_GSSLibStub
1210  * Method:    getContextMech
1211  * Signature: (J)Lorg/ietf/jgss/Oid;
1212  */
1213 JNIEXPORT jobject JNICALL
1214 Java_sun_security_jgss_wrapper_GSSLibStub_getContextMech(JNIEnv *env,
1215                                                          jobject jobj,
1216                                                          jlong pContext)
1217 {
1218   OM_uint32 minor, major;
1219   gss_OID mech;
1220   gss_ctx_id_t contextHdl;
1221 
1222   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);

</pre><hr></hr><pre>
1228 
1229   checkStatus(env, jobj, major, minor, "[GSSLibStub_getContextMech]");
1230   /* return immediately if an exception has occurred */
1231   if ((*env)-&gt;ExceptionCheck(env)) {
1232     return NULL;
1233   }
1234 
1235   return getJavaOID(env, mech);
1236 }
1237 
1238 /*
1239  * Class:     sun_security_jgss_wrapper_GSSLibStub
1240  * Method:    getContextName
1241  * Signature: (JZ)J
1242  */
1243 JNIEXPORT jlong JNICALL
1244 Java_sun_security_jgss_wrapper_GSSLibStub_getContextName(JNIEnv *env,
1245   jobject jobj, jlong pContext, jboolean isSrc)
1246 {
1247   OM_uint32 minor, major;
<span class="changed">1248   gss_name_t nameHdl;</span>
1249   gss_ctx_id_t contextHdl;
1250 
1251   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1252 
1253   TRACE2("[GSSLibStub_getContextName] %" PRIuPTR ", isSrc=%d",
1254           (uintptr_t)contextHdl, isSrc);
1255 
<span class="removed">1256   nameHdl = GSS_C_NO_NAME;</span>
1257   if (isSrc == JNI_TRUE) {
1258     major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, &amp;nameHdl, NULL,
1259                                 NULL, NULL, NULL,  NULL, NULL);
1260   } else {
1261     major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, NULL, &amp;nameHdl,
1262                                 NULL, NULL, NULL,  NULL, NULL);
1263   }
1264 
1265   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContextAll]");
1266   /* return immediately if an exception has occurred */
1267   if ((*env)-&gt;ExceptionCheck(env)) {
1268     return jlong_zero;
1269   }
1270 
1271   TRACE1("[GSSLibStub_getContextName] pName=%" PRIuPTR "", (uintptr_t) nameHdl);
1272 
1273   return ptr_to_jlong(nameHdl);
1274 }
1275 
1276 /*

</pre><hr></hr><pre>
1334   return (jlong) ptr_to_jlong(contextHdl);
1335 }
1336 
1337 /*
1338  * Class:     sun_security_jgss_wrapper_GSSLibStub
1339  * Method:    wrapSizeLimit
1340  * Signature: (JIII)I
1341  */
1342 JNIEXPORT jint JNICALL
1343 Java_sun_security_jgss_wrapper_GSSLibStub_wrapSizeLimit(JNIEnv *env,
1344                                                         jobject jobj,
1345                                                         jlong pContext,
1346                                                         jint reqFlag,
1347                                                         jint jqop,
1348                                                         jint joutSize)
1349 {
1350   OM_uint32 minor, major;
1351   gss_ctx_id_t contextHdl;
1352   OM_uint32 outSize, maxInSize;
1353   gss_qop_t qop;

1354 
1355   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1356 
1357   TRACE1("[GSSLibStub_wrapSizeLimit] %" PRIuPTR "", (uintptr_t)contextHdl);
1358 
1359   if (contextHdl == GSS_C_NO_CONTEXT) {
1360     // Twik per javadoc
1361     checkStatus(env, jobj, GSS_S_NO_CONTEXT, 0,
1362         "[GSSLibStub_wrapSizeLimit]");
1363     return 0;
1364   }
1365 
1366   qop = (gss_qop_t) jqop;
1367   outSize = (OM_uint32) joutSize;
1368   /* gss_wrap_size_limit(...) =&gt; GSS_S_NO_CONTEXT(!), GSS_S_CONTEXT_EXPIRED,
1369      GSS_S_BAD_QOP */
1370   major = (*ftab-&gt;wrapSizeLimit)(&amp;minor, contextHdl, reqFlag,
1371                               qop, outSize, &amp;maxInSize);
1372 
1373   checkStatus(env, jobj, major, minor, "[GSSLibStub_wrapSizeLimit]");
1374   if ((*env)-&gt;ExceptionCheck(env)) {
1375     return 0;
1376   }
<span class="changed">1377   return (jint) maxInSize;</span>







1378 }
1379 
1380 /*
1381  * Class:     sun_security_jgss_wrapper_GSSLibStub
1382  * Method:    exportContext
1383  * Signature: (J)[B
1384  */
1385 JNIEXPORT jbyteArray JNICALL
1386 Java_sun_security_jgss_wrapper_GSSLibStub_exportContext(JNIEnv *env,
1387                                                         jobject jobj,
1388                                                         jlong pContext)
1389 {
<span class="changed">1390   OM_uint32 minor, major;</span>
1391   gss_ctx_id_t contextHdl;
<span class="changed">1392   gss_buffer_desc interProcToken;</span>
<span class="changed">1393   jbyteArray jresult;</span>
1394 
1395   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1396 
1397   TRACE1("[GSSLibStub_exportContext] %" PRIuPTR "", (uintptr_t)contextHdl);
1398 
1399   if (contextHdl == GSS_C_NO_CONTEXT) {
1400     // Twik per javadoc
1401     checkStatus(env, jobj, GSS_S_NO_CONTEXT, 0, "[GSSLibStub_exportContext]");
1402     return NULL;
1403   }
1404   /* gss_export_sec_context(...) =&gt; GSS_S_CONTEXT_EXPIRED,
1405      GSS_S_NO_CONTEXT, GSS_S_UNAVAILABLE */
1406   major =
1407     (*ftab-&gt;exportSecContext)(&amp;minor, &amp;contextHdl, &amp;interProcToken);
1408 
<span class="removed">1409   /* release intermediate buffers */</span>
<span class="removed">1410   jresult = getJavaBuffer(env, &amp;interProcToken);</span>
<span class="removed">1411   if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="removed">1412     return NULL;</span>
<span class="removed">1413   }</span>
1414   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportContext]");
1415   if ((*env)-&gt;ExceptionCheck(env)) {

1416     return NULL;
1417   }
1418 
<span class="changed">1419   return jresult;</span>

1420 }
1421 
1422 /*
1423  * Class:     sun_security_jgss_wrapper_GSSLibStub
1424  * Method:    getMic
1425  * Signature: (JI[B)[B
1426  */
1427 JNIEXPORT jbyteArray JNICALL
1428 Java_sun_security_jgss_wrapper_GSSLibStub_getMic(JNIEnv *env, jobject jobj,
1429                                                  jlong pContext, jint jqop,
1430                                                  jbyteArray jmsg)
1431 {
<span class="changed">1432   OM_uint32 minor, major;</span>
1433   gss_ctx_id_t contextHdl;
1434   gss_qop_t qop;
1435   gss_buffer_desc msg;
<span class="changed">1436   gss_buffer_desc msgToken;</span>
<span class="changed">1437   jbyteArray jresult;</span>
1438 
1439   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1440 
1441   TRACE1("[GSSLibStub_getMic] %" PRIuPTR "", (uintptr_t)contextHdl);
1442 
1443   if (contextHdl == GSS_C_NO_CONTEXT) {
1444     // Twik per javadoc
1445     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_getMic]");
1446     return NULL;
1447   }
1448   qop = (gss_qop_t) jqop;
<span class="changed">1449   initGSSBuffer(env, jmsg, &amp;msg);</span>
1450   if ((*env)-&gt;ExceptionCheck(env)) {
1451     return NULL;
1452   }
1453 
1454   /* gss_get_mic(...) =&gt; GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
1455      GSS_S_BAD_QOP */
<span class="changed">1456   major =</span>
<span class="changed">1457     (*ftab-&gt;getMic)(&amp;minor, contextHdl, qop, &amp;msg, &amp;msgToken);</span>
1458 
1459   /* release intermediate buffers */
<span class="changed">1460   resetGSSBuffer(&amp;msg);</span>
<span class="changed">1461   jresult = getJavaBuffer(env, &amp;msgToken);</span>
<span class="changed">1462   if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="changed">1463     return NULL;</span>
<span class="changed">1464   }</span>
1465   checkStatus(env, jobj, major, minor, "[GSSLibStub_getMic]");
1466   if ((*env)-&gt;ExceptionCheck(env)) {

1467     return NULL;
1468   }
1469 
<span class="changed">1470   return jresult;</span>

1471 }
1472 
1473 /*
1474  * Class:     sun_security_jgss_wrapper_GSSLibStub
1475  * Method:    verifyMic
1476  * Signature: (J[B[BLorg/ietf/jgss/MessageProp;)V
1477  */
1478 JNIEXPORT void JNICALL
1479 Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
1480                                                     jobject jobj,
1481                                                     jlong pContext,
1482                                                     jbyteArray jmsgToken,
1483                                                     jbyteArray jmsg,
1484                                                     jobject jprop)
1485 {
1486   OM_uint32 minor, major;
1487   gss_ctx_id_t contextHdl;
1488   gss_buffer_desc msg;
1489   gss_buffer_desc msgToken;
1490   gss_qop_t qop;
1491 
1492   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1493 
1494   TRACE1("[GSSLibStub_verifyMic] %" PRIuPTR "", (uintptr_t)contextHdl);
1495 
1496   if (contextHdl == GSS_C_NO_CONTEXT) {
1497     // Twik per javadoc
1498     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0,
1499         "[GSSLibStub_verifyMic]");
1500     return;
1501   }
1502 
1503   qop = (gss_qop_t) (*env)-&gt;CallIntMethod(env, jprop, MID_MessageProp_getQOP);
1504   if ((*env)-&gt;ExceptionCheck(env)) { return; }
1505 
<span class="changed">1506   initGSSBuffer(env, jmsg, &amp;msg);</span>
1507   if ((*env)-&gt;ExceptionCheck(env)) { return; }
1508 
<span class="changed">1509   initGSSBuffer(env, jmsgToken, &amp;msgToken);</span>
1510   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed">1511     resetGSSBuffer(&amp;msg);</span>
1512     return;
1513   }
1514 
1515   /* gss_verify_mic(...) =&gt; GSS_S_DEFECTIVE_TOKEN, GSS_S_BAD_MIC,
1516      GSS_S_CONTEXT_EXPIRED, GSS_S_DUPLICATE_TOKEN(!), GSS_S_OLD_TOKEN(!),
1517      GSS_S_UNSEQ_TOKEN(!), GSS_S_GAP_TOKEN(!), GSS_S_NO_CONTEXT(!) */
1518   major =
1519     (*ftab-&gt;verifyMic)(&amp;minor, contextHdl, &amp;msg, &amp;msgToken, &amp;qop);
1520 
1521   /* release intermediate buffers */
<span class="changed">1522   resetGSSBuffer(&amp;msg);</span>
<span class="changed">1523   resetGSSBuffer(&amp;msgToken);</span>
1524 





1525   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_verifyMic]");
1526   if ((*env)-&gt;ExceptionCheck(env)) {
1527     return;
1528   }
1529 
1530   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
1531   if ((*env)-&gt;ExceptionCheck(env)) {
1532     return;
1533   }
1534 
1535   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
1536                        minor);
<span class="removed">1537   if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="removed">1538     return;</span>
<span class="removed">1539   }</span>
1540 }
1541 
1542 /*
1543  * Class:     sun_security_jgss_wrapper_GSSLibStub
1544  * Method:    wrap
1545  * Signature: (J[BLorg/ietf/jgss/MessageProp;)[B
1546  */
1547 JNIEXPORT jbyteArray JNICALL
1548 Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
1549                                                jobject jobj,
1550                                                jlong pContext,
1551                                                jbyteArray jmsg,
1552                                                jobject jprop)
1553 {
<span class="changed">1554   OM_uint32 minor, major;</span>
1555   jboolean confFlag;
1556   gss_qop_t qop;
1557   gss_buffer_desc msg;
<span class="changed">1558   gss_buffer_desc msgToken;</span>
1559   int confState;
1560   gss_ctx_id_t contextHdl;
1561   jbyteArray jresult;
1562 
1563   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1564 
1565   TRACE1("[GSSLibStub_wrap] %" PRIuPTR "", (uintptr_t)contextHdl);
1566 
1567   if (contextHdl == GSS_C_NO_CONTEXT) {
1568     // Twik per javadoc
1569     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_wrap]");
1570     return NULL;
1571   }
1572 
1573   confFlag =
1574     (*env)-&gt;CallBooleanMethod(env, jprop, MID_MessageProp_getPrivacy);
1575   if ((*env)-&gt;ExceptionCheck(env)) {
1576     return NULL;
1577   }
1578 
1579   qop = (gss_qop_t)
1580     (*env)-&gt;CallIntMethod(env, jprop, MID_MessageProp_getQOP);
1581   if ((*env)-&gt;ExceptionCheck(env)) {
1582     return NULL;
1583   }
1584 
<span class="changed">1585   initGSSBuffer(env, jmsg, &amp;msg);</span>
1586   if ((*env)-&gt;ExceptionCheck(env)) {
1587     return NULL;
1588   }
1589 
1590   /* gss_wrap(...) =&gt; GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
1591      GSS_S_BAD_QOP */
1592   major = (*ftab-&gt;wrap)(&amp;minor, contextHdl, confFlag, qop, &amp;msg, &amp;confState,
1593                    &amp;msgToken);
1594 
1595   /* release intermediate buffers */
<span class="changed">1596   resetGSSBuffer(&amp;msg);</span>
<span class="changed">1597   jresult = getJavaBuffer(env, &amp;msgToken);</span>

1598   if ((*env)-&gt;ExceptionCheck(env)) {

1599     return NULL;
1600   }
1601 
<span class="changed">1602   checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");</span>

1603   if ((*env)-&gt;ExceptionCheck(env)) {
1604     return NULL;
1605   }
1606 
1607   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
1608                          (confState? JNI_TRUE:JNI_FALSE));
1609   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed">1610     return NULL;</span>

1611   }
1612   return jresult;
1613 }
1614 
1615 /*
1616  * Class:     sun_security_jgss_wrapper_GSSLibStub
1617  * Method:    unwrap
1618  * Signature: (J[BLorg/ietf/jgss/MessageProp;)[B
1619  */
1620 JNIEXPORT jbyteArray JNICALL
1621 Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
1622                                                  jobject jobj,
1623                                                  jlong pContext,
1624                                                  jbyteArray jmsgToken,
1625                                                  jobject jprop)
1626 {
<span class="changed">1627   OM_uint32 minor, major;</span>
1628   gss_ctx_id_t contextHdl;
1629   gss_buffer_desc msgToken;
<span class="changed">1630   gss_buffer_desc msg;</span>
1631   int confState;
1632   gss_qop_t qop;
1633   jbyteArray jresult;
1634 
1635   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1636 
1637   TRACE1("[GSSLibStub_unwrap] %" PRIuPTR "", (uintptr_t)contextHdl);
1638 
1639   if (contextHdl == GSS_C_NO_CONTEXT) {
1640     // Twik per javadoc
1641     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_unwrap]");
1642     return NULL;
1643   }
1644 
<span class="changed">1645   initGSSBuffer(env, jmsgToken, &amp;msgToken);</span>
1646   if ((*env)-&gt;ExceptionCheck(env)) {
1647     return NULL;
1648   }
1649 
1650   confState = 0;
1651   qop = GSS_C_QOP_DEFAULT;
1652   /* gss_unwrap(...) =&gt; GSS_S_DEFECTIVE_TOKEN, GSS_S_BAD_MIC,
1653      GSS_S_CONTEXT_EXPIRED, GSS_S_DUPLICATE_TOKEN(!), GSS_S_OLD_TOKEN(!),
1654      GSS_S_UNSEQ_TOKEN(!), GSS_S_GAP_TOKEN(!), GSS_S_NO_CONTEXT(!) */
1655   major =
1656     (*ftab-&gt;unwrap)(&amp;minor, contextHdl, &amp;msgToken, &amp;msg, &amp;confState, &amp;qop);
1657 
1658   /* release intermediate buffers */
<span class="changed">1659   resetGSSBuffer(&amp;msgToken);</span>
<span class="changed">1660   jresult = getJavaBuffer(env, &amp;msg);</span>






1661   if ((*env)-&gt;ExceptionCheck(env)) {

1662     return NULL;
1663   }
1664 
<span class="changed">1665   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");</span>




1666   if ((*env)-&gt;ExceptionCheck(env)) {
1667     return NULL;
1668   }
1669 
1670   /* update the message prop with relevant info */
1671   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
1672                          (confState != 0));
1673   if ((*env)-&gt;ExceptionCheck(env)) {

1674     return NULL;
1675   }
1676   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
1677   if ((*env)-&gt;ExceptionCheck(env)) {

1678     return NULL;
1679   }
1680   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
1681                          minor);
1682   if ((*env)-&gt;ExceptionCheck(env)) {

1683     return NULL;
1684   }
1685 
1686   return jresult;
1687 }
</pre></td><td><pre>

</pre><hr></hr><pre>
 132         break;
 133       }
 134     }
 135     (*env)-&gt;ReleaseByteArrayElements(env, jbytes, bytes, 0);
 136 
 137     if (found != 1) {
 138       checkStatus(env, NULL, GSS_S_BAD_MECH, 0, "[GSSLibStub_getMechPtr]");
 139       return ptr_to_jlong(NULL);
 140     } else {
 141       return ptr_to_jlong(cOid);
 142     }
 143   } else {
 144     return ptr_to_jlong(GSS_C_NO_OID);
 145   }
 146 }
 147 
 148 /*
 149  * Utility routine which releases the specified gss_channel_bindings_t
 150  * structure.
 151  */
<span class="changed"> 152 static void deleteGSSCB(JNIEnv *env, gss_channel_bindings_t cb) {</span>

 153   if (cb == GSS_C_NO_CHANNEL_BINDINGS) return;
 154 
 155   /* release initiator address */
 156   if (cb-&gt;initiator_addrtype != GSS_C_AF_NULLADDR) {
<span class="changed"> 157     resetGSSBuffer(env, NULL, &amp;(cb-&gt;initiator_address));</span>
 158   }
 159   /* release acceptor address */
 160   if (cb-&gt;acceptor_addrtype != GSS_C_AF_NULLADDR) {
<span class="changed"> 161     resetGSSBuffer(env, NULL, &amp;(cb-&gt;acceptor_address));</span>
 162   }
 163   /* release application data */
<span class="changed"> 164   if (cb-&gt;application_data.value != NULL) {</span>
<span class="changed"> 165     resetGSSBuffer(env, NULL, &amp;(cb-&gt;application_data));</span>
 166   }
 167   free(cb);
 168 }
 169 
 170 /*
 171  * Utility routine which creates a gss_channel_bindings_t structure
 172  * using the specified org.ietf.jgss.ChannelBinding object.
 173  * NOTE: must call deleteGSSCB() to free up the resources.
 174  */
 175 gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
 176   gss_channel_bindings_t cb;
 177   jobject jinetAddr;
 178   jbyteArray value;
 179 
 180   if (jcb == NULL) {
 181     return GSS_C_NO_CHANNEL_BINDINGS;
 182   }
 183 
 184   cb = malloc(sizeof(struct gss_channel_bindings_struct));
 185   if (cb == NULL) {
 186     throwOutOfMemoryError(env,NULL);
 187     return NULL;
 188   }
 189 
<span class="changed"> 190   /* Fully initialize to a state safe for cleanup */</span>
 191   cb-&gt;initiator_addrtype = GSS_C_AF_NULLADDR;
 192   cb-&gt;acceptor_addrtype = GSS_C_AF_NULLADDR;
<span class="new"> 193   cb-&gt;application_data.length = 0;</span>
<span class="new"> 194   cb-&gt;application_data.value = NULL;</span>
 195 
 196   // addresses needs to be initialized to empty
 197   memset(&amp;cb-&gt;initiator_address, 0, sizeof(cb-&gt;initiator_address));
 198   memset(&amp;cb-&gt;acceptor_address, 0, sizeof(cb-&gt;acceptor_address));
 199 
 200   /* set up initiator address */
 201   jinetAddr = (*env)-&gt;CallObjectMethod(env, jcb,
 202       MID_ChannelBinding_getInitiatorAddr);
 203   if ((*env)-&gt;ExceptionCheck(env)) {
 204     goto cleanup;
 205   }
 206   if (jinetAddr != NULL) {
 207     value = (*env)-&gt;CallObjectMethod(env, jinetAddr,
 208                                      MID_InetAddress_getAddr);
 209     if ((*env)-&gt;ExceptionCheck(env)) {
 210       goto cleanup;
 211     }
<span class="changed"> 212     initGSSBuffer(env, value, &amp;(cb-&gt;initiator_address), JNI_TRUE);</span>

 213     if ((*env)-&gt;ExceptionCheck(env)) {
 214       goto cleanup;
 215     }
<span class="new"> 216     cb-&gt;initiator_addrtype = GSS_C_AF_INET;</span>
 217   }
 218   /* set up acceptor address */
 219   jinetAddr = (*env)-&gt;CallObjectMethod(env, jcb,
 220       MID_ChannelBinding_getAcceptorAddr);
 221   if ((*env)-&gt;ExceptionCheck(env)) {
 222     goto cleanup;
 223   }
 224   if (jinetAddr != NULL) {
 225     value = (*env)-&gt;CallObjectMethod(env, jinetAddr,
 226                                      MID_InetAddress_getAddr);
 227     if ((*env)-&gt;ExceptionCheck(env)) {
 228       goto cleanup;
 229     }
<span class="changed"> 230     initGSSBuffer(env, value, &amp;(cb-&gt;acceptor_address), JNI_TRUE);</span>

 231     if ((*env)-&gt;ExceptionCheck(env)) {
 232       goto cleanup;
 233     }
<span class="new"> 234     cb-&gt;acceptor_addrtype = GSS_C_AF_INET;</span>
 235   }
 236   /* set up application data */
 237   value = (*env)-&gt;CallObjectMethod(env, jcb,
 238                                    MID_ChannelBinding_getAppData);
 239   if ((*env)-&gt;ExceptionCheck(env)) {
 240     goto cleanup;
 241   }
<span class="changed"> 242   initGSSBuffer(env, value, &amp;(cb-&gt;application_data), JNI_TRUE);</span>
 243   if ((*env)-&gt;ExceptionCheck(env)) {
 244     goto cleanup;
 245   }
 246   return cb;
 247 cleanup:
<span class="changed"> 248   deleteGSSCB(env, cb);</span>
 249   return NULL;
 250 }
 251 
 252 /*
 253  * Utility routine for storing the supplementary information
 254  * into the specified org.ietf.jgss.MessageProp object.
 255  */
 256 void setSupplementaryInfo(JNIEnv *env, jobject jstub, jobject jprop,
 257                           int suppInfo, int minor) {
 258   jboolean isDuplicate, isOld, isUnseq, hasGap;
 259   jstring minorMsg;
 260 
 261   if (suppInfo != GSS_S_COMPLETE) {
 262     isDuplicate = ((suppInfo &amp; GSS_S_DUPLICATE_TOKEN) != 0);
 263     isOld = ((suppInfo &amp; GSS_S_OLD_TOKEN) != 0);
 264     isUnseq = ((suppInfo &amp; GSS_S_UNSEQ_TOKEN) != 0);
 265     hasGap = ((suppInfo &amp; GSS_S_GAP_TOKEN) != 0);
 266     minorMsg = getMinorMessage(env, jstub, minor);
 267     if ((*env)-&gt;ExceptionCheck(env)) {
 268       return;

</pre><hr></hr><pre>
 279  * Signature: ()[Lorg/ietf/jgss/Oid;
 280  */
 281 JNIEXPORT jobjectArray JNICALL
 282 Java_sun_security_jgss_wrapper_GSSLibStub_indicateMechs(JNIEnv *env,
 283                                                         jclass jcls)
 284 {
 285   if (ftab-&gt;mechs != NULL &amp;&amp; ftab-&gt;mechs != GSS_C_NO_OID_SET) {
 286     return getJavaOIDArray(env, ftab-&gt;mechs);
 287   } else return NULL;
 288 }
 289 
 290 /*
 291  * Class:     sun_security_jgss_wrapper_GSSLibStub
 292  * Method:    inquireNamesForMech
 293  * Signature: ()[Lorg/ietf/jgss/Oid;
 294  */
 295 JNIEXPORT jobjectArray JNICALL
 296 Java_sun_security_jgss_wrapper_GSSLibStub_inquireNamesForMech(JNIEnv *env,
 297                                                               jobject jobj)
 298 {
<span class="changed"> 299   OM_uint32 minor, major, dummy;</span>
 300   gss_OID mech;
 301   gss_OID_set nameTypes;
 302   jobjectArray result;
 303 
 304   if (ftab-&gt;inquireNamesForMech != NULL) {
 305     mech = (gss_OID)jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
 306     nameTypes = GSS_C_NO_OID_SET;
 307 
 308     /* gss_inquire_names_for_mech(...) =&gt; N/A */
 309     major = (*ftab-&gt;inquireNamesForMech)(&amp;minor, mech, &amp;nameTypes);
 310 
 311     /* release intermediate buffers before checking status */
 312     result = getJavaOIDArray(env, nameTypes);
<span class="changed"> 313     (*ftab-&gt;releaseOidSet)(&amp;dummy, &amp;nameTypes);</span>
 314     if ((*env)-&gt;ExceptionCheck(env)) {
 315       return NULL;
 316     }
 317 
 318     checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireNamesForMech]");
 319     if ((*env)-&gt;ExceptionCheck(env)) {
 320       return NULL;
 321     }
 322     return result;
 323   }
 324   return NULL;
 325 }
 326 
 327 /*
 328  * Class:     sun_security_jgss_wrapper_GSSLibStub
 329  * Method:    releaseName
 330  * Signature: (J)V
 331  */
 332 JNIEXPORT void JNICALL
 333 Java_sun_security_jgss_wrapper_GSSLibStub_releaseName(JNIEnv *env,

</pre><hr></hr><pre>
 350 
 351 /*
 352  * Class:     sun_security_jgss_wrapper_GSSLibStub
 353  * Method:    importName
 354  * Signature: ([BLorg/ietf/jgss/Oid;)J
 355  */
 356 JNIEXPORT jlong JNICALL
 357 Java_sun_security_jgss_wrapper_GSSLibStub_importName(JNIEnv *env,
 358                                                      jobject jobj,
 359                                                      jbyteArray jnameVal,
 360                                                      jobject jnameType)
 361 {
 362   OM_uint32 minor, major;
 363   gss_buffer_desc nameVal;
 364   gss_OID nameType;
 365   gss_name_t nameHdl;
 366   nameHdl = GSS_C_NO_NAME;
 367 
 368   TRACE0("[GSSLibStub_importName]");
 369 
<span class="changed"> 370   initGSSBuffer(env, jnameVal, &amp;nameVal, JNI_FALSE);</span>
 371   if ((*env)-&gt;ExceptionCheck(env)) {
 372       return jlong_zero;
 373   }
 374 
 375   nameType = newGSSOID(env, jnameType);
 376   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed"> 377     resetGSSBuffer(env, jnameVal, &amp;nameVal);</span>
 378     return jlong_zero;
 379   }
 380 
 381   /* gss_import_name(...) =&gt; GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME,
 382      GSS_S_BAD_MECH */
 383   major = (*ftab-&gt;importName)(&amp;minor, &amp;nameVal, nameType, &amp;nameHdl);
 384 
 385   TRACE1("[GSSLibStub_importName] %" PRIuPTR  "", (uintptr_t) nameHdl);
 386 
 387   /* release intermediate buffers */
 388   deleteGSSOID(nameType);
<span class="changed"> 389   resetGSSBuffer(env, jnameVal, &amp;nameVal);</span>
 390 
 391   checkStatus(env, jobj, major, minor, "[GSSLibStub_importName]");
 392   if ((*env)-&gt;ExceptionCheck(env)) {
 393     return jlong_zero;
 394   }
 395   return ptr_to_jlong(nameHdl);
 396 }
 397 
 398 
 399 /*
 400  * Class:     sun_security_jgss_wrapper_GSSLibStub
 401  * Method:    compareName
 402  * Signature: (JJ)Z
 403  */
 404 JNIEXPORT jboolean JNICALL
 405 Java_sun_security_jgss_wrapper_GSSLibStub_compareName(JNIEnv *env,
 406                                                       jobject jobj,
 407                                                       jlong pName1,
 408                                                       jlong pName2)
 409 {

</pre><hr></hr><pre>
 456     TRACE1("[GSSLibStub_canonicalizeName] MN=%" PRIuPTR "", (uintptr_t)mnNameHdl);
 457 
 458     checkStatus(env, jobj, major, minor, "[GSSLibStub_canonicalizeName]");
 459     if ((*env)-&gt;ExceptionCheck(env)) {
 460       return ptr_to_jlong(GSS_C_NO_NAME);
 461     }
 462     return ptr_to_jlong(mnNameHdl);
 463   }
 464   return ptr_to_jlong(GSS_C_NO_NAME);
 465 }
 466 
 467 /*
 468  * Class:     sun_security_jgss_wrapper_GSSLibStub
 469  * Method:    exportName
 470  * Signature: (J)[B
 471  */
 472 JNIEXPORT jbyteArray JNICALL
 473 Java_sun_security_jgss_wrapper_GSSLibStub_exportName(JNIEnv *env,
 474                                                      jobject jobj,
 475                                                      jlong pName) {
<span class="changed"> 476   OM_uint32 minor, major, dummy;</span>
 477   gss_name_t nameHdl, mNameHdl;
<span class="changed"> 478   gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;</span>

 479 
 480   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 481 
 482   TRACE1("[GSSLibStub_exportName] %ld", (long) pName);
 483 
 484   /* gss_export_name(...) =&gt; GSS_S_NAME_NOT_MN, GSS_S_BAD_NAMETYPE,
 485      GSS_S_BAD_NAME */
 486   major = (*ftab-&gt;exportName)(&amp;minor, nameHdl, &amp;outBuf);
 487 
 488   /* canonicalize the internal name to MN and retry */
 489   if (major == GSS_S_NAME_NOT_MN) {
 490     /* release intermediate buffers before retrying */
 491     (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outBuf);
 492 
 493     TRACE0("[GSSLibStub_exportName] canonicalize and re-try");
 494 
 495     mNameHdl = (gss_name_t)jlong_to_ptr(
 496         Java_sun_security_jgss_wrapper_GSSLibStub_canonicalizeName
 497                                         (env, jobj, pName));
 498     if ((*env)-&gt;ExceptionCheck(env)) {
 499         return NULL;
 500     }
 501 
 502     major = (*ftab-&gt;exportName)(&amp;minor, mNameHdl, &amp;outBuf);
<span class="changed"> 503     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;mNameHdl);</span>






 504   }
 505 
<span class="changed"> 506   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportName]");</span>

 507   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new"> 508     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;outBuf);</span>
 509     return NULL;
 510   }
<span class="new"> 511   /* Map outBuf to byteArray result and release */</span>
<span class="new"> 512   return getJavaBuffer(env, &amp;outBuf, JNI_TRUE);</span>
<span class="new"> 513 }</span>
 514 
<span class="changed"> 515 /*</span>
<span class="changed"> 516  * Class:     sun_security_jgss_wrapper_GSSLibStub</span>
<span class="changed"> 517  * Method:    localName</span>
<span class="changed"> 518  * Signature: (J)Ljava/lang/String;</span>
<span class="changed"> 519  */</span>
<span class="changed"> 520 JNIEXPORT jstring JNICALL</span>
<span class="changed"> 521 Java_sun_security_jgss_wrapper_GSSLibStub_localName(JNIEnv *env,</span>
<span class="changed"> 522                                                     jobject jobj,</span>
<span class="changed"> 523                                                     jlong pName,</span>
<span class="changed"> 524                                                     jobject jOid)</span>
<span class="changed"> 525 {</span>
<span class="changed"> 526   OM_uint32 minor, major, dummy;</span>
<span class="changed"> 527   gss_name_t nameHdl, mnNameHdl;</span>
<span class="changed"> 528   gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;</span>
<span class="changed"> 529   gss_OID mech;</span>
<span class="changed"> 530 </span>
<span class="changed"> 531   nameHdl = (gss_name_t) jlong_to_ptr(pName);</span>
<span class="changed"> 532 </span>
<span class="changed"> 533   if (ftab-&gt;localName == NULL) {</span>
<span class="changed"> 534     TRACE0("GSSLibStub_localName not supported by GSS provider");</span>
<span class="changed"> 535     checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,</span>
<span class="changed"> 536                 "[GSSLibStub_localName]");</span>
 537     return NULL;
 538   }
<span class="changed"> 539   mech = newGSSOID(env, jOid);</span>
<span class="changed"> 540 </span>
<span class="changed"> 541   /* gss_localname(...) =&gt; GSS_S_NAME_NOT_MN, GSS_S_BAD_NAMETYPE,</span>
<span class="changed"> 542      GSS_S_BAD_NAME */</span>
<span class="changed"> 543   major = (*ftab-&gt;localName)(&amp;minor, nameHdl, mech, &amp;outBuf);</span>
<span class="changed"> 544   if (major == GSS_S_COMPLETE) {</span>
<span class="changed"> 545     deleteGSSOID(mech);</span>
<span class="changed"> 546     return getJavaString(env, &amp;outBuf);</span>
<span class="changed"> 547   }</span>
<span class="changed"> 548   (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outBuf);</span>
<span class="changed"> 549 </span>
<span class="changed"> 550   if (major != GSS_S_NAME_NOT_MN) {</span>
<span class="changed"> 551     checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");</span>
<span class="changed"> 552     goto err;</span>
<span class="changed"> 553   }</span>
<span class="changed"> 554 </span>
<span class="changed"> 555   /* canonicalize the internal name to MN and retry */</span>
<span class="changed"> 556   TRACE0("[GSSLibStub_localName] canonicalize and re-try");</span>
<span class="changed"> 557 </span>
<span class="changed"> 558   major = (*ftab-&gt;canonicalizeName)(&amp;minor, nameHdl, mech, &amp;mnNameHdl);</span>
<span class="changed"> 559   checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");</span>
<span class="changed"> 560   if ((*env)-&gt;ExceptionCheck(env))</span>
<span class="changed"> 561     goto err;</span>
<span class="changed"> 562 </span>
<span class="changed"> 563   major = (*ftab-&gt;localName)(&amp;minor, mnNameHdl, mech, &amp;outBuf);</span>
<span class="changed"> 564   (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;mnNameHdl);</span>
<span class="changed"> 565 </span>
<span class="changed"> 566   checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");</span>
<span class="changed"> 567   if ((*env)-&gt;ExceptionCheck(env) == JNI_FALSE &amp;&amp; major == GSS_S_COMPLETE) {</span>
<span class="changed"> 568     deleteGSSOID(mech);</span>
<span class="changed"> 569     return getJavaString(env, &amp;outBuf);</span>
<span class="changed"> 570   }</span>
<span class="changed"> 571   (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outBuf);</span>
<span class="changed"> 572 </span>
<span class="changed"> 573 err:</span>
<span class="changed"> 574   deleteGSSOID(mech);</span>
<span class="changed"> 575   return NULL;</span>
 576 }
 577 
 578 /*
 579  * Class:     sun_security_jgss_wrapper_GSSLibStub
 580  * Method:    displayName
 581  * Signature: (J)[Ljava/lang/Object;
 582  */
 583 JNIEXPORT jobjectArray JNICALL
 584 Java_sun_security_jgss_wrapper_GSSLibStub_displayName(JNIEnv *env,
 585                                                       jobject jobj,
 586                                                       jlong pName) {
 587   OM_uint32 minor, major;
 588   gss_name_t nameHdl;
<span class="changed"> 589   gss_buffer_desc outNameBuf = GSS_C_EMPTY_BUFFER;</span>
 590   gss_OID outNameType;
 591   jstring jname;
 592   jobject jtype;
 593   jobjectArray jresult;
 594 
 595   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 596 
 597   TRACE1("[GSSLibStub_displayName] %ld", (long) pName);
 598 
 599   if (nameHdl == GSS_C_NO_NAME) {
 600     checkStatus(env, jobj, GSS_S_BAD_NAME, 0, "[GSSLibStub_displayName]");
 601     return NULL;
 602   }
 603 
 604   /* gss_display_name(...) =&gt; GSS_S_BAD_NAME */
 605   major = (*ftab-&gt;displayName)(&amp;minor, nameHdl, &amp;outNameBuf, &amp;outNameType);
 606 
 607   /* release intermediate buffers before checking status */
 608   jname = getJavaString(env, &amp;outNameBuf);
 609   if ((*env)-&gt;ExceptionCheck(env)) {

</pre><hr></hr><pre>
 624   /* return immediately if an exception has occurred */
 625   if ((*env)-&gt;ExceptionCheck(env)) {
 626     return NULL;
 627   }
 628 
 629   (*env)-&gt;SetObjectArrayElement(env, jresult, 0, jname);
 630   if ((*env)-&gt;ExceptionCheck(env)) {
 631     return NULL;
 632   }
 633   (*env)-&gt;SetObjectArrayElement(env, jresult, 1, jtype);
 634   if ((*env)-&gt;ExceptionCheck(env)) {
 635     return NULL;
 636   }
 637 
 638   return jresult;
 639 }
 640 
 641 /*
 642  * Class:     sun_security_jgss_wrapper_GSSLibStub
 643  * Method:    acquireCred
<span class="changed"> 644  * Signature: (JLjava/lang/String;[II)J</span>
 645  */
 646 JNIEXPORT jlong JNICALL
 647 Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
 648                                                       jobject jobj,
 649                                                       jlong pName,
<span class="new"> 650                                                       jstring jPassword,</span>
<span class="new"> 651                                                       jarray jCredStore,</span>
 652                                                       jint reqTime,
 653                                                       jint usage)
 654 {
 655   OM_uint32 minor, major;
 656   gss_OID mech;
<span class="new"> 657   gss_OID_set_desc singleton;</span>
 658   gss_OID_set mechs;
 659   gss_cred_usage_t credUsage;
 660   gss_name_t nameHdl;
 661   gss_cred_id_t credHdl;
 662   credHdl = GSS_C_NO_CREDENTIAL;
 663 
 664   TRACE0("[GSSLibStub_acquireCred]");
 665 
 666   mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
<span class="changed"> 667   mechs = makeGSSOIDSet(&amp;singleton, mech);</span>
 668   credUsage = (gss_cred_usage_t) usage;
 669   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 670 
 671   TRACE2("[GSSLibStub_acquireCred] pName=%ld, usage=%d", (long)pName, usage);
 672 
 673   /* gss_acquire_cred(...) =&gt; GSS_S_BAD_MECH, GSS_S_BAD_NAMETYPE,
 674      GSS_S_BAD_NAME, GSS_S_CREDENTIALS_EXPIRED, GSS_S_NO_CRED */
<span class="changed"> 675   if (jPassword == NULL &amp;&amp; jCredStore == NULL) {</span>
<span class="changed"> 676     major = (*ftab-&gt;acquireCred)(&amp;minor, nameHdl, reqTime, mechs, credUsage,</span>
<span class="changed"> 677                                  &amp;credHdl, NULL, NULL);</span>
<span class="changed"> 678   } else if (jPassword != NULL) {</span>
<span class="changed"> 679     gss_buffer_desc password;</span>
<span class="changed"> 680 </span>
<span class="changed"> 681     if (ftab-&gt;acquireCredWithPassword == NULL) {</span>
<span class="changed"> 682       const char *msg = "GSSLibStub_acquireCred with password not supported "</span>
<span class="changed"> 683           "by GSS provider";</span>
<span class="changed"> 684 </span>
<span class="changed"> 685       TRACE0(msg);</span>
<span class="changed"> 686       checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, msg);</span>
<span class="changed"> 687       return ptr_to_jlong(NULL);</span>
<span class="changed"> 688     }</span>
<span class="changed"> 689 </span>
<span class="changed"> 690     initGSSBufferString(env, jPassword, &amp;password);</span>
<span class="changed"> 691     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="changed"> 692       return jlong_zero;</span>
<span class="changed"> 693     }</span>
<span class="changed"> 694     major = (*ftab-&gt;acquireCredWithPassword)(&amp;minor, nameHdl, &amp;password,</span>
<span class="changed"> 695                                              reqTime, mechs, credUsage,</span>
<span class="changed"> 696                                              &amp;credHdl, NULL, NULL);</span>
<span class="changed"> 697     resetGSSBufferString(env, jPassword, &amp;password);</span>
<span class="changed"> 698   } else {</span>
<span class="changed"> 699     gss_key_value_set_desc credStore = {0, 0};</span>
<span class="changed"> 700 </span>
<span class="changed"> 701     if (ftab-&gt;acquireCredFrom == NULL) {</span>
<span class="changed"> 702       const char *msg = "GSSLibStub_acquireCred from credential store not "</span>
<span class="changed"> 703           "supported by GSS provider";</span>
<span class="changed"> 704 </span>
<span class="changed"> 705       TRACE0("[GSSLibStub_acquireCred] acquiring from a specific credential "</span>
<span class="changed"> 706              "store not supported by GSS provider");</span>
<span class="changed"> 707       checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,</span>
<span class="changed"> 708                   "[GSSLibStub_acquireCred]");</span>
<span class="changed"> 709       return ptr_to_jlong(NULL);</span>
<span class="changed"> 710     }</span>
<span class="changed"> 711 </span>
<span class="changed"> 712     initGSSCredStore(env, jCredStore, &amp;credStore);</span>
<span class="changed"> 713     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="changed"> 714       return jlong_zero;</span>
<span class="changed"> 715     }</span>
<span class="changed"> 716     major = (*ftab-&gt;acquireCredFrom)(&amp;minor, nameHdl, reqTime, mechs,</span>
<span class="changed"> 717                                      credUsage, &amp;credStore, &amp;credHdl,</span>
<span class="changed"> 718                                      NULL, NULL);</span>
<span class="changed"> 719     resetGSSCredStore(env, jCredStore, &amp;credStore);</span>
<span class="changed"> 720   }</span>
 721 
 722   TRACE1("[GSSLibStub_acquireCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
 723 
 724   checkStatus(env, jobj, major, minor, "[GSSLibStub_acquireCred]");
 725   if ((*env)-&gt;ExceptionCheck(env)) {
 726     return jlong_zero;
 727   }
 728   return ptr_to_jlong(credHdl);
 729 }
 730 
 731 /*
 732  * Class:     sun_security_jgss_wrapper_GSSLibStub
<span class="new"> 733  * Method:    storeCred</span>
<span class="new"> 734  * Signature: (JILorg/ietf/jgss/Oid;ZZ[)J</span>
<span class="new"> 735  */</span>
<span class="new"> 736 JNIEXPORT jlong JNICALL</span>
<span class="new"> 737 Java_sun_security_jgss_wrapper_GSSLibStub_storeCred(JNIEnv *env,</span>
<span class="new"> 738                                                     jobject jobj,</span>
<span class="new"> 739                                                     jlong pCred,</span>
<span class="new"> 740                                                     jint usage,</span>
<span class="new"> 741                                                     jobject jmech,</span>
<span class="new"> 742                                                     jboolean overwrite,</span>
<span class="new"> 743                                                     jboolean defaultCred,</span>
<span class="new"> 744                                                     jarray jCredStore)</span>
<span class="new"> 745 {</span>
<span class="new"> 746   OM_uint32 minor, major;</span>
<span class="new"> 747   gss_key_value_set_desc credStore;</span>
<span class="new"> 748   gss_cred_usage_t credUsage;</span>
<span class="new"> 749   gss_cred_id_t credHdl;</span>
<span class="new"> 750   gss_OID mech;</span>
<span class="new"> 751 </span>
<span class="new"> 752   TRACE0("[GSSLibStub_storeCred]");</span>
<span class="new"> 753 </span>
<span class="new"> 754   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);</span>
<span class="new"> 755   credUsage = (gss_cred_usage_t) usage;</span>
<span class="new"> 756 </span>
<span class="new"> 757   mech = newGSSOID(env, jmech);</span>
<span class="new"> 758   if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="new"> 759     return jlong_zero;</span>
<span class="new"> 760   }</span>
<span class="new"> 761 </span>
<span class="new"> 762   TRACE2("[GSSLibStub_storeCred] pCred=%ld, usage=%d", (long)pCred, usage);</span>
<span class="new"> 763 </span>
<span class="new"> 764   if (ftab-&gt;storeCredInto == NULL) {</span>
<span class="new"> 765     TRACE0("[GSSLibStub_storeCred] GSSLibStub_storeCred not supported by "</span>
<span class="new"> 766            "GSS provider");</span>
<span class="new"> 767     checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, "[GSSLibStub_storeCred]");</span>
<span class="new"> 768     return ptr_to_jlong(NULL);</span>
<span class="new"> 769   }</span>
<span class="new"> 770 </span>
<span class="new"> 771   initGSSCredStore(env, jCredStore, &amp;credStore);</span>
<span class="new"> 772   if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="new"> 773     return jlong_zero;</span>
<span class="new"> 774   }</span>
<span class="new"> 775   major = (*ftab-&gt;storeCredInto)(&amp;minor, credHdl, credUsage, mech,</span>
<span class="new"> 776                                  overwrite, defaultCred, &amp;credStore,</span>
<span class="new"> 777                                  NULL, NULL);</span>
<span class="new"> 778   resetGSSCredStore(env, jCredStore, &amp;credStore);</span>
<span class="new"> 779 </span>
<span class="new"> 780   TRACE1("[GSSLibStub_storeCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);</span>
<span class="new"> 781 </span>
<span class="new"> 782   checkStatus(env, jobj, major, minor, "[GSSLibStub_storeCred]");</span>
<span class="new"> 783   if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="new"> 784     return jlong_zero;</span>
<span class="new"> 785   }</span>
<span class="new"> 786   return ptr_to_jlong(credHdl);</span>
<span class="new"> 787 }</span>
<span class="new"> 788 </span>
<span class="new"> 789 /*</span>
<span class="new"> 790  * Class:     sun_security_jgss_wrapper_GSSLibStub</span>
 791  * Method:    releaseCred
 792  * Signature: (J)J
 793  */
 794 JNIEXPORT jlong JNICALL
 795 Java_sun_security_jgss_wrapper_GSSLibStub_releaseCred(JNIEnv *env,
 796                                                       jobject jobj,
 797                                                       jlong pCred)
 798 {
 799   OM_uint32 minor, major;
 800   gss_cred_id_t credHdl;
 801 
 802   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
 803 
 804   TRACE1("[GSSLibStub_releaseCred] %ld", (long int)pCred);
 805 
 806   if (credHdl != GSS_C_NO_CREDENTIAL) {
 807     /* gss_release_cred(...) =&gt; GSS_S_NO_CRED(!) */
 808     major = (*ftab-&gt;releaseCred)(&amp;minor, &amp;credHdl);
 809 
 810     checkStatus(env, jobj, major, minor, "[GSSLibStub_releaseCred]");

</pre><hr></hr><pre>
 930   return (jint) usage;
 931 }
 932 /*
 933  * Class:     sun_security_jgss_wrapper_GSSLibStub
 934  * Method:    importContext
 935  * Signature: ([B)Lsun/security/jgss/wrapper/NativeGSSContext;
 936  */
 937 JNIEXPORT jobject JNICALL
 938 Java_sun_security_jgss_wrapper_GSSLibStub_importContext(JNIEnv *env,
 939                                                         jobject jobj,
 940                                                         jbyteArray jctxtToken)
 941 {
 942   OM_uint32 minor, major;
 943   gss_buffer_desc ctxtToken;
 944   gss_ctx_id_t contextHdl;
 945   gss_OID mech, mech2;
 946 
 947   TRACE0("[GSSLibStub_importContext]");
 948 
 949   contextHdl = GSS_C_NO_CONTEXT;
<span class="changed"> 950   initGSSBuffer(env, jctxtToken, &amp;ctxtToken, JNI_FALSE);</span>
 951   if ((*env)-&gt;ExceptionCheck(env)) {
 952     return NULL;
 953   }
 954 
 955   /* gss_import_sec_context(...) =&gt; GSS_S_NO_CONTEXT, GSS_S_DEFECTIVE_TOKEN,
 956      GSS_S_UNAVAILABLE, GSS_S_UNAUTHORIZED */
 957   major = (*ftab-&gt;importSecContext)(&amp;minor, &amp;ctxtToken, &amp;contextHdl);
 958 
 959   TRACE1("[GSSLibStub_importContext] pContext=%" PRIuPTR "", (uintptr_t) contextHdl);
 960 
 961   /* release intermediate buffers */
<span class="changed"> 962   resetGSSBuffer(env, jctxtToken, &amp;ctxtToken);</span>
 963 
 964   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext]");
 965   /* return immediately if an exception has occurred */
 966   if ((*env)-&gt;ExceptionCheck(env)) {
 967     return NULL;
 968   }
 969 
 970   /* now that the context has been imported, proceed to find out
 971      its mech */
 972   major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, NULL, NULL,
 973                               NULL, &amp;mech, NULL, NULL, NULL);
 974 
 975   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext] getMech");
 976   /* return immediately if an exception has occurred */
 977   if ((*env)-&gt;ExceptionCheck(env)) {
 978     return NULL;
 979   }
 980 
 981   mech2 = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj,
 982       FID_GSSLibStub_pMech));
 983 
 984   if (sameMech(mech, mech2) == JNI_TRUE) {
 985     /* mech match - return the context object */
 986     return (*env)-&gt;NewObject(env, CLS_NativeGSSContext,
 987                                  MID_NativeGSSContext_ctor,
 988                                  ptr_to_jlong(contextHdl), jobj);
 989   } else {
 990     /* mech mismatch - clean up then return null */
 991     major = (*ftab-&gt;deleteSecContext)(&amp;minor, &amp;contextHdl, GSS_C_NO_BUFFER);
<span class="changed"> 992     checkStatus(env, jobj, GSS_S_FAILURE, minor,</span>
 993         "[GSSLibStub_importContext] cleanup");
 994     return NULL;
 995   }
 996 }
 997 
 998 /*
 999  * Class:     sun_security_jgss_wrapper_GSSLibStub
1000  * Method:    initContext
1001  * Signature: (JJLorg/ietf/jgss/ChannelBinding;[BLsun/security/jgss/wrapper/NativeGSSContext;)[B
1002  */
1003 JNIEXPORT jbyteArray JNICALL
1004 Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
1005                                                       jobject jobj,
1006                                                       jlong pCred,
1007                                                       jlong pName,
1008                                                       jobject jcb,
1009                                                       jbyteArray jinToken,
1010                                                       jobject jcontextSpi)
1011 {
<span class="changed">1012   OM_uint32 minor, major, dummy;</span>
1013   gss_cred_id_t credHdl ;
1014   gss_ctx_id_t contextHdl, contextHdlSave;
1015   gss_name_t targetName;
1016   gss_OID mech;
1017   OM_uint32 flags, aFlags;
1018   OM_uint32 time, aTime;
1019   gss_channel_bindings_t cb;
1020   gss_buffer_desc inToken;
<span class="changed">1021   gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;</span>


1022   gss_OID aMech;
1023   jobject jMech;

1024 
1025   TRACE0("[GSSLibStub_initContext]");
1026 
1027   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
1028   contextHdl = contextHdlSave = (gss_ctx_id_t) jlong_to_ptr(
1029     (*env)-&gt;GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
1030   targetName = (gss_name_t) jlong_to_ptr(pName);
1031   mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
1032   flags = (OM_uint32) (*env)-&gt;GetIntField(env, jcontextSpi,
1033                                           FID_NativeGSSContext_flags);
1034   time = getGSSTime((*env)-&gt;GetIntField(env, jcontextSpi,
1035                                         FID_NativeGSSContext_lifetime));
1036   cb = newGSSCB(env, jcb);
1037   if ((*env)-&gt;ExceptionCheck(env)) {
1038     return NULL;
1039   }
1040 
<span class="changed">1041   initGSSBuffer(env, jinToken, &amp;inToken, JNI_FALSE);</span>
1042   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed">1043     deleteGSSCB(env, cb);</span>
1044     return NULL;
1045   }
1046 
1047   TRACE2( "[GSSLibStub_initContext] before: pCred=%" PRIuPTR ", pContext=%" PRIuPTR "",
1048           (uintptr_t)credHdl, (uintptr_t)contextHdl);
1049 
1050   /* gss_init_sec_context(...) =&gt; GSS_S_CONTINUE_NEEDED(!),
1051      GSS_S_DEFECTIVE_TOKEN, GSS_S_NO_CRED, GSS_S_DEFECTIVE_CREDENTIAL(!),
1052      GSS_S_CREDENTIALS_EXPIRED, GSS_S_BAD_BINDINGS, GSS_S_BAD_MIC,
1053      GSS_S_OLD_TOKEN, GSS_S_DUPLICATE_TOKEN, GSS_S_NO_CONTEXT(!),
1054      GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME(!), GSS_S_BAD_MECH */
1055   major = (*ftab-&gt;initSecContext)(&amp;minor, credHdl,
1056                                  &amp;contextHdl, targetName, mech,
<span class="changed">1057                                  flags, time, cb, &amp;inToken, &amp;aMech,</span>
1058                                  &amp;outToken, &amp;aFlags, &amp;aTime);
1059 
1060   TRACE2("[GSSLibStub_initContext] after: pContext=%" PRIuPTR ", outToken len=%ld",
1061             (uintptr_t)contextHdl, (long)outToken.length);
1062 
1063   // update context handle with the latest value if changed
1064   // this is to work with both MIT and Solaris. Former deletes half-built
1065   // context if error occurs
1066   if (contextHdl != contextHdlSave) {
1067     (*env)-&gt;SetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext,
1068                          ptr_to_jlong(contextHdl));
1069     TRACE1("[GSSLibStub_initContext] set pContext=%" PRIuPTR "", (uintptr_t)contextHdl);
1070   }
1071 
1072   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
1073     /* update member values if needed */
1074     (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
1075     TRACE1("[GSSLibStub_initContext] set flags=0x%x", aFlags);
1076 
1077     if (major == GSS_S_COMPLETE) {
1078       (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
1079                           getJavaTime(aTime));
1080       TRACE0("[GSSLibStub_initContext] context established");
1081 
1082       (*env)-&gt;SetBooleanField(env, jcontextSpi,
1083                               FID_NativeGSSContext_isEstablished,
1084                               JNI_TRUE);
1085 
<span class="changed">1086       jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);</span>
<span class="changed">1087       if (!(*env)-&gt;ExceptionCheck(env)) {</span>
1088         (*env)-&gt;SetObjectField(env, jcontextSpi,
1089                                FID_NativeGSSContext_actualMech, jMech);
<span class="changed">1090       }</span>
1091     } else if (major &amp; GSS_S_CONTINUE_NEEDED) {
1092       TRACE0("[GSSLibStub_initContext] context not established");
<span class="changed">1093       major &amp;= ~GSS_S_CONTINUE_NEEDED;</span>
1094     }
1095   }
1096 
1097   /* release intermediate buffers before checking status */
<span class="changed">1098   deleteGSSCB(env, cb);</span>
<span class="changed">1099   resetGSSBuffer(env, jinToken, &amp;inToken);</span>




1100 
1101   checkStatus(env, jobj, major, minor, "[GSSLibStub_initContext]");
1102   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1103     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;outToken);</span>
1104     return NULL;
1105   }
<span class="changed">1106   /* Map outToken to byteArray result and release */</span>
<span class="changed">1107   return getJavaBuffer(env, &amp;outToken, JNI_TRUE);</span>
1108 }
1109 
1110 /*
1111  * Class:     sun_security_jgss_wrapper_GSSLibStub
1112  * Method:    acceptContext
1113  * Signature: (JLorg/ietf/jgss/ChannelBinding;[BLsun/security/jgss/wrapper/NativeGSSContext;)[B
1114  */
1115 JNIEXPORT jbyteArray JNICALL
1116 Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
1117                                                         jobject jobj,
1118                                                         jlong pCred,
1119                                                         jobject jcb,
1120                                                         jbyteArray jinToken,
1121                                                         jobject jcontextSpi)
1122 {
<span class="changed">1123   OM_uint32 minor, major, dummy;</span>
1124   OM_uint32 minor2, major2;
1125   gss_ctx_id_t contextHdl, contextHdlSave;
1126   gss_cred_id_t credHdl;
1127   gss_buffer_desc inToken;
1128   gss_channel_bindings_t cb;
<span class="changed">1129   gss_name_t srcName = GSS_C_NO_NAME;</span>
<span class="changed">1130   gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;</span>
1131   gss_OID aMech;
1132   OM_uint32 aFlags;
1133   OM_uint32 aTime;
<span class="changed">1134   gss_cred_id_t delCred = GSS_C_NO_CREDENTIAL;</span>
1135   jobject jsrcName = NULL;
1136   jobject jdelCred;
<span class="changed">1137   jobject jMech = NULL;</span>
1138   jboolean setTarget;
<span class="changed">1139   gss_name_t targetName = GSS_C_NO_NAME;</span>
1140   jobject jtargetName;
1141 
1142   TRACE0("[GSSLibStub_acceptContext]");
1143 
1144   contextHdl = contextHdlSave = (gss_ctx_id_t)jlong_to_ptr(
1145     (*env)-&gt;GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
1146   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
<span class="changed">1147   initGSSBuffer(env, jinToken, &amp;inToken, JNI_FALSE);</span>
1148   if ((*env)-&gt;ExceptionCheck(env)) {
1149     return NULL;
1150   }
1151   cb = newGSSCB(env, jcb);
1152   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed">1153     resetGSSBuffer(env, jinToken, &amp;inToken);</span>
1154     return NULL;
1155   }


1156   setTarget = (credHdl == GSS_C_NO_CREDENTIAL);
1157   aFlags = 0;
1158 
1159   TRACE2( "[GSSLibStub_acceptContext] before: pCred=%" PRIuPTR ", pContext=%" PRIuPTR "",
1160           (uintptr_t) credHdl, (uintptr_t) contextHdl);
1161 
1162   /* gss_accept_sec_context(...) =&gt; GSS_S_CONTINUE_NEEDED(!),
1163      GSS_S_DEFECTIVE_TOKEN, GSS_S_DEFECTIVE_CREDENTIAL(!),
1164      GSS_S_NO_CRED, GSS_S_CREDENTIALS_EXPIRED, GSS_S_BAD_BINDINGS,
1165      GSS_S_NO_CONTEXT(!), GSS_S_BAD_MIC, GSS_S_OLD_TOKEN,
1166      GSS_S_DUPLICATE_TOKEN, GSS_S_BAD_MECH */
1167   major =
1168     (*ftab-&gt;acceptSecContext)(&amp;minor, &amp;contextHdl, credHdl,
1169                            &amp;inToken, cb, &amp;srcName, &amp;aMech, &amp;outToken,
1170                            &amp;aFlags, &amp;aTime, &amp;delCred);
1171   /* release intermediate buffers before checking status */
1172 
<span class="changed">1173   deleteGSSCB(env, cb);</span>
<span class="changed">1174   resetGSSBuffer(env, jinToken, &amp;inToken);</span>
1175 
1176   TRACE3("[GSSLibStub_acceptContext] after: pCred=%" PRIuPTR ", pContext=%" PRIuPTR ", pDelegCred=%" PRIuPTR "",
1177         (uintptr_t)credHdl, (uintptr_t)contextHdl, (uintptr_t) delCred);
1178 
1179   // update context handle with the latest value if changed
1180   // this is to work with both MIT and Solaris. Former deletes half-built
1181   // context if error occurs
1182   if (contextHdl != contextHdlSave) {
1183     (*env)-&gt;SetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext,
1184                          ptr_to_jlong(contextHdl));
1185     TRACE1("[GSSLibStub_acceptContext] set pContext=%" PRIuPTR "", (uintptr_t)contextHdl);
1186   }
1187 
1188   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
1189     /* update member values if needed */
<span class="changed">1190 </span>
<span class="changed">1191     jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);</span>
<span class="changed">1192     if (!(*env)-&gt;ExceptionCheck(env)) {</span>
<span class="changed">1193       (*env)-&gt;SetObjectField(env, jcontextSpi,</span>
<span class="changed">1194                              FID_NativeGSSContext_actualMech, jMech);</span>
<span class="changed">1195     }</span>
<span class="changed">1196     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="changed">1197       goto error;</span>
<span class="changed">1198     }</span>
<span class="changed">1199 </span>
<span class="changed">1200     /* WORKAROUND for an old Heimdal bug */</span>
1201     if (delCred == GSS_C_NO_CREDENTIAL) {
<span class="changed">1202         aFlags &amp;= ~GSS_C_DELEG_FLAG;</span>
1203     }
1204     (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
1205     TRACE1("[GSSLibStub_acceptContext] set flags=0x%x", aFlags);
1206 
1207     if (setTarget) {
1208       major2 = (*ftab-&gt;inquireContext)(&amp;minor2, contextHdl, NULL,
1209                               &amp;targetName, NULL, NULL, NULL,
1210                               NULL, NULL);
1211       checkStatus(env, jobj, major2, minor2,
1212                     "[GSSLibStub_acceptContext] inquire");
1213       if ((*env)-&gt;ExceptionCheck(env)) {
1214          goto error;
1215       }
1216 
1217       jtargetName = (*env)-&gt;NewObject(env, CLS_GSSNameElement,
1218                                 MID_GSSNameElement_ctor,
<span class="changed">1219                                 ptr_to_jlong(targetName), jMech, jobj);</span>
1220       if ((*env)-&gt;ExceptionCheck(env)) {
1221         goto error;
1222       }
1223 
1224       TRACE1("[GSSLibStub_acceptContext] set targetName=%" PRIuPTR "",
1225               (uintptr_t)targetName);
<span class="new">1226       targetName = GSS_C_NO_NAME;</span>
1227 
1228       (*env)-&gt;SetObjectField(env, jcontextSpi, FID_NativeGSSContext_targetName,
1229                              jtargetName);
1230       if ((*env)-&gt;ExceptionCheck(env)) {
1231         goto error;
1232       }
1233     }
1234     if (srcName != GSS_C_NO_NAME) {
1235       jsrcName = (*env)-&gt;NewObject(env, CLS_GSSNameElement,
1236                                    MID_GSSNameElement_ctor,
<span class="changed">1237                                    ptr_to_jlong(srcName), jMech, jobj);</span>
1238       if ((*env)-&gt;ExceptionCheck(env)) {
1239         goto error;
1240       }
1241 
1242       TRACE1("[GSSLibStub_acceptContext] set srcName=%" PRIuPTR "", (uintptr_t)srcName);
<span class="new">1243       srcName = GSS_C_NO_NAME;</span>
1244 
1245       (*env)-&gt;SetObjectField(env, jcontextSpi, FID_NativeGSSContext_srcName,
1246                              jsrcName);
1247       if ((*env)-&gt;ExceptionCheck(env)) {
1248         goto error;
1249       }
1250     }
1251     if (major == GSS_S_COMPLETE) {
1252       TRACE0("[GSSLibStub_acceptContext] context established");
1253 
1254       (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
1255                           getJavaTime(aTime));
1256       (*env)-&gt;SetBooleanField(env, jcontextSpi,
1257                               FID_NativeGSSContext_isEstablished,
1258                               JNI_TRUE);






1259       if ((*env)-&gt;ExceptionCheck(env)) {
1260         goto error;
1261       }
1262       if (delCred != GSS_C_NO_CREDENTIAL) {
1263         jdelCred = (*env)-&gt;NewObject(env, CLS_GSSCredElement,
1264                                      MID_GSSCredElement_ctor,
1265                                      ptr_to_jlong(delCred), jsrcName, jMech);
1266         if ((*env)-&gt;ExceptionCheck(env)) {
1267           goto error;
1268         }
<span class="new">1269         TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",</span>
<span class="new">1270                 (uintptr_t) delCred);</span>
<span class="new">1271         delCred = GSS_C_NO_CREDENTIAL;</span>
1272         (*env)-&gt;SetObjectField(env, jcontextSpi,
1273                                FID_NativeGSSContext_delegatedCred,
1274                                jdelCred);


1275 
1276         if ((*env)-&gt;ExceptionCheck(env)) {
1277           goto error;
1278         }
1279       }
1280     } else if (major &amp; GSS_S_CONTINUE_NEEDED) {
1281       TRACE0("[GSSLibStub_acceptContext] context not established");
1282 
1283       if (aFlags &amp; GSS_C_PROT_READY_FLAG) {
1284         (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
1285                             getJavaTime(aTime));
1286       }
<span class="changed">1287       major &amp;= ~GSS_S_CONTINUE_NEEDED;</span>
1288     }
1289   }
<span class="changed">1290 </span>
<span class="changed">1291   checkStatus(env, jobj, major, minor, "[GSSLibStub_acceptContext]");</span>
<span class="changed">1292   if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="changed">1293     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;outToken);</span>
<span class="changed">1294     return NULL;</span>
<span class="changed">1295   }</span>
<span class="changed">1296 </span>
<span class="changed">1297   /* Map outToken to byteArray result and release */</span>
<span class="changed">1298   return getJavaBuffer(env, &amp;outToken, JNI_TRUE);</span>
1299 
1300 error:
1301   (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outToken);
1302   if (srcName != GSS_C_NO_NAME) {
1303     (*ftab-&gt;releaseName)(&amp;minor, &amp;srcName);
1304   }
1305   if (targetName != GSS_C_NO_NAME) {
1306     (*ftab-&gt;releaseName)(&amp;minor, &amp;targetName);
1307   }
1308   if (delCred != GSS_C_NO_CREDENTIAL) {
1309     (*ftab-&gt;releaseCred) (&amp;minor, &amp;delCred);
1310   }
1311   return NULL;
1312 }
1313 
1314 /*
1315  * Class:     sun_security_jgss_wrapper_GSSLibStub
1316  * Method:    inquireContext
1317  * Signature: (J)[J
1318  */
1319 JNIEXPORT jlongArray JNICALL
1320 Java_sun_security_jgss_wrapper_GSSLibStub_inquireContext(JNIEnv *env,
1321                                                          jobject jobj,
1322                                                          jlong pContext)
1323 {
<span class="changed">1324   OM_uint32 minor, major, dummy;</span>
1325   gss_ctx_id_t contextHdl;
<span class="changed">1326   gss_name_t srcName = GSS_C_NO_NAME;</span>
<span class="changed">1327   gss_name_t targetName = GSS_C_NO_NAME;</span>
<span class="changed">1328   OM_uint32 time = 0;</span>
<span class="changed">1329   OM_uint32 flags = 0;</span>
<span class="changed">1330   int isInitiator = 0;</span>
<span class="changed">1331   int isEstablished = 0;</span>
1332   jlong result[6];
1333   jlongArray jresult;
1334 
1335   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1336 
1337   TRACE1("[GSSLibStub_inquireContext] %" PRIuPTR "", (uintptr_t)contextHdl);
1338 




1339   /* gss_inquire_context(...) =&gt; GSS_S_NO_CONTEXT(!) */
1340   major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, &amp;srcName,
1341                               &amp;targetName, &amp;time, NULL, &amp;flags,
1342                               &amp;isInitiator, &amp;isEstablished);
1343   /* update member values if needed */
1344   TRACE2("[GSSLibStub_inquireContext] srcName %" PRIuPTR ", targetName %" PRIuPTR "",
1345       (uintptr_t)srcName, (uintptr_t)targetName);
1346 
1347   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContext]");
1348   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1349     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;srcName);</span>
<span class="new">1350     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;targetName);</span>
1351     return NULL;
1352   }
1353   result[0] = ptr_to_jlong(srcName);
1354   result[1] = ptr_to_jlong(targetName);
1355   result[2] = (jlong) isInitiator;
1356   result[3] = (jlong) isEstablished;
1357   result[4] = (jlong) flags;
1358   result[5] = (jlong) getJavaTime(time);
1359 
1360   jresult = (*env)-&gt;NewLongArray(env, 6);
<span class="changed">1361   if (jresult != NULL) {</span>


1362     (*env)-&gt;SetLongArrayRegion(env, jresult, 0, 6, result);
<span class="new">1363   }</span>
1364   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1365     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;srcName);</span>
<span class="new">1366     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;targetName);</span>
1367     return NULL;
1368   }
1369   return jresult;
1370 }
1371 
1372 /*
1373  * Class:     sun_security_jgss_wrapper_GSSLibStub
1374  * Method:    getContextMech
1375  * Signature: (J)Lorg/ietf/jgss/Oid;
1376  */
1377 JNIEXPORT jobject JNICALL
1378 Java_sun_security_jgss_wrapper_GSSLibStub_getContextMech(JNIEnv *env,
1379                                                          jobject jobj,
1380                                                          jlong pContext)
1381 {
1382   OM_uint32 minor, major;
1383   gss_OID mech;
1384   gss_ctx_id_t contextHdl;
1385 
1386   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);

</pre><hr></hr><pre>
1392 
1393   checkStatus(env, jobj, major, minor, "[GSSLibStub_getContextMech]");
1394   /* return immediately if an exception has occurred */
1395   if ((*env)-&gt;ExceptionCheck(env)) {
1396     return NULL;
1397   }
1398 
1399   return getJavaOID(env, mech);
1400 }
1401 
1402 /*
1403  * Class:     sun_security_jgss_wrapper_GSSLibStub
1404  * Method:    getContextName
1405  * Signature: (JZ)J
1406  */
1407 JNIEXPORT jlong JNICALL
1408 Java_sun_security_jgss_wrapper_GSSLibStub_getContextName(JNIEnv *env,
1409   jobject jobj, jlong pContext, jboolean isSrc)
1410 {
1411   OM_uint32 minor, major;
<span class="changed">1412   gss_name_t nameHdl = GSS_C_NO_NAME;</span>
1413   gss_ctx_id_t contextHdl;
1414 
1415   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1416 
1417   TRACE2("[GSSLibStub_getContextName] %" PRIuPTR ", isSrc=%d",
1418           (uintptr_t)contextHdl, isSrc);
1419 

1420   if (isSrc == JNI_TRUE) {
1421     major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, &amp;nameHdl, NULL,
1422                                 NULL, NULL, NULL,  NULL, NULL);
1423   } else {
1424     major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, NULL, &amp;nameHdl,
1425                                 NULL, NULL, NULL,  NULL, NULL);
1426   }
1427 
1428   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContextAll]");
1429   /* return immediately if an exception has occurred */
1430   if ((*env)-&gt;ExceptionCheck(env)) {
1431     return jlong_zero;
1432   }
1433 
1434   TRACE1("[GSSLibStub_getContextName] pName=%" PRIuPTR "", (uintptr_t) nameHdl);
1435 
1436   return ptr_to_jlong(nameHdl);
1437 }
1438 
1439 /*

</pre><hr></hr><pre>
1497   return (jlong) ptr_to_jlong(contextHdl);
1498 }
1499 
1500 /*
1501  * Class:     sun_security_jgss_wrapper_GSSLibStub
1502  * Method:    wrapSizeLimit
1503  * Signature: (JIII)I
1504  */
1505 JNIEXPORT jint JNICALL
1506 Java_sun_security_jgss_wrapper_GSSLibStub_wrapSizeLimit(JNIEnv *env,
1507                                                         jobject jobj,
1508                                                         jlong pContext,
1509                                                         jint reqFlag,
1510                                                         jint jqop,
1511                                                         jint joutSize)
1512 {
1513   OM_uint32 minor, major;
1514   gss_ctx_id_t contextHdl;
1515   OM_uint32 outSize, maxInSize;
1516   gss_qop_t qop;
<span class="new">1517   jint result;</span>
1518 
1519   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1520 
1521   TRACE1("[GSSLibStub_wrapSizeLimit] %" PRIuPTR "", (uintptr_t)contextHdl);
1522 
1523   if (contextHdl == GSS_C_NO_CONTEXT) {
1524     // Twik per javadoc
1525     checkStatus(env, jobj, GSS_S_NO_CONTEXT, 0,
1526         "[GSSLibStub_wrapSizeLimit]");
1527     return 0;
1528   }
1529 
1530   qop = (gss_qop_t) jqop;
1531   outSize = (OM_uint32) joutSize;
1532   /* gss_wrap_size_limit(...) =&gt; GSS_S_NO_CONTEXT(!), GSS_S_CONTEXT_EXPIRED,
1533      GSS_S_BAD_QOP */
1534   major = (*ftab-&gt;wrapSizeLimit)(&amp;minor, contextHdl, reqFlag,
1535                               qop, outSize, &amp;maxInSize);
1536 
1537   checkStatus(env, jobj, major, minor, "[GSSLibStub_wrapSizeLimit]");
1538   if ((*env)-&gt;ExceptionCheck(env)) {
1539     return 0;
1540   }
<span class="changed">1541 </span>
<span class="changed">1542   /* Right-shift maxInSize until it fits into jint */</span>
<span class="changed">1543   result = (jint)maxInSize;</span>
<span class="changed">1544   while (result &lt; 0 || maxInSize != (OM_uint32)result) {</span>
<span class="changed">1545     result = (jint)(maxInSize &gt;&gt;= 1);</span>
<span class="changed">1546   }</span>
<span class="changed">1547 </span>
<span class="changed">1548   return result;</span>
1549 }
1550 
1551 /*
1552  * Class:     sun_security_jgss_wrapper_GSSLibStub
1553  * Method:    exportContext
1554  * Signature: (J)[B
1555  */
1556 JNIEXPORT jbyteArray JNICALL
1557 Java_sun_security_jgss_wrapper_GSSLibStub_exportContext(JNIEnv *env,
1558                                                         jobject jobj,
1559                                                         jlong pContext)
1560 {
<span class="changed">1561   OM_uint32 minor, major, dummy;</span>
1562   gss_ctx_id_t contextHdl;
<span class="changed">1563   gss_buffer_desc interProcToken = GSS_C_EMPTY_BUFFER;</span>

1564 
1565   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1566 
1567   TRACE1("[GSSLibStub_exportContext] %" PRIuPTR "", (uintptr_t)contextHdl);
1568 
1569   if (contextHdl == GSS_C_NO_CONTEXT) {
1570     // Twik per javadoc
1571     checkStatus(env, jobj, GSS_S_NO_CONTEXT, 0, "[GSSLibStub_exportContext]");
1572     return NULL;
1573   }
1574   /* gss_export_sec_context(...) =&gt; GSS_S_CONTEXT_EXPIRED,
1575      GSS_S_NO_CONTEXT, GSS_S_UNAVAILABLE */
1576   major =
1577     (*ftab-&gt;exportSecContext)(&amp;minor, &amp;contextHdl, &amp;interProcToken);
1578 





1579   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportContext]");
1580   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1581     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;interProcToken);</span>
1582     return NULL;
1583   }
1584 
<span class="changed">1585   /* Map interProcToken to byteArray result and release */</span>
<span class="changed">1586   return getJavaBuffer(env, &amp;interProcToken, JNI_TRUE);</span>
1587 }
1588 
1589 /*
1590  * Class:     sun_security_jgss_wrapper_GSSLibStub
1591  * Method:    getMic
1592  * Signature: (JI[B)[B
1593  */
1594 JNIEXPORT jbyteArray JNICALL
1595 Java_sun_security_jgss_wrapper_GSSLibStub_getMic(JNIEnv *env, jobject jobj,
1596                                                  jlong pContext, jint jqop,
1597                                                  jbyteArray jmsg)
1598 {
<span class="changed">1599   OM_uint32 minor, major, dummy;</span>
1600   gss_ctx_id_t contextHdl;
1601   gss_qop_t qop;
1602   gss_buffer_desc msg;
<span class="changed">1603   gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;</span>

1604 
1605   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1606 
1607   TRACE1("[GSSLibStub_getMic] %" PRIuPTR "", (uintptr_t)contextHdl);
1608 
1609   if (contextHdl == GSS_C_NO_CONTEXT) {
1610     // Twik per javadoc
1611     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_getMic]");
1612     return NULL;
1613   }
1614   qop = (gss_qop_t) jqop;
<span class="changed">1615   initGSSBuffer(env, jmsg, &amp;msg, JNI_FALSE);</span>
1616   if ((*env)-&gt;ExceptionCheck(env)) {
1617     return NULL;
1618   }
1619 
1620   /* gss_get_mic(...) =&gt; GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
1621      GSS_S_BAD_QOP */
<span class="changed">1622   major = (*ftab-&gt;getMic)(&amp;minor, contextHdl, qop, &amp;msg, &amp;msgToken);</span>

1623 
1624   /* release intermediate buffers */
<span class="changed">1625   resetGSSBuffer(env, jmsg, &amp;msg);</span>




1626   checkStatus(env, jobj, major, minor, "[GSSLibStub_getMic]");
1627   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1628     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;msgToken);</span>
1629     return NULL;
1630   }
1631 
<span class="changed">1632   /* Map msgToken to byteArray result and release */</span>
<span class="changed">1633   return getJavaBuffer(env, &amp;msgToken, JNI_TRUE);</span>
1634 }
1635 
1636 /*
1637  * Class:     sun_security_jgss_wrapper_GSSLibStub
1638  * Method:    verifyMic
1639  * Signature: (J[B[BLorg/ietf/jgss/MessageProp;)V
1640  */
1641 JNIEXPORT void JNICALL
1642 Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
1643                                                     jobject jobj,
1644                                                     jlong pContext,
1645                                                     jbyteArray jmsgToken,
1646                                                     jbyteArray jmsg,
1647                                                     jobject jprop)
1648 {
1649   OM_uint32 minor, major;
1650   gss_ctx_id_t contextHdl;
1651   gss_buffer_desc msg;
1652   gss_buffer_desc msgToken;
1653   gss_qop_t qop;
1654 
1655   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1656 
1657   TRACE1("[GSSLibStub_verifyMic] %" PRIuPTR "", (uintptr_t)contextHdl);
1658 
1659   if (contextHdl == GSS_C_NO_CONTEXT) {
1660     // Twik per javadoc
1661     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0,
1662         "[GSSLibStub_verifyMic]");
1663     return;
1664   }
1665 
1666   qop = (gss_qop_t) (*env)-&gt;CallIntMethod(env, jprop, MID_MessageProp_getQOP);
1667   if ((*env)-&gt;ExceptionCheck(env)) { return; }
1668 
<span class="changed">1669   initGSSBuffer(env, jmsg, &amp;msg, JNI_FALSE);</span>
1670   if ((*env)-&gt;ExceptionCheck(env)) { return; }
1671 
<span class="changed">1672   initGSSBuffer(env, jmsgToken, &amp;msgToken, JNI_FALSE);</span>
1673   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed">1674     resetGSSBuffer(env, jmsg, &amp;msg);</span>
1675     return;
1676   }
1677 
1678   /* gss_verify_mic(...) =&gt; GSS_S_DEFECTIVE_TOKEN, GSS_S_BAD_MIC,
1679      GSS_S_CONTEXT_EXPIRED, GSS_S_DUPLICATE_TOKEN(!), GSS_S_OLD_TOKEN(!),
1680      GSS_S_UNSEQ_TOKEN(!), GSS_S_GAP_TOKEN(!), GSS_S_NO_CONTEXT(!) */
1681   major =
1682     (*ftab-&gt;verifyMic)(&amp;minor, contextHdl, &amp;msg, &amp;msgToken, &amp;qop);
1683 
1684   /* release intermediate buffers */
<span class="changed">1685   resetGSSBuffer(env, jmsg, &amp;msg);</span>
<span class="changed">1686   resetGSSBuffer(env, jmsgToken, &amp;msgToken);</span>
1687 
<span class="new">1688   /*</span>
<span class="new">1689    * We don't throw on supplementary status codes here, instead we pass only</span>
<span class="new">1690    * GSS_ERROR(major) to checkStatus() and set the supplementary status in the</span>
<span class="new">1691    * message properties.</span>
<span class="new">1692    */</span>
1693   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_verifyMic]");
1694   if ((*env)-&gt;ExceptionCheck(env)) {
1695     return;
1696   }
1697 
1698   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
1699   if ((*env)-&gt;ExceptionCheck(env)) {
1700     return;
1701   }
1702 
1703   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
1704                        minor);



1705 }
1706 
1707 /*
1708  * Class:     sun_security_jgss_wrapper_GSSLibStub
1709  * Method:    wrap
1710  * Signature: (J[BLorg/ietf/jgss/MessageProp;)[B
1711  */
1712 JNIEXPORT jbyteArray JNICALL
1713 Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
1714                                                jobject jobj,
1715                                                jlong pContext,
1716                                                jbyteArray jmsg,
1717                                                jobject jprop)
1718 {
<span class="changed">1719   OM_uint32 minor, major, dummy;</span>
1720   jboolean confFlag;
1721   gss_qop_t qop;
1722   gss_buffer_desc msg;
<span class="changed">1723   gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;</span>
1724   int confState;
1725   gss_ctx_id_t contextHdl;
1726   jbyteArray jresult;
1727 
1728   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1729 
1730   TRACE1("[GSSLibStub_wrap] %" PRIuPTR "", (uintptr_t)contextHdl);
1731 
1732   if (contextHdl == GSS_C_NO_CONTEXT) {
1733     // Twik per javadoc
1734     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_wrap]");
1735     return NULL;
1736   }
1737 
1738   confFlag =
1739     (*env)-&gt;CallBooleanMethod(env, jprop, MID_MessageProp_getPrivacy);
1740   if ((*env)-&gt;ExceptionCheck(env)) {
1741     return NULL;
1742   }
1743 
1744   qop = (gss_qop_t)
1745     (*env)-&gt;CallIntMethod(env, jprop, MID_MessageProp_getQOP);
1746   if ((*env)-&gt;ExceptionCheck(env)) {
1747     return NULL;
1748   }
1749 
<span class="changed">1750   initGSSBuffer(env, jmsg, &amp;msg, JNI_FALSE);</span>
1751   if ((*env)-&gt;ExceptionCheck(env)) {
1752     return NULL;
1753   }
1754 
1755   /* gss_wrap(...) =&gt; GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
1756      GSS_S_BAD_QOP */
1757   major = (*ftab-&gt;wrap)(&amp;minor, contextHdl, confFlag, qop, &amp;msg, &amp;confState,
1758                    &amp;msgToken);
1759 
1760   /* release intermediate buffers */
<span class="changed">1761   resetGSSBuffer(env, jmsg, &amp;msg);</span>
<span class="changed">1762   checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");</span>
<span class="changed">1763 </span>
1764   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1765     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;msgToken);</span>
1766     return NULL;
1767   }
1768 
<span class="changed">1769   /* Map msgToken to byteArray result and release */</span>
<span class="changed">1770   jresult = getJavaBuffer(env, &amp;msgToken, JNI_TRUE);</span>
1771   if ((*env)-&gt;ExceptionCheck(env)) {
1772     return NULL;
1773   }
1774 
1775   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
1776                          (confState? JNI_TRUE:JNI_FALSE));
1777   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="changed">1778     (*env)-&gt;DeleteLocalRef(env, jresult);</span>
<span class="changed">1779     jresult = NULL;</span>
1780   }
1781   return jresult;
1782 }
1783 
1784 /*
1785  * Class:     sun_security_jgss_wrapper_GSSLibStub
1786  * Method:    unwrap
1787  * Signature: (J[BLorg/ietf/jgss/MessageProp;)[B
1788  */
1789 JNIEXPORT jbyteArray JNICALL
1790 Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
1791                                                  jobject jobj,
1792                                                  jlong pContext,
1793                                                  jbyteArray jmsgToken,
1794                                                  jobject jprop)
1795 {
<span class="changed">1796   OM_uint32 minor, major, dummy;</span>
1797   gss_ctx_id_t contextHdl;
1798   gss_buffer_desc msgToken;
<span class="changed">1799   gss_buffer_desc msg = GSS_C_EMPTY_BUFFER;</span>
1800   int confState;
1801   gss_qop_t qop;
1802   jbyteArray jresult;
1803 
1804   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1805 
1806   TRACE1("[GSSLibStub_unwrap] %" PRIuPTR "", (uintptr_t)contextHdl);
1807 
1808   if (contextHdl == GSS_C_NO_CONTEXT) {
1809     // Twik per javadoc
1810     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_unwrap]");
1811     return NULL;
1812   }
1813 
<span class="changed">1814   initGSSBuffer(env, jmsgToken, &amp;msgToken, JNI_FALSE);</span>
1815   if ((*env)-&gt;ExceptionCheck(env)) {
1816     return NULL;
1817   }
1818 
1819   confState = 0;
1820   qop = GSS_C_QOP_DEFAULT;
1821   /* gss_unwrap(...) =&gt; GSS_S_DEFECTIVE_TOKEN, GSS_S_BAD_MIC,
1822      GSS_S_CONTEXT_EXPIRED, GSS_S_DUPLICATE_TOKEN(!), GSS_S_OLD_TOKEN(!),
1823      GSS_S_UNSEQ_TOKEN(!), GSS_S_GAP_TOKEN(!), GSS_S_NO_CONTEXT(!) */
1824   major =
1825     (*ftab-&gt;unwrap)(&amp;minor, contextHdl, &amp;msgToken, &amp;msg, &amp;confState, &amp;qop);
1826 
1827   /* release intermediate buffers */
<span class="changed">1828   resetGSSBuffer(env, jmsgToken, &amp;msgToken);</span>
<span class="changed">1829 </span>
<span class="changed">1830   /*</span>
<span class="changed">1831    * We don't throw on supplementary status codes here, instead we pass only</span>
<span class="changed">1832    * GSS_ERROR(major) to checkStatus() and set the supplementary status in the</span>
<span class="changed">1833    * message properties.</span>
<span class="changed">1834    */</span>
<span class="changed">1835   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");</span>
1836   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1837     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;msg);</span>
1838     return NULL;
1839   }
1840 
<span class="changed">1841   /*</span>
<span class="changed">1842    * Map msg to byteArray result and release, zero length msg maps to empty</span>
<span class="changed">1843    * byte array, not null.</span>
<span class="changed">1844    */</span>
<span class="changed">1845   jresult = getJavaBuffer(env, &amp;msg, JNI_FALSE);</span>
1846   if ((*env)-&gt;ExceptionCheck(env)) {
1847     return NULL;
1848   }
1849 
1850   /* update the message prop with relevant info */
1851   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
1852                          (confState != 0));
1853   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1854     (*env)-&gt;DeleteLocalRef(env, jresult);</span>
1855     return NULL;
1856   }
1857   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
1858   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1859     (*env)-&gt;DeleteLocalRef(env, jresult);</span>
1860     return NULL;
1861   }
1862   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
1863                          minor);
1864   if ((*env)-&gt;ExceptionCheck(env)) {
<span class="new">1865     (*env)-&gt;DeleteLocalRef(env, jresult);</span>
1866     return NULL;
1867   }
1868 
1869   return jresult;
1870 }
</pre></td>
</tr></table>
</body></html>
