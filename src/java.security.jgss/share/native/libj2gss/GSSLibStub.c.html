<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>ws New src/java.security.jgss/share/native/libj2gss/GSSLibStub.c</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include "sun_security_jgss_wrapper_GSSLibStub.h"
  27 #include "NativeUtil.h"
  28 #include "NativeFunc.h"
  29 #include "jlong.h"
  30 #include &lt;jni.h&gt;
  31 
  32 /* Constants for indicating what type of info is needed for inquiries */
  33 const int TYPE_CRED_NAME = 10;
  34 const int TYPE_CRED_TIME = 11;
  35 const int TYPE_CRED_USAGE = 12;
  36 
  37 /*
  38  * Class:     sun_security_jgss_wrapper_GSSLibStub
  39  * Method:    init
  40  * Signature: (Ljava/lang/String;Z)Z
  41  */
  42 JNIEXPORT jboolean JNICALL
  43 Java_sun_security_jgss_wrapper_GSSLibStub_init(JNIEnv *env,
  44                                                jclass jcls,
  45                                                jstring jlibName,
  46                                                jboolean jDebug) {
  47     const char *libName;
  48     int failed;
  49     char *error = NULL;
  50 
  51     if (!jDebug) {
  52       JGSS_DEBUG = 0;
  53     } else {
  54       JGSS_DEBUG = 1;
  55     }
  56 
  57     if (jlibName == NULL) {
  58         TRACE0("[GSSLibStub_init] GSS lib name is NULL");
  59         return JNI_FALSE;
  60     }
  61 
  62     libName = (*env)-&gt;GetStringUTFChars(env, jlibName, NULL);
  63     if (libName == NULL) {
  64         return JNI_FALSE;
  65     }
  66     TRACE1("[GSSLibStub_init] libName=%s", libName);
  67 
  68     /* initialize global function table */
  69     failed = loadNative(libName);
  70     (*env)-&gt;ReleaseStringUTFChars(env, jlibName, libName);
  71 
  72     if (!failed) {
  73         return JNI_TRUE;
  74     } else {
  75         if (JGSS_DEBUG) {
  76 #ifdef WIN32
  77             #define MAX_MSG_SIZE 256
  78             static CHAR szMsgBuf[MAX_MSG_SIZE];
  79             DWORD dwRes;
  80             DWORD dwError = GetLastError();
  81             dwRes = FormatMessage (
  82                     FORMAT_MESSAGE_FROM_SYSTEM,
  83                     NULL,
  84                     dwError,
  85                     0,
  86                     szMsgBuf,
  87                     MAX_MSG_SIZE,
  88                     NULL);
  89             if (0 == dwRes) {
  90                 printf("GSS-API: Unknown failure %d\n", dwError);
  91             } else {
  92                 printf("GSS-API: %s\n",szMsgBuf);
  93             }
  94 #else
  95             char* error = dlerror();
  96             if (error) {
  97                 TRACE0(error);
  98             }
  99 #endif
 100         }
 101         return JNI_FALSE;
 102     }
 103 }
 104 
 105 /*
 106  * Class:     sun_security_jgss_wrapper_GSSLibStub
 107  * Method:    getMechPtr
 108  * Signature: ([B)J
 109  */
 110 JNIEXPORT jlong JNICALL
 111 Java_sun_security_jgss_wrapper_GSSLibStub_getMechPtr(JNIEnv *env,
 112                                                      jclass jcls,
 113                                                      jbyteArray jbytes) {
 114   gss_OID cOid;
 115   unsigned int i, len;
 116   jbyte* bytes;
 117   int found;
 118 
 119   if (jbytes != NULL) {
 120     found = 0;
 121     len = (unsigned int)((*env)-&gt;GetArrayLength(env, jbytes) - 2);
 122     bytes = (*env)-&gt;GetByteArrayElements(env, jbytes, NULL);
 123     if (bytes == NULL) {
 124       return ptr_to_jlong(NULL);
 125     }
 126     for (i = 0; i &lt; ftab-&gt;mechs-&gt;count; i++) {
 127       cOid = &amp;(ftab-&gt;mechs-&gt;elements[i]);
 128       if (len == cOid-&gt;length &amp;&amp;
 129           (memcmp(cOid-&gt;elements, (bytes + 2), len) == 0)) {
 130         // Found a match
 131         found = 1;
 132         break;
 133       }
 134     }
 135     (*env)-&gt;ReleaseByteArrayElements(env, jbytes, bytes, 0);
 136 
 137     if (found != 1) {
 138       checkStatus(env, NULL, GSS_S_BAD_MECH, 0, "[GSSLibStub_getMechPtr]");
 139       return ptr_to_jlong(NULL);
 140     } else {
 141       return ptr_to_jlong(cOid);
 142     }
 143   } else {
 144     return ptr_to_jlong(GSS_C_NO_OID);
 145   }
 146 }
 147 
 148 /*
 149  * Utility routine which releases the specified gss_channel_bindings_t
 150  * structure.
 151  */
 152 static void deleteGSSCB(JNIEnv *env, gss_channel_bindings_t cb) {
 153   if (cb == GSS_C_NO_CHANNEL_BINDINGS) return;
 154 
 155   /* release initiator address */
 156   if (cb-&gt;initiator_addrtype != GSS_C_AF_NULLADDR) {
 157     resetGSSBuffer(env, NULL, &amp;(cb-&gt;initiator_address));
 158   }
 159   /* release acceptor address */
 160   if (cb-&gt;acceptor_addrtype != GSS_C_AF_NULLADDR) {
 161     resetGSSBuffer(env, NULL, &amp;(cb-&gt;acceptor_address));
 162   }
 163   /* release application data */
 164   if (cb-&gt;application_data.value != NULL) {
 165     resetGSSBuffer(env, NULL, &amp;(cb-&gt;application_data));
 166   }
 167   free(cb);
 168 }
 169 
 170 /*
 171  * Utility routine which creates a gss_channel_bindings_t structure
 172  * using the specified org.ietf.jgss.ChannelBinding object.
 173  * NOTE: must call deleteGSSCB() to free up the resources.
 174  */
 175 gss_channel_bindings_t newGSSCB(JNIEnv *env, jobject jcb) {
 176   gss_channel_bindings_t cb;
 177   jobject jinetAddr;
 178   jbyteArray value;
 179 
 180   if (jcb == NULL) {
 181     return GSS_C_NO_CHANNEL_BINDINGS;
 182   }
 183 
 184   cb = malloc(sizeof(struct gss_channel_bindings_struct));
 185   if (cb == NULL) {
 186     throwOutOfMemoryError(env,NULL);
 187     return NULL;
 188   }
 189 
 190   /* Fully initialize to a state safe for cleanup */
 191   cb-&gt;initiator_addrtype = GSS_C_AF_NULLADDR;
 192   cb-&gt;acceptor_addrtype = GSS_C_AF_NULLADDR;
 193   cb-&gt;application_data.length = 0;
 194   cb-&gt;application_data.value = NULL;
 195 
 196   // addresses needs to be initialized to empty
 197   memset(&amp;cb-&gt;initiator_address, 0, sizeof(cb-&gt;initiator_address));
 198   memset(&amp;cb-&gt;acceptor_address, 0, sizeof(cb-&gt;acceptor_address));
 199 
 200   /* set up initiator address */
 201   jinetAddr = (*env)-&gt;CallObjectMethod(env, jcb,
 202       MID_ChannelBinding_getInitiatorAddr);
 203   if ((*env)-&gt;ExceptionCheck(env)) {
 204     goto cleanup;
 205   }
 206   if (jinetAddr != NULL) {
 207     value = (*env)-&gt;CallObjectMethod(env, jinetAddr,
 208                                      MID_InetAddress_getAddr);
 209     if ((*env)-&gt;ExceptionCheck(env)) {
 210       goto cleanup;
 211     }
 212     initGSSBuffer(env, value, &amp;(cb-&gt;initiator_address), JNI_TRUE);
 213     if ((*env)-&gt;ExceptionCheck(env)) {
 214       goto cleanup;
 215     }
 216     cb-&gt;initiator_addrtype = GSS_C_AF_INET;
 217   }
 218   /* set up acceptor address */
 219   jinetAddr = (*env)-&gt;CallObjectMethod(env, jcb,
 220       MID_ChannelBinding_getAcceptorAddr);
 221   if ((*env)-&gt;ExceptionCheck(env)) {
 222     goto cleanup;
 223   }
 224   if (jinetAddr != NULL) {
 225     value = (*env)-&gt;CallObjectMethod(env, jinetAddr,
 226                                      MID_InetAddress_getAddr);
 227     if ((*env)-&gt;ExceptionCheck(env)) {
 228       goto cleanup;
 229     }
 230     initGSSBuffer(env, value, &amp;(cb-&gt;acceptor_address), JNI_TRUE);
 231     if ((*env)-&gt;ExceptionCheck(env)) {
 232       goto cleanup;
 233     }
 234     cb-&gt;acceptor_addrtype = GSS_C_AF_INET;
 235   }
 236   /* set up application data */
 237   value = (*env)-&gt;CallObjectMethod(env, jcb,
 238                                    MID_ChannelBinding_getAppData);
 239   if ((*env)-&gt;ExceptionCheck(env)) {
 240     goto cleanup;
 241   }
 242   initGSSBuffer(env, value, &amp;(cb-&gt;application_data), JNI_TRUE);
 243   if ((*env)-&gt;ExceptionCheck(env)) {
 244     goto cleanup;
 245   }
 246   return cb;
 247 cleanup:
 248   deleteGSSCB(env, cb);
 249   return NULL;
 250 }
 251 
 252 /*
 253  * Utility routine for storing the supplementary information
 254  * into the specified org.ietf.jgss.MessageProp object.
 255  */
 256 void setSupplementaryInfo(JNIEnv *env, jobject jstub, jobject jprop,
 257                           int suppInfo, int minor) {
 258   jboolean isDuplicate, isOld, isUnseq, hasGap;
 259   jstring minorMsg;
 260 
 261   if (suppInfo != GSS_S_COMPLETE) {
 262     isDuplicate = ((suppInfo &amp; GSS_S_DUPLICATE_TOKEN) != 0);
 263     isOld = ((suppInfo &amp; GSS_S_OLD_TOKEN) != 0);
 264     isUnseq = ((suppInfo &amp; GSS_S_UNSEQ_TOKEN) != 0);
 265     hasGap = ((suppInfo &amp; GSS_S_GAP_TOKEN) != 0);
 266     minorMsg = getMinorMessage(env, jstub, minor);
 267     if ((*env)-&gt;ExceptionCheck(env)) {
 268       return;
 269     }
 270     (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setSupplementaryStates,
 271                            isDuplicate, isOld, isUnseq, hasGap, minor,
 272                            minorMsg);
 273   }
 274 }
 275 
 276 /*
 277  * Class:     sun_security_jgss_wrapper_GSSLibStub
 278  * Method:    indicateMechs
 279  * Signature: ()[Lorg/ietf/jgss/Oid;
 280  */
 281 JNIEXPORT jobjectArray JNICALL
 282 Java_sun_security_jgss_wrapper_GSSLibStub_indicateMechs(JNIEnv *env,
 283                                                         jclass jcls)
 284 {
 285   if (ftab-&gt;mechs != NULL &amp;&amp; ftab-&gt;mechs != GSS_C_NO_OID_SET) {
 286     return getJavaOIDArray(env, ftab-&gt;mechs);
 287   } else return NULL;
 288 }
 289 
 290 /*
 291  * Class:     sun_security_jgss_wrapper_GSSLibStub
 292  * Method:    inquireNamesForMech
 293  * Signature: ()[Lorg/ietf/jgss/Oid;
 294  */
 295 JNIEXPORT jobjectArray JNICALL
 296 Java_sun_security_jgss_wrapper_GSSLibStub_inquireNamesForMech(JNIEnv *env,
 297                                                               jobject jobj)
 298 {
 299   OM_uint32 minor, major, dummy;
 300   gss_OID mech;
 301   gss_OID_set nameTypes;
 302   jobjectArray result;
 303 
 304   if (ftab-&gt;inquireNamesForMech != NULL) {
 305     mech = (gss_OID)jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
 306     nameTypes = GSS_C_NO_OID_SET;
 307 
 308     /* gss_inquire_names_for_mech(...) =&gt; N/A */
 309     major = (*ftab-&gt;inquireNamesForMech)(&amp;minor, mech, &amp;nameTypes);
 310 
 311     /* release intermediate buffers before checking status */
 312     result = getJavaOIDArray(env, nameTypes);
 313     (*ftab-&gt;releaseOidSet)(&amp;dummy, &amp;nameTypes);
 314     if ((*env)-&gt;ExceptionCheck(env)) {
 315       return NULL;
 316     }
 317 
 318     checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireNamesForMech]");
 319     if ((*env)-&gt;ExceptionCheck(env)) {
 320       return NULL;
 321     }
 322     return result;
 323   }
 324   return NULL;
 325 }
 326 
 327 /*
 328  * Class:     sun_security_jgss_wrapper_GSSLibStub
 329  * Method:    releaseName
 330  * Signature: (J)V
 331  */
 332 JNIEXPORT void JNICALL
 333 Java_sun_security_jgss_wrapper_GSSLibStub_releaseName(JNIEnv *env,
 334                                                       jobject jobj,
 335                                                       jlong pName)
 336 {
 337   OM_uint32 minor, major;
 338   gss_name_t nameHdl;
 339 
 340   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 341 
 342   TRACE1("[GSSLibStub_releaseName] %ld", (long) pName);
 343 
 344   if (nameHdl != GSS_C_NO_NAME) {
 345     /* gss_release_name(...) =&gt; GSS_S_BAD_NAME */
 346     major = (*ftab-&gt;releaseName)(&amp;minor, &amp;nameHdl);
 347     checkStatus(env, jobj, major, minor, "[GSSLibStub_releaseName]");
 348   }
 349 }
 350 
 351 /*
 352  * Class:     sun_security_jgss_wrapper_GSSLibStub
 353  * Method:    importName
 354  * Signature: ([BLorg/ietf/jgss/Oid;)J
 355  */
 356 JNIEXPORT jlong JNICALL
 357 Java_sun_security_jgss_wrapper_GSSLibStub_importName(JNIEnv *env,
 358                                                      jobject jobj,
 359                                                      jbyteArray jnameVal,
 360                                                      jobject jnameType)
 361 {
 362   OM_uint32 minor, major;
 363   gss_buffer_desc nameVal;
 364   gss_OID nameType;
 365   gss_name_t nameHdl;
 366   nameHdl = GSS_C_NO_NAME;
 367 
 368   TRACE0("[GSSLibStub_importName]");
 369 
 370   initGSSBuffer(env, jnameVal, &amp;nameVal, JNI_FALSE);
 371   if ((*env)-&gt;ExceptionCheck(env)) {
 372       return jlong_zero;
 373   }
 374 
 375   nameType = newGSSOID(env, jnameType);
 376   if ((*env)-&gt;ExceptionCheck(env)) {
 377     resetGSSBuffer(env, jnameVal, &amp;nameVal);
 378     return jlong_zero;
 379   }
 380 
 381   /* gss_import_name(...) =&gt; GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME,
 382      GSS_S_BAD_MECH */
 383   major = (*ftab-&gt;importName)(&amp;minor, &amp;nameVal, nameType, &amp;nameHdl);
 384 
 385   TRACE1("[GSSLibStub_importName] %" PRIuPTR  "", (uintptr_t) nameHdl);
 386 
 387   /* release intermediate buffers */
 388   deleteGSSOID(nameType);
 389   resetGSSBuffer(env, jnameVal, &amp;nameVal);
 390 
 391   checkStatus(env, jobj, major, minor, "[GSSLibStub_importName]");
 392   if ((*env)-&gt;ExceptionCheck(env)) {
 393     return jlong_zero;
 394   }
 395   return ptr_to_jlong(nameHdl);
 396 }
 397 
 398 
 399 /*
 400  * Class:     sun_security_jgss_wrapper_GSSLibStub
 401  * Method:    compareName
 402  * Signature: (JJ)Z
 403  */
 404 JNIEXPORT jboolean JNICALL
 405 Java_sun_security_jgss_wrapper_GSSLibStub_compareName(JNIEnv *env,
 406                                                       jobject jobj,
 407                                                       jlong pName1,
 408                                                       jlong pName2)
 409 {
 410   OM_uint32 minor, major;
 411   gss_name_t nameHdl1, nameHdl2;
 412   int isEqual;
 413 
 414   isEqual = 0;
 415   nameHdl1 = (gss_name_t) jlong_to_ptr(pName1);
 416   nameHdl2 = (gss_name_t) jlong_to_ptr(pName2);
 417 
 418   TRACE2("[GSSLibStub_compareName] %ld %ld", (long)pName1, (long)pName2);
 419 
 420   if ((nameHdl1 != GSS_C_NO_NAME) &amp;&amp; (nameHdl2 != GSS_C_NO_NAME)) {
 421 
 422     /* gss_compare_name(...) =&gt; GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME(!) */
 423     major = (*ftab-&gt;compareName)(&amp;minor, nameHdl1, nameHdl2, &amp;isEqual);
 424 
 425     checkStatus(env, jobj, major, minor, "[GSSLibStub_compareName]");
 426   }
 427   return (isEqual != 0);
 428 }
 429 
 430 /*
 431  * Class:     sun_security_jgss_wrapper_GSSLibStub
 432  * Method:    canonicalizeName
 433  * Signature: (J)J
 434  */
 435 JNIEXPORT jlong JNICALL
 436 Java_sun_security_jgss_wrapper_GSSLibStub_canonicalizeName(JNIEnv *env,
 437                                                            jobject jobj,
 438                                                            jlong pName)
 439 {
 440   OM_uint32 minor, major;
 441   gss_name_t nameHdl, mnNameHdl;
 442   gss_OID mech;
 443 
 444   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 445 
 446   TRACE1("[GSSLibStub_canonicalizeName] %ld", (long) pName);
 447 
 448   if (nameHdl != GSS_C_NO_NAME) {
 449     mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
 450     mnNameHdl = GSS_C_NO_NAME;
 451 
 452     /* gss_canonicalize_name(...) may return GSS_S_BAD_NAMETYPE,
 453        GSS_S_BAD_NAME, GSS_S_BAD_MECH */
 454     major = (*ftab-&gt;canonicalizeName)(&amp;minor, nameHdl, mech, &amp;mnNameHdl);
 455 
 456     TRACE1("[GSSLibStub_canonicalizeName] MN=%" PRIuPTR "", (uintptr_t)mnNameHdl);
 457 
 458     checkStatus(env, jobj, major, minor, "[GSSLibStub_canonicalizeName]");
 459     if ((*env)-&gt;ExceptionCheck(env)) {
 460       return ptr_to_jlong(GSS_C_NO_NAME);
 461     }
 462     return ptr_to_jlong(mnNameHdl);
 463   }
 464   return ptr_to_jlong(GSS_C_NO_NAME);
 465 }
 466 
 467 /*
 468  * Class:     sun_security_jgss_wrapper_GSSLibStub
 469  * Method:    exportName
 470  * Signature: (J)[B
 471  */
 472 JNIEXPORT jbyteArray JNICALL
 473 Java_sun_security_jgss_wrapper_GSSLibStub_exportName(JNIEnv *env,
 474                                                      jobject jobj,
 475                                                      jlong pName) {
 476   OM_uint32 minor, major, dummy;
 477   gss_name_t nameHdl, mNameHdl;
 478   gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;
 479 
 480   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 481 
 482   TRACE1("[GSSLibStub_exportName] %ld", (long) pName);
 483 
 484   /* gss_export_name(...) =&gt; GSS_S_NAME_NOT_MN, GSS_S_BAD_NAMETYPE,
 485      GSS_S_BAD_NAME */
 486   major = (*ftab-&gt;exportName)(&amp;minor, nameHdl, &amp;outBuf);
 487 
 488   /* canonicalize the internal name to MN and retry */
 489   if (major == GSS_S_NAME_NOT_MN) {
 490     /* release intermediate buffers before retrying */
 491     (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outBuf);
 492 
 493     TRACE0("[GSSLibStub_exportName] canonicalize and re-try");
 494 
 495     mNameHdl = (gss_name_t)jlong_to_ptr(
 496         Java_sun_security_jgss_wrapper_GSSLibStub_canonicalizeName
 497                                         (env, jobj, pName));
 498     if ((*env)-&gt;ExceptionCheck(env)) {
 499         return NULL;
 500     }
 501 
 502     major = (*ftab-&gt;exportName)(&amp;minor, mNameHdl, &amp;outBuf);
 503     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;mNameHdl);
 504   }
 505 
 506   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportName]");
 507   if ((*env)-&gt;ExceptionCheck(env)) {
 508     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;outBuf);
 509     return NULL;
 510   }
 511   /* Map outBuf to byteArray result and release */
 512   return getJavaBuffer(env, &amp;outBuf, JNI_TRUE);
 513 }
 514 
 515 /*
 516  * Class:     sun_security_jgss_wrapper_GSSLibStub
 517  * Method:    localName
 518  * Signature: (J)Ljava/lang/String;
 519  */
 520 JNIEXPORT jstring JNICALL
 521 Java_sun_security_jgss_wrapper_GSSLibStub_localName(JNIEnv *env,
 522                                                     jobject jobj,
 523                                                     jlong pName,
 524                                                     jobject jOid)
 525 {
 526   OM_uint32 minor, major, dummy;
 527   gss_name_t nameHdl, mnNameHdl;
 528   gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;
 529   gss_OID mech;
 530 
 531   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 532 
 533   if (ftab-&gt;localName == NULL) {
 534     TRACE0("GSSLibStub_localName not supported by GSS provider");
 535     checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,
 536                 "[GSSLibStub_localName]");
 537     return NULL;
 538   }
 539   mech = newGSSOID(env, jOid);
 540 
 541   /* gss_localname(...) =&gt; GSS_S_NAME_NOT_MN, GSS_S_BAD_NAMETYPE,
 542      GSS_S_BAD_NAME */
 543   major = (*ftab-&gt;localName)(&amp;minor, nameHdl, mech, &amp;outBuf);
 544   if (major == GSS_S_COMPLETE) {
 545     deleteGSSOID(mech);
 546     return getJavaString(env, &amp;outBuf);
 547   }
 548   (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outBuf);
 549 
 550   if (major != GSS_S_NAME_NOT_MN) {
 551     checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
 552     goto err;
 553   }
 554 
 555   /* canonicalize the internal name to MN and retry */
 556   TRACE0("[GSSLibStub_localName] canonicalize and re-try");
 557 
 558   major = (*ftab-&gt;canonicalizeName)(&amp;minor, nameHdl, mech, &amp;mnNameHdl);
 559   checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
 560   if ((*env)-&gt;ExceptionCheck(env))
 561     goto err;
 562 
 563   major = (*ftab-&gt;localName)(&amp;minor, mnNameHdl, mech, &amp;outBuf);
 564   (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;mnNameHdl);
 565 
 566   checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
 567   if ((*env)-&gt;ExceptionCheck(env) == JNI_FALSE &amp;&amp; major == GSS_S_COMPLETE) {
 568     deleteGSSOID(mech);
 569     return getJavaString(env, &amp;outBuf);
 570   }
 571   (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outBuf);
 572 
 573 err:
 574   deleteGSSOID(mech);
 575   return NULL;
 576 }
 577 
 578 /*
 579  * Class:     sun_security_jgss_wrapper_GSSLibStub
 580  * Method:    displayName
 581  * Signature: (J)[Ljava/lang/Object;
 582  */
 583 JNIEXPORT jobjectArray JNICALL
 584 Java_sun_security_jgss_wrapper_GSSLibStub_displayName(JNIEnv *env,
 585                                                       jobject jobj,
 586                                                       jlong pName) {
 587   OM_uint32 minor, major;
 588   gss_name_t nameHdl;
 589   gss_buffer_desc outNameBuf = GSS_C_EMPTY_BUFFER;
 590   gss_OID outNameType;
 591   jstring jname;
 592   jobject jtype;
 593   jobjectArray jresult;
 594 
 595   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 596 
 597   TRACE1("[GSSLibStub_displayName] %ld", (long) pName);
 598 
 599   if (nameHdl == GSS_C_NO_NAME) {
 600     checkStatus(env, jobj, GSS_S_BAD_NAME, 0, "[GSSLibStub_displayName]");
 601     return NULL;
 602   }
 603 
 604   /* gss_display_name(...) =&gt; GSS_S_BAD_NAME */
 605   major = (*ftab-&gt;displayName)(&amp;minor, nameHdl, &amp;outNameBuf, &amp;outNameType);
 606 
 607   /* release intermediate buffers before checking status */
 608   jname = getJavaString(env, &amp;outNameBuf);
 609   if ((*env)-&gt;ExceptionCheck(env)) {
 610     return NULL;
 611   }
 612 
 613   checkStatus(env, jobj, major, minor, "[GSSLibStub_displayName]");
 614   if ((*env)-&gt;ExceptionCheck(env)) {
 615     return NULL;
 616   }
 617 
 618   jtype = getJavaOID(env, outNameType);
 619   if ((*env)-&gt;ExceptionCheck(env)) {
 620     return NULL;
 621   }
 622 
 623   jresult = (*env)-&gt;NewObjectArray(env, 2, CLS_Object, NULL);
 624   /* return immediately if an exception has occurred */
 625   if ((*env)-&gt;ExceptionCheck(env)) {
 626     return NULL;
 627   }
 628 
 629   (*env)-&gt;SetObjectArrayElement(env, jresult, 0, jname);
 630   if ((*env)-&gt;ExceptionCheck(env)) {
 631     return NULL;
 632   }
 633   (*env)-&gt;SetObjectArrayElement(env, jresult, 1, jtype);
 634   if ((*env)-&gt;ExceptionCheck(env)) {
 635     return NULL;
 636   }
 637 
 638   return jresult;
 639 }
 640 
 641 /*
 642  * Class:     sun_security_jgss_wrapper_GSSLibStub
 643  * Method:    acquireCred
 644  * Signature: (JLjava/lang/String;[II)J
 645  */
 646 JNIEXPORT jlong JNICALL
 647 Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
 648                                                       jobject jobj,
 649                                                       jlong pName,
 650                                                       jstring jPassword,
 651                                                       jarray jCredStore,
 652                                                       jint reqTime,
 653                                                       jint usage)
 654 {
 655   OM_uint32 minor, major;
 656   gss_OID mech;
 657   gss_OID_set_desc singleton;
 658   gss_OID_set mechs;
 659   gss_cred_usage_t credUsage;
 660   gss_name_t nameHdl;
 661   gss_cred_id_t credHdl;
 662   credHdl = GSS_C_NO_CREDENTIAL;
 663 
 664   TRACE0("[GSSLibStub_acquireCred]");
 665 
 666   mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
 667   mechs = makeGSSOIDSet(&amp;singleton, mech);
 668   credUsage = (gss_cred_usage_t) usage;
 669   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 670 
 671   TRACE2("[GSSLibStub_acquireCred] pName=%ld, usage=%d", (long)pName, usage);
 672 
 673   /* gss_acquire_cred(...) =&gt; GSS_S_BAD_MECH, GSS_S_BAD_NAMETYPE,
 674      GSS_S_BAD_NAME, GSS_S_CREDENTIALS_EXPIRED, GSS_S_NO_CRED */
 675   if (jPassword == NULL &amp;&amp; jCredStore == NULL) {
 676     major = (*ftab-&gt;acquireCred)(&amp;minor, nameHdl, reqTime, mechs, credUsage,
 677                                  &amp;credHdl, NULL, NULL);
 678   } else if (jPassword != NULL) {
 679     gss_buffer_desc password;
 680 
 681     if (ftab-&gt;acquireCredWithPassword == NULL) {
 682       const char *msg = "GSSLibStub_acquireCred with password not supported "
 683           "by GSS provider";
 684 
 685       TRACE0(msg);
 686       checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, msg);
 687       return ptr_to_jlong(NULL);
 688     }
 689 
 690     initGSSBufferString(env, jPassword, &amp;password);
 691     if ((*env)-&gt;ExceptionCheck(env)) {
 692       return jlong_zero;
 693     }
 694     major = (*ftab-&gt;acquireCredWithPassword)(&amp;minor, nameHdl, &amp;password,
 695                                              reqTime, mechs, credUsage,
 696                                              &amp;credHdl, NULL, NULL);
 697     resetGSSBufferString(env, jPassword, &amp;password);
 698   } else {
 699     gss_key_value_set_desc credStore = {0, 0};
 700 
 701     if (ftab-&gt;acquireCredFrom == NULL) {
 702       const char *msg = "GSSLibStub_acquireCred from credential store not "
 703           "supported by GSS provider";
 704 
 705       TRACE0("[GSSLibStub_acquireCred] acquiring from a specific credential "
 706              "store not supported by GSS provider");
 707       checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,
 708                   "[GSSLibStub_acquireCred]");
 709       return ptr_to_jlong(NULL);
 710     }
 711 
 712     initGSSCredStore(env, jCredStore, &amp;credStore);
 713     if ((*env)-&gt;ExceptionCheck(env)) {
 714       return jlong_zero;
 715     }
 716     major = (*ftab-&gt;acquireCredFrom)(&amp;minor, nameHdl, reqTime, mechs,
 717                                      credUsage, &amp;credStore, &amp;credHdl,
 718                                      NULL, NULL);
 719     resetGSSCredStore(env, jCredStore, &amp;credStore);
 720   }
 721 
 722   TRACE1("[GSSLibStub_acquireCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
 723 
 724   checkStatus(env, jobj, major, minor, "[GSSLibStub_acquireCred]");
 725   if ((*env)-&gt;ExceptionCheck(env)) {
 726     return jlong_zero;
 727   }
 728   return ptr_to_jlong(credHdl);
 729 }
 730 
 731 /*
 732  * Class:     sun_security_jgss_wrapper_GSSLibStub
 733  * Method:    storeCred
 734  * Signature: (JILorg/ietf/jgss/Oid;ZZ[)J
 735  */
 736 JNIEXPORT jlong JNICALL
 737 Java_sun_security_jgss_wrapper_GSSLibStub_storeCred(JNIEnv *env,
 738                                                     jobject jobj,
 739                                                     jlong pCred,
 740                                                     jint usage,
 741                                                     jobject jmech,
 742                                                     jboolean overwrite,
 743                                                     jboolean defaultCred,
 744                                                     jarray jCredStore)
 745 {
 746   OM_uint32 minor, major;
 747   gss_key_value_set_desc credStore;
 748   gss_cred_usage_t credUsage;
 749   gss_cred_id_t credHdl;
 750   gss_OID mech;
 751 
 752   TRACE0("[GSSLibStub_storeCred]");
 753 
 754   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
 755   credUsage = (gss_cred_usage_t) usage;
 756 
 757   mech = newGSSOID(env, jmech);
 758   if ((*env)-&gt;ExceptionCheck(env)) {
 759     return jlong_zero;
 760   }
 761 
 762   TRACE2("[GSSLibStub_storeCred] pCred=%ld, usage=%d", (long)pCred, usage);
 763 
 764   if (ftab-&gt;storeCredInto == NULL) {
 765     TRACE0("[GSSLibStub_storeCred] GSSLibStub_storeCred not supported by "
 766            "GSS provider");
 767     checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, "[GSSLibStub_storeCred]");
 768     return ptr_to_jlong(NULL);
 769   }
 770 
 771   initGSSCredStore(env, jCredStore, &amp;credStore);
 772   if ((*env)-&gt;ExceptionCheck(env)) {
 773     return jlong_zero;
 774   }
 775   major = (*ftab-&gt;storeCredInto)(&amp;minor, credHdl, credUsage, mech,
 776                                  overwrite, defaultCred, &amp;credStore,
 777                                  NULL, NULL);
 778   resetGSSCredStore(env, jCredStore, &amp;credStore);
 779 
 780   TRACE1("[GSSLibStub_storeCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
 781 
 782   checkStatus(env, jobj, major, minor, "[GSSLibStub_storeCred]");
 783   if ((*env)-&gt;ExceptionCheck(env)) {
 784     return jlong_zero;
 785   }
 786   return ptr_to_jlong(credHdl);
 787 }
 788 
 789 /*
 790  * Class:     sun_security_jgss_wrapper_GSSLibStub
 791  * Method:    releaseCred
 792  * Signature: (J)J
 793  */
 794 JNIEXPORT jlong JNICALL
 795 Java_sun_security_jgss_wrapper_GSSLibStub_releaseCred(JNIEnv *env,
 796                                                       jobject jobj,
 797                                                       jlong pCred)
 798 {
 799   OM_uint32 minor, major;
 800   gss_cred_id_t credHdl;
 801 
 802   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
 803 
 804   TRACE1("[GSSLibStub_releaseCred] %ld", (long int)pCred);
 805 
 806   if (credHdl != GSS_C_NO_CREDENTIAL) {
 807     /* gss_release_cred(...) =&gt; GSS_S_NO_CRED(!) */
 808     major = (*ftab-&gt;releaseCred)(&amp;minor, &amp;credHdl);
 809 
 810     checkStatus(env, jobj, major, minor, "[GSSLibStub_releaseCred]");
 811     if ((*env)-&gt;ExceptionCheck(env)) {
 812       return jlong_zero;
 813     }
 814   }
 815   return ptr_to_jlong(credHdl);
 816 }
 817 
 818 /*
 819  * Utility routine for obtaining info about a credential.
 820  */
 821 void inquireCred(JNIEnv *env, jobject jobj, gss_cred_id_t pCred,
 822                  jint type, void *result) {
 823   OM_uint32 minor=0, major=0;
 824   OM_uint32 routineErr;
 825   gss_cred_id_t credHdl;
 826 
 827   credHdl = pCred;
 828 
 829   TRACE1("[gss_inquire_cred] %" PRIuPTR "", (uintptr_t) pCred);
 830 
 831   /* gss_inquire_cred(...) =&gt; GSS_S_DEFECTIVE_CREDENTIAL(!),
 832      GSS_S_CREDENTIALS_EXPIRED(!), GSS_S_NO_CRED(!) */
 833   if (type == TYPE_CRED_NAME) {
 834     major = (*ftab-&gt;inquireCred)(&amp;minor, credHdl, result, NULL, NULL, NULL);
 835   } else if (type == TYPE_CRED_TIME) {
 836     major = (*ftab-&gt;inquireCred)(&amp;minor, credHdl, NULL, result, NULL, NULL);
 837   } else if (type == TYPE_CRED_USAGE) {
 838     major = (*ftab-&gt;inquireCred)(&amp;minor, credHdl, NULL, NULL, result, NULL);
 839   }
 840 
 841   routineErr = GSS_ROUTINE_ERROR(major);
 842   if (routineErr == GSS_S_CREDENTIALS_EXPIRED) {
 843     /* ignore GSS_S_CREDENTIALS_EXPIRED for query  */
 844     major = GSS_CALLING_ERROR(major) |
 845       GSS_SUPPLEMENTARY_INFO(major);
 846   } else if (routineErr == GSS_S_NO_CRED) {
 847     /* twik since Java API throws BAD_MECH instead of NO_CRED */
 848     major = GSS_CALLING_ERROR(major) |
 849       GSS_S_BAD_MECH  | GSS_SUPPLEMENTARY_INFO(major);
 850   }
 851   checkStatus(env, jobj, major, minor, "[gss_inquire_cred]");
 852 }
 853 
 854 /*
 855  * Class:     sun_security_jgss_wrapper_GSSLibStub
 856  * Method:    getCredName
 857  * Signature: (J)J
 858  */
 859 JNIEXPORT jlong JNICALL
 860 Java_sun_security_jgss_wrapper_GSSLibStub_getCredName(JNIEnv *env,
 861                                                       jobject jobj,
 862                                                       jlong pCred)
 863 {
 864   gss_name_t nameHdl;
 865   gss_cred_id_t credHdl;
 866 
 867   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
 868 
 869   TRACE1("[GSSLibStub_getCredName] %ld", (long int)pCred);
 870 
 871   nameHdl = GSS_C_NO_NAME;
 872   inquireCred(env, jobj, credHdl, TYPE_CRED_NAME, &amp;nameHdl);
 873   /* return immediately if an exception has occurred */
 874   if ((*env)-&gt;ExceptionCheck(env)) {
 875     return jlong_zero;
 876   }
 877 
 878   TRACE1("[GSSLibStub_getCredName] pName=%" PRIuPTR "", (uintptr_t) nameHdl);
 879   return ptr_to_jlong(nameHdl);
 880 }
 881 
 882 /*
 883  * Class:     sun_security_jgss_wrapper_GSSLibStub
 884  * Method:    getCredTime
 885  * Signature: (J)I
 886  */
 887 JNIEXPORT jint JNICALL
 888 Java_sun_security_jgss_wrapper_GSSLibStub_getCredTime(JNIEnv *env,
 889                                                       jobject jobj,
 890                                                       jlong pCred)
 891 {
 892   gss_cred_id_t credHdl;
 893   OM_uint32 lifetime;
 894 
 895   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
 896 
 897   TRACE1("[GSSLibStub_getCredTime] %ld", (long int)pCred);
 898 
 899   lifetime = 0;
 900   inquireCred(env, jobj, credHdl, TYPE_CRED_TIME, &amp;lifetime);
 901   /* return immediately if an exception has occurred */
 902   if ((*env)-&gt;ExceptionCheck(env)) {
 903     return 0;
 904   }
 905   return getJavaTime(lifetime);
 906 }
 907 
 908 /*
 909  * Class:     sun_security_jgss_wrapper_GSSLibStub
 910  * Method:    getCredUsage
 911  * Signature: (J)I
 912  */
 913 JNIEXPORT jint JNICALL
 914 Java_sun_security_jgss_wrapper_GSSLibStub_getCredUsage(JNIEnv *env,
 915                                                        jobject jobj,
 916                                                        jlong pCred)
 917 {
 918   gss_cred_usage_t usage;
 919   gss_cred_id_t credHdl;
 920 
 921   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
 922 
 923   TRACE1("[GSSLibStub_getCredUsage] %ld", (long int)pCred);
 924 
 925   inquireCred(env, jobj, credHdl, TYPE_CRED_USAGE, &amp;usage);
 926   /* return immediately if an exception has occurred */
 927   if ((*env)-&gt;ExceptionCheck(env)) {
 928     return -1;
 929   }
 930   return (jint) usage;
 931 }
 932 /*
 933  * Class:     sun_security_jgss_wrapper_GSSLibStub
 934  * Method:    importContext
 935  * Signature: ([B)Lsun/security/jgss/wrapper/NativeGSSContext;
 936  */
 937 JNIEXPORT jobject JNICALL
 938 Java_sun_security_jgss_wrapper_GSSLibStub_importContext(JNIEnv *env,
 939                                                         jobject jobj,
 940                                                         jbyteArray jctxtToken)
 941 {
 942   OM_uint32 minor, major;
 943   gss_buffer_desc ctxtToken;
 944   gss_ctx_id_t contextHdl;
 945   gss_OID mech, mech2;
 946 
 947   TRACE0("[GSSLibStub_importContext]");
 948 
 949   contextHdl = GSS_C_NO_CONTEXT;
 950   initGSSBuffer(env, jctxtToken, &amp;ctxtToken, JNI_FALSE);
 951   if ((*env)-&gt;ExceptionCheck(env)) {
 952     return NULL;
 953   }
 954 
 955   /* gss_import_sec_context(...) =&gt; GSS_S_NO_CONTEXT, GSS_S_DEFECTIVE_TOKEN,
 956      GSS_S_UNAVAILABLE, GSS_S_UNAUTHORIZED */
 957   major = (*ftab-&gt;importSecContext)(&amp;minor, &amp;ctxtToken, &amp;contextHdl);
 958 
 959   TRACE1("[GSSLibStub_importContext] pContext=%" PRIuPTR "", (uintptr_t) contextHdl);
 960 
 961   /* release intermediate buffers */
 962   resetGSSBuffer(env, jctxtToken, &amp;ctxtToken);
 963 
 964   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext]");
 965   /* return immediately if an exception has occurred */
 966   if ((*env)-&gt;ExceptionCheck(env)) {
 967     return NULL;
 968   }
 969 
 970   /* now that the context has been imported, proceed to find out
 971      its mech */
 972   major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, NULL, NULL,
 973                               NULL, &amp;mech, NULL, NULL, NULL);
 974 
 975   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext] getMech");
 976   /* return immediately if an exception has occurred */
 977   if ((*env)-&gt;ExceptionCheck(env)) {
 978     return NULL;
 979   }
 980 
 981   mech2 = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj,
 982       FID_GSSLibStub_pMech));
 983 
 984   if (sameMech(mech, mech2) == JNI_TRUE) {
 985     /* mech match - return the context object */
 986     return (*env)-&gt;NewObject(env, CLS_NativeGSSContext,
 987                                  MID_NativeGSSContext_ctor,
 988                                  ptr_to_jlong(contextHdl), jobj);
 989   } else {
 990     /* mech mismatch - clean up then return null */
 991     major = (*ftab-&gt;deleteSecContext)(&amp;minor, &amp;contextHdl, GSS_C_NO_BUFFER);
 992     checkStatus(env, jobj, GSS_S_FAILURE, minor,
 993         "[GSSLibStub_importContext] cleanup");
 994     return NULL;
 995   }
 996 }
 997 
 998 /*
 999  * Class:     sun_security_jgss_wrapper_GSSLibStub
1000  * Method:    initContext
1001  * Signature: (JJLorg/ietf/jgss/ChannelBinding;[BLsun/security/jgss/wrapper/NativeGSSContext;)[B
1002  */
1003 JNIEXPORT jbyteArray JNICALL
1004 Java_sun_security_jgss_wrapper_GSSLibStub_initContext(JNIEnv *env,
1005                                                       jobject jobj,
1006                                                       jlong pCred,
1007                                                       jlong pName,
1008                                                       jobject jcb,
1009                                                       jbyteArray jinToken,
1010                                                       jobject jcontextSpi)
1011 {
1012   OM_uint32 minor, major, dummy;
1013   gss_cred_id_t credHdl ;
1014   gss_ctx_id_t contextHdl, contextHdlSave;
1015   gss_name_t targetName;
1016   gss_OID mech;
1017   OM_uint32 flags, aFlags;
1018   OM_uint32 time, aTime;
1019   gss_channel_bindings_t cb;
1020   gss_buffer_desc inToken;
1021   gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
1022   gss_OID aMech;
1023   jobject jMech;
1024 
1025   TRACE0("[GSSLibStub_initContext]");
1026 
1027   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
1028   contextHdl = contextHdlSave = (gss_ctx_id_t) jlong_to_ptr(
1029     (*env)-&gt;GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
1030   targetName = (gss_name_t) jlong_to_ptr(pName);
1031   mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jobj, FID_GSSLibStub_pMech));
1032   flags = (OM_uint32) (*env)-&gt;GetIntField(env, jcontextSpi,
1033                                           FID_NativeGSSContext_flags);
1034   time = getGSSTime((*env)-&gt;GetIntField(env, jcontextSpi,
1035                                         FID_NativeGSSContext_lifetime));
1036   cb = newGSSCB(env, jcb);
1037   if ((*env)-&gt;ExceptionCheck(env)) {
1038     return NULL;
1039   }
1040 
1041   initGSSBuffer(env, jinToken, &amp;inToken, JNI_FALSE);
1042   if ((*env)-&gt;ExceptionCheck(env)) {
1043     deleteGSSCB(env, cb);
1044     return NULL;
1045   }
1046 
1047   TRACE2( "[GSSLibStub_initContext] before: pCred=%" PRIuPTR ", pContext=%" PRIuPTR "",
1048           (uintptr_t)credHdl, (uintptr_t)contextHdl);
1049 
1050   /* gss_init_sec_context(...) =&gt; GSS_S_CONTINUE_NEEDED(!),
1051      GSS_S_DEFECTIVE_TOKEN, GSS_S_NO_CRED, GSS_S_DEFECTIVE_CREDENTIAL(!),
1052      GSS_S_CREDENTIALS_EXPIRED, GSS_S_BAD_BINDINGS, GSS_S_BAD_MIC,
1053      GSS_S_OLD_TOKEN, GSS_S_DUPLICATE_TOKEN, GSS_S_NO_CONTEXT(!),
1054      GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME(!), GSS_S_BAD_MECH */
1055   major = (*ftab-&gt;initSecContext)(&amp;minor, credHdl,
1056                                  &amp;contextHdl, targetName, mech,
1057                                  flags, time, cb, &amp;inToken, &amp;aMech,
1058                                  &amp;outToken, &amp;aFlags, &amp;aTime);
1059 
1060   TRACE2("[GSSLibStub_initContext] after: pContext=%" PRIuPTR ", outToken len=%ld",
1061             (uintptr_t)contextHdl, (long)outToken.length);
1062 
1063   // update context handle with the latest value if changed
1064   // this is to work with both MIT and Solaris. Former deletes half-built
1065   // context if error occurs
1066   if (contextHdl != contextHdlSave) {
1067     (*env)-&gt;SetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext,
1068                          ptr_to_jlong(contextHdl));
1069     TRACE1("[GSSLibStub_initContext] set pContext=%" PRIuPTR "", (uintptr_t)contextHdl);
1070   }
1071 
1072   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
1073     /* update member values if needed */
1074     (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
1075     TRACE1("[GSSLibStub_initContext] set flags=0x%x", aFlags);
1076 
1077     if (major == GSS_S_COMPLETE) {
1078       (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
1079                           getJavaTime(aTime));
1080       TRACE0("[GSSLibStub_initContext] context established");
1081 
1082       (*env)-&gt;SetBooleanField(env, jcontextSpi,
1083                               FID_NativeGSSContext_isEstablished,
1084                               JNI_TRUE);
1085 
1086       jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);
1087       if (!(*env)-&gt;ExceptionCheck(env)) {
1088         (*env)-&gt;SetObjectField(env, jcontextSpi,
1089                                FID_NativeGSSContext_actualMech, jMech);
1090       }
1091     } else if (major &amp; GSS_S_CONTINUE_NEEDED) {
1092       TRACE0("[GSSLibStub_initContext] context not established");
1093       major &amp;= ~GSS_S_CONTINUE_NEEDED;
1094     }
1095   }
1096 
1097   /* release intermediate buffers before checking status */
1098   deleteGSSCB(env, cb);
1099   resetGSSBuffer(env, jinToken, &amp;inToken);
1100 
1101   checkStatus(env, jobj, major, minor, "[GSSLibStub_initContext]");
1102   if ((*env)-&gt;ExceptionCheck(env)) {
1103     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;outToken);
1104     return NULL;
1105   }
1106   /* Map outToken to byteArray result and release */
1107   return getJavaBuffer(env, &amp;outToken, JNI_TRUE);
1108 }
1109 
1110 /*
1111  * Class:     sun_security_jgss_wrapper_GSSLibStub
1112  * Method:    acceptContext
1113  * Signature: (JLorg/ietf/jgss/ChannelBinding;[BLsun/security/jgss/wrapper/NativeGSSContext;)[B
1114  */
1115 JNIEXPORT jbyteArray JNICALL
1116 Java_sun_security_jgss_wrapper_GSSLibStub_acceptContext(JNIEnv *env,
1117                                                         jobject jobj,
1118                                                         jlong pCred,
1119                                                         jobject jcb,
1120                                                         jbyteArray jinToken,
1121                                                         jobject jcontextSpi)
1122 {
1123   OM_uint32 minor, major, dummy;
1124   OM_uint32 minor2, major2;
1125   gss_ctx_id_t contextHdl, contextHdlSave;
1126   gss_cred_id_t credHdl;
1127   gss_buffer_desc inToken;
1128   gss_channel_bindings_t cb;
1129   gss_name_t srcName = GSS_C_NO_NAME;
1130   gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
1131   gss_OID aMech;
1132   OM_uint32 aFlags;
1133   OM_uint32 aTime;
1134   gss_cred_id_t delCred = GSS_C_NO_CREDENTIAL;
1135   jobject jsrcName = NULL;
1136   jobject jdelCred;
1137   jobject jMech = NULL;
1138   jboolean setTarget;
1139   gss_name_t targetName = GSS_C_NO_NAME;
1140   jobject jtargetName;
1141 
1142   TRACE0("[GSSLibStub_acceptContext]");
1143 
1144   contextHdl = contextHdlSave = (gss_ctx_id_t)jlong_to_ptr(
1145     (*env)-&gt;GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
1146   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
1147   initGSSBuffer(env, jinToken, &amp;inToken, JNI_FALSE);
1148   if ((*env)-&gt;ExceptionCheck(env)) {
1149     return NULL;
1150   }
1151   cb = newGSSCB(env, jcb);
1152   if ((*env)-&gt;ExceptionCheck(env)) {
1153     resetGSSBuffer(env, jinToken, &amp;inToken);
1154     return NULL;
1155   }
1156   setTarget = (credHdl == GSS_C_NO_CREDENTIAL);
1157   aFlags = 0;
1158 
1159   TRACE2( "[GSSLibStub_acceptContext] before: pCred=%" PRIuPTR ", pContext=%" PRIuPTR "",
1160           (uintptr_t) credHdl, (uintptr_t) contextHdl);
1161 
1162   /* gss_accept_sec_context(...) =&gt; GSS_S_CONTINUE_NEEDED(!),
1163      GSS_S_DEFECTIVE_TOKEN, GSS_S_DEFECTIVE_CREDENTIAL(!),
1164      GSS_S_NO_CRED, GSS_S_CREDENTIALS_EXPIRED, GSS_S_BAD_BINDINGS,
1165      GSS_S_NO_CONTEXT(!), GSS_S_BAD_MIC, GSS_S_OLD_TOKEN,
1166      GSS_S_DUPLICATE_TOKEN, GSS_S_BAD_MECH */
1167   major =
1168     (*ftab-&gt;acceptSecContext)(&amp;minor, &amp;contextHdl, credHdl,
1169                            &amp;inToken, cb, &amp;srcName, &amp;aMech, &amp;outToken,
1170                            &amp;aFlags, &amp;aTime, &amp;delCred);
1171   /* release intermediate buffers before checking status */
1172 
1173   deleteGSSCB(env, cb);
1174   resetGSSBuffer(env, jinToken, &amp;inToken);
1175 
1176   TRACE3("[GSSLibStub_acceptContext] after: pCred=%" PRIuPTR ", pContext=%" PRIuPTR ", pDelegCred=%" PRIuPTR "",
1177         (uintptr_t)credHdl, (uintptr_t)contextHdl, (uintptr_t) delCred);
1178 
1179   // update context handle with the latest value if changed
1180   // this is to work with both MIT and Solaris. Former deletes half-built
1181   // context if error occurs
1182   if (contextHdl != contextHdlSave) {
1183     (*env)-&gt;SetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext,
1184                          ptr_to_jlong(contextHdl));
1185     TRACE1("[GSSLibStub_acceptContext] set pContext=%" PRIuPTR "", (uintptr_t)contextHdl);
1186   }
1187 
1188   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
1189     /* update member values if needed */
1190 
1191     jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);
1192     if (!(*env)-&gt;ExceptionCheck(env)) {
1193       (*env)-&gt;SetObjectField(env, jcontextSpi,
1194                              FID_NativeGSSContext_actualMech, jMech);
1195     }
1196     if ((*env)-&gt;ExceptionCheck(env)) {
1197       goto error;
1198     }
1199 
1200     /* WORKAROUND for an old Heimdal bug */
1201     if (delCred == GSS_C_NO_CREDENTIAL) {
1202         aFlags &amp;= ~GSS_C_DELEG_FLAG;
1203     }
1204     (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
1205     TRACE1("[GSSLibStub_acceptContext] set flags=0x%x", aFlags);
1206 
1207     if (setTarget) {
1208       major2 = (*ftab-&gt;inquireContext)(&amp;minor2, contextHdl, NULL,
1209                               &amp;targetName, NULL, NULL, NULL,
1210                               NULL, NULL);
1211       checkStatus(env, jobj, major2, minor2,
1212                     "[GSSLibStub_acceptContext] inquire");
1213       if ((*env)-&gt;ExceptionCheck(env)) {
1214          goto error;
1215       }
1216 
1217       jtargetName = (*env)-&gt;NewObject(env, CLS_GSSNameElement,
1218                                 MID_GSSNameElement_ctor,
1219                                 ptr_to_jlong(targetName), jMech, jobj);
1220       if ((*env)-&gt;ExceptionCheck(env)) {
1221         goto error;
1222       }
1223 
1224       TRACE1("[GSSLibStub_acceptContext] set targetName=%" PRIuPTR "",
1225               (uintptr_t)targetName);
1226       targetName = GSS_C_NO_NAME;
1227 
1228       (*env)-&gt;SetObjectField(env, jcontextSpi, FID_NativeGSSContext_targetName,
1229                              jtargetName);
1230       if ((*env)-&gt;ExceptionCheck(env)) {
1231         goto error;
1232       }
1233     }
1234     if (srcName != GSS_C_NO_NAME) {
1235       jsrcName = (*env)-&gt;NewObject(env, CLS_GSSNameElement,
1236                                    MID_GSSNameElement_ctor,
1237                                    ptr_to_jlong(srcName), jMech, jobj);
1238       if ((*env)-&gt;ExceptionCheck(env)) {
1239         goto error;
1240       }
1241 
1242       TRACE1("[GSSLibStub_acceptContext] set srcName=%" PRIuPTR "", (uintptr_t)srcName);
1243       srcName = GSS_C_NO_NAME;
1244 
1245       (*env)-&gt;SetObjectField(env, jcontextSpi, FID_NativeGSSContext_srcName,
1246                              jsrcName);
1247       if ((*env)-&gt;ExceptionCheck(env)) {
1248         goto error;
1249       }
1250     }
1251     if (major == GSS_S_COMPLETE) {
1252       TRACE0("[GSSLibStub_acceptContext] context established");
1253 
1254       (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
1255                           getJavaTime(aTime));
1256       (*env)-&gt;SetBooleanField(env, jcontextSpi,
1257                               FID_NativeGSSContext_isEstablished,
1258                               JNI_TRUE);
1259       if ((*env)-&gt;ExceptionCheck(env)) {
1260         goto error;
1261       }
1262       if (delCred != GSS_C_NO_CREDENTIAL) {
1263         jdelCred = (*env)-&gt;NewObject(env, CLS_GSSCredElement,
1264                                      MID_GSSCredElement_ctor,
1265                                      ptr_to_jlong(delCred), jsrcName, jMech);
1266         if ((*env)-&gt;ExceptionCheck(env)) {
1267           goto error;
1268         }
1269         TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",
1270                 (uintptr_t) delCred);
1271         delCred = GSS_C_NO_CREDENTIAL;
1272         (*env)-&gt;SetObjectField(env, jcontextSpi,
1273                                FID_NativeGSSContext_delegatedCred,
1274                                jdelCred);
1275 
1276         if ((*env)-&gt;ExceptionCheck(env)) {
1277           goto error;
1278         }
1279       }
1280     } else if (major &amp; GSS_S_CONTINUE_NEEDED) {
1281       TRACE0("[GSSLibStub_acceptContext] context not established");
1282 
1283       if (aFlags &amp; GSS_C_PROT_READY_FLAG) {
1284         (*env)-&gt;SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
1285                             getJavaTime(aTime));
1286       }
1287       major &amp;= ~GSS_S_CONTINUE_NEEDED;
1288     }
1289   }
1290 
1291   checkStatus(env, jobj, major, minor, "[GSSLibStub_acceptContext]");
1292   if ((*env)-&gt;ExceptionCheck(env)) {
1293     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;outToken);
1294     return NULL;
1295   }
1296 
1297   /* Map outToken to byteArray result and release */
1298   return getJavaBuffer(env, &amp;outToken, JNI_TRUE);
1299 
1300 error:
1301   (*ftab-&gt;releaseBuffer)(&amp;minor, &amp;outToken);
1302   if (srcName != GSS_C_NO_NAME) {
1303     (*ftab-&gt;releaseName)(&amp;minor, &amp;srcName);
1304   }
1305   if (targetName != GSS_C_NO_NAME) {
1306     (*ftab-&gt;releaseName)(&amp;minor, &amp;targetName);
1307   }
1308   if (delCred != GSS_C_NO_CREDENTIAL) {
1309     (*ftab-&gt;releaseCred) (&amp;minor, &amp;delCred);
1310   }
1311   return NULL;
1312 }
1313 
1314 /*
1315  * Class:     sun_security_jgss_wrapper_GSSLibStub
1316  * Method:    inquireContext
1317  * Signature: (J)[J
1318  */
1319 JNIEXPORT jlongArray JNICALL
1320 Java_sun_security_jgss_wrapper_GSSLibStub_inquireContext(JNIEnv *env,
1321                                                          jobject jobj,
1322                                                          jlong pContext)
1323 {
1324   OM_uint32 minor, major, dummy;
1325   gss_ctx_id_t contextHdl;
1326   gss_name_t srcName = GSS_C_NO_NAME;
1327   gss_name_t targetName = GSS_C_NO_NAME;
1328   OM_uint32 time = 0;
1329   OM_uint32 flags = 0;
1330   int isInitiator = 0;
1331   int isEstablished = 0;
1332   jlong result[6];
1333   jlongArray jresult;
1334 
1335   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1336 
1337   TRACE1("[GSSLibStub_inquireContext] %" PRIuPTR "", (uintptr_t)contextHdl);
1338 
1339   /* gss_inquire_context(...) =&gt; GSS_S_NO_CONTEXT(!) */
1340   major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, &amp;srcName,
1341                               &amp;targetName, &amp;time, NULL, &amp;flags,
1342                               &amp;isInitiator, &amp;isEstablished);
1343   /* update member values if needed */
1344   TRACE2("[GSSLibStub_inquireContext] srcName %" PRIuPTR ", targetName %" PRIuPTR "",
1345       (uintptr_t)srcName, (uintptr_t)targetName);
1346 
1347   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContext]");
1348   if ((*env)-&gt;ExceptionCheck(env)) {
1349     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;srcName);
1350     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;targetName);
1351     return NULL;
1352   }
1353   result[0] = ptr_to_jlong(srcName);
1354   result[1] = ptr_to_jlong(targetName);
1355   result[2] = (jlong) isInitiator;
1356   result[3] = (jlong) isEstablished;
1357   result[4] = (jlong) flags;
1358   result[5] = (jlong) getJavaTime(time);
1359 
1360   jresult = (*env)-&gt;NewLongArray(env, 6);
1361   if (jresult != NULL) {
1362     (*env)-&gt;SetLongArrayRegion(env, jresult, 0, 6, result);
1363   }
1364   if ((*env)-&gt;ExceptionCheck(env)) {
1365     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;srcName);
1366     (void) (*ftab-&gt;releaseName)(&amp;dummy, &amp;targetName);
1367     return NULL;
1368   }
1369   return jresult;
1370 }
1371 
1372 /*
1373  * Class:     sun_security_jgss_wrapper_GSSLibStub
1374  * Method:    getContextMech
1375  * Signature: (J)Lorg/ietf/jgss/Oid;
1376  */
1377 JNIEXPORT jobject JNICALL
1378 Java_sun_security_jgss_wrapper_GSSLibStub_getContextMech(JNIEnv *env,
1379                                                          jobject jobj,
1380                                                          jlong pContext)
1381 {
1382   OM_uint32 minor, major;
1383   gss_OID mech;
1384   gss_ctx_id_t contextHdl;
1385 
1386   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1387 
1388   TRACE1("[GSSLibStub_getContextMech] %ld", (long int)pContext);
1389 
1390   major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, NULL, NULL,
1391                                 NULL, &amp;mech, NULL,  NULL, NULL);
1392 
1393   checkStatus(env, jobj, major, minor, "[GSSLibStub_getContextMech]");
1394   /* return immediately if an exception has occurred */
1395   if ((*env)-&gt;ExceptionCheck(env)) {
1396     return NULL;
1397   }
1398 
1399   return getJavaOID(env, mech);
1400 }
1401 
1402 /*
1403  * Class:     sun_security_jgss_wrapper_GSSLibStub
1404  * Method:    getContextName
1405  * Signature: (JZ)J
1406  */
1407 JNIEXPORT jlong JNICALL
1408 Java_sun_security_jgss_wrapper_GSSLibStub_getContextName(JNIEnv *env,
1409   jobject jobj, jlong pContext, jboolean isSrc)
1410 {
1411   OM_uint32 minor, major;
1412   gss_name_t nameHdl = GSS_C_NO_NAME;
1413   gss_ctx_id_t contextHdl;
1414 
1415   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1416 
1417   TRACE2("[GSSLibStub_getContextName] %" PRIuPTR ", isSrc=%d",
1418           (uintptr_t)contextHdl, isSrc);
1419 
1420   if (isSrc == JNI_TRUE) {
1421     major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, &amp;nameHdl, NULL,
1422                                 NULL, NULL, NULL,  NULL, NULL);
1423   } else {
1424     major = (*ftab-&gt;inquireContext)(&amp;minor, contextHdl, NULL, &amp;nameHdl,
1425                                 NULL, NULL, NULL,  NULL, NULL);
1426   }
1427 
1428   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContextAll]");
1429   /* return immediately if an exception has occurred */
1430   if ((*env)-&gt;ExceptionCheck(env)) {
1431     return jlong_zero;
1432   }
1433 
1434   TRACE1("[GSSLibStub_getContextName] pName=%" PRIuPTR "", (uintptr_t) nameHdl);
1435 
1436   return ptr_to_jlong(nameHdl);
1437 }
1438 
1439 /*
1440  * Class:     sun_security_jgss_wrapper_GSSLibStub
1441  * Method:    getContextTime
1442  * Signature: (J)I
1443  */
1444 JNIEXPORT jint JNICALL
1445 Java_sun_security_jgss_wrapper_GSSLibStub_getContextTime(JNIEnv *env,
1446                                                          jobject jobj,
1447                                                          jlong pContext) {
1448   OM_uint32 minor, major;
1449   gss_ctx_id_t contextHdl;
1450   OM_uint32 time;
1451 
1452   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1453 
1454   TRACE1("[GSSLibStub_getContextTime] %" PRIuPTR "", (uintptr_t)contextHdl);
1455 
1456   if (contextHdl == GSS_C_NO_CONTEXT) return 0;
1457 
1458   /* gss_context_time(...) =&gt; GSS_S_CONTEXT_EXPIRED(!),
1459      GSS_S_NO_CONTEXT(!) */
1460   major = (*ftab-&gt;contextTime)(&amp;minor, contextHdl, &amp;time);
1461   if (GSS_ROUTINE_ERROR(major) == GSS_S_CONTEXT_EXPIRED) {
1462     major = GSS_CALLING_ERROR(major) | GSS_SUPPLEMENTARY_INFO(major);
1463   }
1464   checkStatus(env, jobj, major, minor, "[GSSLibStub_getContextTime]");
1465   if ((*env)-&gt;ExceptionCheck(env)) {
1466     return 0;
1467   }
1468   return getJavaTime(time);
1469 }
1470 
1471 /*
1472  * Class:     sun_security_jgss_wrapper_GSSLibStub
1473  * Method:    deleteContext
1474  * Signature: (J)J
1475  */
1476 JNIEXPORT jlong JNICALL
1477 Java_sun_security_jgss_wrapper_GSSLibStub_deleteContext(JNIEnv *env,
1478                                                         jobject jobj,
1479                                                         jlong pContext)
1480 {
1481   OM_uint32 minor, major;
1482   gss_ctx_id_t contextHdl;
1483 
1484   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1485 
1486   TRACE1("[GSSLibStub_deleteContext] %" PRIuPTR "", (uintptr_t)contextHdl);
1487 
1488   if (contextHdl == GSS_C_NO_CONTEXT) return ptr_to_jlong(GSS_C_NO_CONTEXT);
1489 
1490   /* gss_delete_sec_context(...) =&gt; GSS_S_NO_CONTEXT(!) */
1491   major = (*ftab-&gt;deleteSecContext)(&amp;minor, &amp;contextHdl, GSS_C_NO_BUFFER);
1492 
1493   checkStatus(env, jobj, major, minor, "[GSSLibStub_deleteContext]");
1494   if ((*env)-&gt;ExceptionCheck(env)) {
1495     return jlong_zero;
1496   }
1497   return (jlong) ptr_to_jlong(contextHdl);
1498 }
1499 
1500 /*
1501  * Class:     sun_security_jgss_wrapper_GSSLibStub
1502  * Method:    wrapSizeLimit
1503  * Signature: (JIII)I
1504  */
1505 JNIEXPORT jint JNICALL
1506 Java_sun_security_jgss_wrapper_GSSLibStub_wrapSizeLimit(JNIEnv *env,
1507                                                         jobject jobj,
1508                                                         jlong pContext,
1509                                                         jint reqFlag,
1510                                                         jint jqop,
1511                                                         jint joutSize)
1512 {
1513   OM_uint32 minor, major;
1514   gss_ctx_id_t contextHdl;
1515   OM_uint32 outSize, maxInSize;
1516   gss_qop_t qop;
1517   jint result;
1518 
1519   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1520 
1521   TRACE1("[GSSLibStub_wrapSizeLimit] %" PRIuPTR "", (uintptr_t)contextHdl);
1522 
1523   if (contextHdl == GSS_C_NO_CONTEXT) {
1524     // Twik per javadoc
1525     checkStatus(env, jobj, GSS_S_NO_CONTEXT, 0,
1526         "[GSSLibStub_wrapSizeLimit]");
1527     return 0;
1528   }
1529 
1530   qop = (gss_qop_t) jqop;
1531   outSize = (OM_uint32) joutSize;
1532   /* gss_wrap_size_limit(...) =&gt; GSS_S_NO_CONTEXT(!), GSS_S_CONTEXT_EXPIRED,
1533      GSS_S_BAD_QOP */
1534   major = (*ftab-&gt;wrapSizeLimit)(&amp;minor, contextHdl, reqFlag,
1535                               qop, outSize, &amp;maxInSize);
1536 
1537   checkStatus(env, jobj, major, minor, "[GSSLibStub_wrapSizeLimit]");
1538   if ((*env)-&gt;ExceptionCheck(env)) {
1539     return 0;
1540   }
1541 
1542   /* Right-shift maxInSize until it fits into jint */
1543   result = (jint)maxInSize;
1544   while (result &lt; 0 || maxInSize != (OM_uint32)result) {
1545     result = (jint)(maxInSize &gt;&gt;= 1);
1546   }
1547 
1548   return result;
1549 }
1550 
1551 /*
1552  * Class:     sun_security_jgss_wrapper_GSSLibStub
1553  * Method:    exportContext
1554  * Signature: (J)[B
1555  */
1556 JNIEXPORT jbyteArray JNICALL
1557 Java_sun_security_jgss_wrapper_GSSLibStub_exportContext(JNIEnv *env,
1558                                                         jobject jobj,
1559                                                         jlong pContext)
1560 {
1561   OM_uint32 minor, major, dummy;
1562   gss_ctx_id_t contextHdl;
1563   gss_buffer_desc interProcToken = GSS_C_EMPTY_BUFFER;
1564 
1565   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1566 
1567   TRACE1("[GSSLibStub_exportContext] %" PRIuPTR "", (uintptr_t)contextHdl);
1568 
1569   if (contextHdl == GSS_C_NO_CONTEXT) {
1570     // Twik per javadoc
1571     checkStatus(env, jobj, GSS_S_NO_CONTEXT, 0, "[GSSLibStub_exportContext]");
1572     return NULL;
1573   }
1574   /* gss_export_sec_context(...) =&gt; GSS_S_CONTEXT_EXPIRED,
1575      GSS_S_NO_CONTEXT, GSS_S_UNAVAILABLE */
1576   major =
1577     (*ftab-&gt;exportSecContext)(&amp;minor, &amp;contextHdl, &amp;interProcToken);
1578 
1579   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportContext]");
1580   if ((*env)-&gt;ExceptionCheck(env)) {
1581     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;interProcToken);
1582     return NULL;
1583   }
1584 
1585   /* Map interProcToken to byteArray result and release */
1586   return getJavaBuffer(env, &amp;interProcToken, JNI_TRUE);
1587 }
1588 
1589 /*
1590  * Class:     sun_security_jgss_wrapper_GSSLibStub
1591  * Method:    getMic
1592  * Signature: (JI[B)[B
1593  */
1594 JNIEXPORT jbyteArray JNICALL
1595 Java_sun_security_jgss_wrapper_GSSLibStub_getMic(JNIEnv *env, jobject jobj,
1596                                                  jlong pContext, jint jqop,
1597                                                  jbyteArray jmsg)
1598 {
1599   OM_uint32 minor, major, dummy;
1600   gss_ctx_id_t contextHdl;
1601   gss_qop_t qop;
1602   gss_buffer_desc msg;
1603   gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;
1604 
1605   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1606 
1607   TRACE1("[GSSLibStub_getMic] %" PRIuPTR "", (uintptr_t)contextHdl);
1608 
1609   if (contextHdl == GSS_C_NO_CONTEXT) {
1610     // Twik per javadoc
1611     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_getMic]");
1612     return NULL;
1613   }
1614   qop = (gss_qop_t) jqop;
1615   initGSSBuffer(env, jmsg, &amp;msg, JNI_FALSE);
1616   if ((*env)-&gt;ExceptionCheck(env)) {
1617     return NULL;
1618   }
1619 
1620   /* gss_get_mic(...) =&gt; GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
1621      GSS_S_BAD_QOP */
1622   major = (*ftab-&gt;getMic)(&amp;minor, contextHdl, qop, &amp;msg, &amp;msgToken);
1623 
1624   /* release intermediate buffers */
1625   resetGSSBuffer(env, jmsg, &amp;msg);
1626   checkStatus(env, jobj, major, minor, "[GSSLibStub_getMic]");
1627   if ((*env)-&gt;ExceptionCheck(env)) {
1628     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;msgToken);
1629     return NULL;
1630   }
1631 
1632   /* Map msgToken to byteArray result and release */
1633   return getJavaBuffer(env, &amp;msgToken, JNI_TRUE);
1634 }
1635 
1636 /*
1637  * Class:     sun_security_jgss_wrapper_GSSLibStub
1638  * Method:    verifyMic
1639  * Signature: (J[B[BLorg/ietf/jgss/MessageProp;)V
1640  */
1641 JNIEXPORT void JNICALL
1642 Java_sun_security_jgss_wrapper_GSSLibStub_verifyMic(JNIEnv *env,
1643                                                     jobject jobj,
1644                                                     jlong pContext,
1645                                                     jbyteArray jmsgToken,
1646                                                     jbyteArray jmsg,
1647                                                     jobject jprop)
1648 {
1649   OM_uint32 minor, major;
1650   gss_ctx_id_t contextHdl;
1651   gss_buffer_desc msg;
1652   gss_buffer_desc msgToken;
1653   gss_qop_t qop;
1654 
1655   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1656 
1657   TRACE1("[GSSLibStub_verifyMic] %" PRIuPTR "", (uintptr_t)contextHdl);
1658 
1659   if (contextHdl == GSS_C_NO_CONTEXT) {
1660     // Twik per javadoc
1661     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0,
1662         "[GSSLibStub_verifyMic]");
1663     return;
1664   }
1665 
1666   qop = (gss_qop_t) (*env)-&gt;CallIntMethod(env, jprop, MID_MessageProp_getQOP);
1667   if ((*env)-&gt;ExceptionCheck(env)) { return; }
1668 
1669   initGSSBuffer(env, jmsg, &amp;msg, JNI_FALSE);
1670   if ((*env)-&gt;ExceptionCheck(env)) { return; }
1671 
1672   initGSSBuffer(env, jmsgToken, &amp;msgToken, JNI_FALSE);
1673   if ((*env)-&gt;ExceptionCheck(env)) {
1674     resetGSSBuffer(env, jmsg, &amp;msg);
1675     return;
1676   }
1677 
1678   /* gss_verify_mic(...) =&gt; GSS_S_DEFECTIVE_TOKEN, GSS_S_BAD_MIC,
1679      GSS_S_CONTEXT_EXPIRED, GSS_S_DUPLICATE_TOKEN(!), GSS_S_OLD_TOKEN(!),
1680      GSS_S_UNSEQ_TOKEN(!), GSS_S_GAP_TOKEN(!), GSS_S_NO_CONTEXT(!) */
1681   major =
1682     (*ftab-&gt;verifyMic)(&amp;minor, contextHdl, &amp;msg, &amp;msgToken, &amp;qop);
1683 
1684   /* release intermediate buffers */
1685   resetGSSBuffer(env, jmsg, &amp;msg);
1686   resetGSSBuffer(env, jmsgToken, &amp;msgToken);
1687 
1688   /*
1689    * We don't throw on supplementary status codes here, instead we pass only
1690    * GSS_ERROR(major) to checkStatus() and set the supplementary status in the
1691    * message properties.
1692    */
1693   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_verifyMic]");
1694   if ((*env)-&gt;ExceptionCheck(env)) {
1695     return;
1696   }
1697 
1698   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
1699   if ((*env)-&gt;ExceptionCheck(env)) {
1700     return;
1701   }
1702 
1703   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
1704                        minor);
1705 }
1706 
1707 /*
1708  * Class:     sun_security_jgss_wrapper_GSSLibStub
1709  * Method:    wrap
1710  * Signature: (J[BLorg/ietf/jgss/MessageProp;)[B
1711  */
1712 JNIEXPORT jbyteArray JNICALL
1713 Java_sun_security_jgss_wrapper_GSSLibStub_wrap(JNIEnv *env,
1714                                                jobject jobj,
1715                                                jlong pContext,
1716                                                jbyteArray jmsg,
1717                                                jobject jprop)
1718 {
1719   OM_uint32 minor, major, dummy;
1720   jboolean confFlag;
1721   gss_qop_t qop;
1722   gss_buffer_desc msg;
1723   gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;
1724   int confState;
1725   gss_ctx_id_t contextHdl;
1726   jbyteArray jresult;
1727 
1728   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1729 
1730   TRACE1("[GSSLibStub_wrap] %" PRIuPTR "", (uintptr_t)contextHdl);
1731 
1732   if (contextHdl == GSS_C_NO_CONTEXT) {
1733     // Twik per javadoc
1734     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_wrap]");
1735     return NULL;
1736   }
1737 
1738   confFlag =
1739     (*env)-&gt;CallBooleanMethod(env, jprop, MID_MessageProp_getPrivacy);
1740   if ((*env)-&gt;ExceptionCheck(env)) {
1741     return NULL;
1742   }
1743 
1744   qop = (gss_qop_t)
1745     (*env)-&gt;CallIntMethod(env, jprop, MID_MessageProp_getQOP);
1746   if ((*env)-&gt;ExceptionCheck(env)) {
1747     return NULL;
1748   }
1749 
1750   initGSSBuffer(env, jmsg, &amp;msg, JNI_FALSE);
1751   if ((*env)-&gt;ExceptionCheck(env)) {
1752     return NULL;
1753   }
1754 
1755   /* gss_wrap(...) =&gt; GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
1756      GSS_S_BAD_QOP */
1757   major = (*ftab-&gt;wrap)(&amp;minor, contextHdl, confFlag, qop, &amp;msg, &amp;confState,
1758                    &amp;msgToken);
1759 
1760   /* release intermediate buffers */
1761   resetGSSBuffer(env, jmsg, &amp;msg);
1762   checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
1763 
1764   if ((*env)-&gt;ExceptionCheck(env)) {
1765     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;msgToken);
1766     return NULL;
1767   }
1768 
1769   /* Map msgToken to byteArray result and release */
1770   jresult = getJavaBuffer(env, &amp;msgToken, JNI_TRUE);
1771   if ((*env)-&gt;ExceptionCheck(env)) {
1772     return NULL;
1773   }
1774 
1775   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
1776                          (confState? JNI_TRUE:JNI_FALSE));
1777   if ((*env)-&gt;ExceptionCheck(env)) {
1778     (*env)-&gt;DeleteLocalRef(env, jresult);
1779     jresult = NULL;
1780   }
1781   return jresult;
1782 }
1783 
1784 /*
1785  * Class:     sun_security_jgss_wrapper_GSSLibStub
1786  * Method:    unwrap
1787  * Signature: (J[BLorg/ietf/jgss/MessageProp;)[B
1788  */
1789 JNIEXPORT jbyteArray JNICALL
1790 Java_sun_security_jgss_wrapper_GSSLibStub_unwrap(JNIEnv *env,
1791                                                  jobject jobj,
1792                                                  jlong pContext,
1793                                                  jbyteArray jmsgToken,
1794                                                  jobject jprop)
1795 {
1796   OM_uint32 minor, major, dummy;
1797   gss_ctx_id_t contextHdl;
1798   gss_buffer_desc msgToken;
1799   gss_buffer_desc msg = GSS_C_EMPTY_BUFFER;
1800   int confState;
1801   gss_qop_t qop;
1802   jbyteArray jresult;
1803 
1804   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
1805 
1806   TRACE1("[GSSLibStub_unwrap] %" PRIuPTR "", (uintptr_t)contextHdl);
1807 
1808   if (contextHdl == GSS_C_NO_CONTEXT) {
1809     // Twik per javadoc
1810     checkStatus(env, jobj, GSS_S_CONTEXT_EXPIRED, 0, "[GSSLibStub_unwrap]");
1811     return NULL;
1812   }
1813 
1814   initGSSBuffer(env, jmsgToken, &amp;msgToken, JNI_FALSE);
1815   if ((*env)-&gt;ExceptionCheck(env)) {
1816     return NULL;
1817   }
1818 
1819   confState = 0;
1820   qop = GSS_C_QOP_DEFAULT;
1821   /* gss_unwrap(...) =&gt; GSS_S_DEFECTIVE_TOKEN, GSS_S_BAD_MIC,
1822      GSS_S_CONTEXT_EXPIRED, GSS_S_DUPLICATE_TOKEN(!), GSS_S_OLD_TOKEN(!),
1823      GSS_S_UNSEQ_TOKEN(!), GSS_S_GAP_TOKEN(!), GSS_S_NO_CONTEXT(!) */
1824   major =
1825     (*ftab-&gt;unwrap)(&amp;minor, contextHdl, &amp;msgToken, &amp;msg, &amp;confState, &amp;qop);
1826 
1827   /* release intermediate buffers */
1828   resetGSSBuffer(env, jmsgToken, &amp;msgToken);
1829 
1830   /*
1831    * We don't throw on supplementary status codes here, instead we pass only
1832    * GSS_ERROR(major) to checkStatus() and set the supplementary status in the
1833    * message properties.
1834    */
1835   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");
1836   if ((*env)-&gt;ExceptionCheck(env)) {
1837     (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, &amp;msg);
1838     return NULL;
1839   }
1840 
1841   /*
1842    * Map msg to byteArray result and release, zero length msg maps to empty
1843    * byte array, not null.
1844    */
1845   jresult = getJavaBuffer(env, &amp;msg, JNI_FALSE);
1846   if ((*env)-&gt;ExceptionCheck(env)) {
1847     return NULL;
1848   }
1849 
1850   /* update the message prop with relevant info */
1851   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
1852                          (confState != 0));
1853   if ((*env)-&gt;ExceptionCheck(env)) {
1854     (*env)-&gt;DeleteLocalRef(env, jresult);
1855     return NULL;
1856   }
1857   (*env)-&gt;CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
1858   if ((*env)-&gt;ExceptionCheck(env)) {
1859     (*env)-&gt;DeleteLocalRef(env, jresult);
1860     return NULL;
1861   }
1862   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
1863                          minor);
1864   if ((*env)-&gt;ExceptionCheck(env)) {
1865     (*env)-&gt;DeleteLocalRef(env, jresult);
1866     return NULL;
1867   }
1868 
1869   return jresult;
1870 }
</pre></body></html>
