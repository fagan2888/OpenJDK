--- old/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c	2019-10-21 14:15:14.700473180 -0500
+++ new/src/java.security.jgss/share/native/libj2gss/GSSLibStub.c	2019-10-21 14:15:14.708473080 -0500
@@ -149,21 +149,20 @@
  * Utility routine which releases the specified gss_channel_bindings_t
  * structure.
  */
-void deleteGSSCB(gss_channel_bindings_t cb) {
-
+static void deleteGSSCB(JNIEnv *env, gss_channel_bindings_t cb) {
   if (cb == GSS_C_NO_CHANNEL_BINDINGS) return;
 
   /* release initiator address */
   if (cb->initiator_addrtype != GSS_C_AF_NULLADDR) {
-    resetGSSBuffer(&(cb->initiator_address));
+    resetGSSBuffer(env, NULL, &(cb->initiator_address));
   }
   /* release acceptor address */
   if (cb->acceptor_addrtype != GSS_C_AF_NULLADDR) {
-    resetGSSBuffer(&(cb->acceptor_address));
+    resetGSSBuffer(env, NULL, &(cb->acceptor_address));
   }
   /* release application data */
-  if (cb->application_data.length != 0) {
-    resetGSSBuffer(&(cb->application_data));
+  if (cb->application_data.value != NULL) {
+    resetGSSBuffer(env, NULL, &(cb->application_data));
   }
   free(cb);
 }
@@ -188,9 +187,11 @@
     return NULL;
   }
 
-  // initialize addrtype in CB first
+  /* Fully initialize to a state safe for cleanup */
   cb->initiator_addrtype = GSS_C_AF_NULLADDR;
   cb->acceptor_addrtype = GSS_C_AF_NULLADDR;
+  cb->application_data.length = 0;
+  cb->application_data.value = NULL;
 
   // addresses needs to be initialized to empty
   memset(&cb->initiator_address, 0, sizeof(cb->initiator_address));
@@ -208,11 +209,11 @@
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
-    cb->initiator_addrtype = GSS_C_AF_INET;
-    initGSSBuffer(env, value, &(cb->initiator_address));
+    initGSSBuffer(env, value, &(cb->initiator_address), JNI_TRUE);
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
+    cb->initiator_addrtype = GSS_C_AF_INET;
   }
   /* set up acceptor address */
   jinetAddr = (*env)->CallObjectMethod(env, jcb,
@@ -226,11 +227,11 @@
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
-    cb->acceptor_addrtype = GSS_C_AF_INET;
-    initGSSBuffer(env, value, &(cb->acceptor_address));
+    initGSSBuffer(env, value, &(cb->acceptor_address), JNI_TRUE);
     if ((*env)->ExceptionCheck(env)) {
       goto cleanup;
     }
+    cb->acceptor_addrtype = GSS_C_AF_INET;
   }
   /* set up application data */
   value = (*env)->CallObjectMethod(env, jcb,
@@ -238,13 +239,13 @@
   if ((*env)->ExceptionCheck(env)) {
     goto cleanup;
   }
-  initGSSBuffer(env, value, &(cb->application_data));
+  initGSSBuffer(env, value, &(cb->application_data), JNI_TRUE);
   if ((*env)->ExceptionCheck(env)) {
     goto cleanup;
   }
   return cb;
 cleanup:
-  deleteGSSCB(cb);
+  deleteGSSCB(env, cb);
   return NULL;
 }
 
@@ -295,7 +296,7 @@
 Java_sun_security_jgss_wrapper_GSSLibStub_inquireNamesForMech(JNIEnv *env,
                                                               jobject jobj)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_OID mech;
   gss_OID_set nameTypes;
   jobjectArray result;
@@ -309,7 +310,7 @@
 
     /* release intermediate buffers before checking status */
     result = getJavaOIDArray(env, nameTypes);
-    deleteGSSOIDSet(nameTypes);
+    (*ftab->releaseOidSet)(&dummy, &nameTypes);
     if ((*env)->ExceptionCheck(env)) {
       return NULL;
     }
@@ -366,14 +367,14 @@
 
   TRACE0("[GSSLibStub_importName]");
 
-  initGSSBuffer(env, jnameVal, &nameVal);
+  initGSSBuffer(env, jnameVal, &nameVal, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
       return jlong_zero;
   }
 
   nameType = newGSSOID(env, jnameType);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&nameVal);
+    resetGSSBuffer(env, jnameVal, &nameVal);
     return jlong_zero;
   }
 
@@ -385,7 +386,7 @@
 
   /* release intermediate buffers */
   deleteGSSOID(nameType);
-  resetGSSBuffer(&nameVal);
+  resetGSSBuffer(env, jnameVal, &nameVal);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_importName]");
   if ((*env)->ExceptionCheck(env)) {
@@ -472,10 +473,9 @@
 Java_sun_security_jgss_wrapper_GSSLibStub_exportName(JNIEnv *env,
                                                      jobject jobj,
                                                      jlong pName) {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_name_t nameHdl, mNameHdl;
-  gss_buffer_desc outBuf;
-  jbyteArray jresult;
+  gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;
 
   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 
@@ -500,26 +500,79 @@
     }
 
     major = (*ftab->exportName)(&minor, mNameHdl, &outBuf);
-    Java_sun_security_jgss_wrapper_GSSLibStub_releaseName
-                                        (env, jobj, ptr_to_jlong(mNameHdl));
-    if ((*env)->ExceptionCheck(env)) {
-      /* release intermediate buffers */
-      (*ftab->releaseBuffer)(&minor, &outBuf);
-      return NULL;
-    }
+    (void) (*ftab->releaseName)(&dummy, &mNameHdl);
   }
 
-  /* release intermediate buffers before checking status */
-  jresult = getJavaBuffer(env, &outBuf);
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_exportName]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outBuf);
     return NULL;
   }
+  /* Map outBuf to byteArray result and release */
+  return getJavaBuffer(env, &outBuf, JNI_TRUE);
+}
 
-  checkStatus(env, jobj, major, minor, "[GSSLibStub_exportName]");
-  if ((*env)->ExceptionCheck(env)) {
+/*
+ * Class:     sun_security_jgss_wrapper_GSSLibStub
+ * Method:    localName
+ * Signature: (J)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_sun_security_jgss_wrapper_GSSLibStub_localName(JNIEnv *env,
+                                                    jobject jobj,
+                                                    jlong pName,
+                                                    jobject jOid)
+{
+  OM_uint32 minor, major, dummy;
+  gss_name_t nameHdl, mnNameHdl;
+  gss_buffer_desc outBuf = GSS_C_EMPTY_BUFFER;
+  gss_OID mech;
+
+  nameHdl = (gss_name_t) jlong_to_ptr(pName);
+
+  if (ftab->localName == NULL) {
+    TRACE0("GSSLibStub_localName not supported by GSS provider");
+    checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,
+                "[GSSLibStub_localName]");
     return NULL;
   }
-  return jresult;
+  mech = newGSSOID(env, jOid);
+
+  /* gss_localname(...) => GSS_S_NAME_NOT_MN, GSS_S_BAD_NAMETYPE,
+     GSS_S_BAD_NAME */
+  major = (*ftab->localName)(&minor, nameHdl, mech, &outBuf);
+  if (major == GSS_S_COMPLETE) {
+    deleteGSSOID(mech);
+    return getJavaString(env, &outBuf);
+  }
+  (*ftab->releaseBuffer)(&minor, &outBuf);
+
+  if (major != GSS_S_NAME_NOT_MN) {
+    checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+    goto err;
+  }
+
+  /* canonicalize the internal name to MN and retry */
+  TRACE0("[GSSLibStub_localName] canonicalize and re-try");
+
+  major = (*ftab->canonicalizeName)(&minor, nameHdl, mech, &mnNameHdl);
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+  if ((*env)->ExceptionCheck(env))
+    goto err;
+
+  major = (*ftab->localName)(&minor, mnNameHdl, mech, &outBuf);
+  (void) (*ftab->releaseName)(&dummy, &mnNameHdl);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_localName]");
+  if ((*env)->ExceptionCheck(env) == JNI_FALSE && major == GSS_S_COMPLETE) {
+    deleteGSSOID(mech);
+    return getJavaString(env, &outBuf);
+  }
+  (*ftab->releaseBuffer)(&minor, &outBuf);
+
+err:
+  deleteGSSOID(mech);
+  return NULL;
 }
 
 /*
@@ -533,7 +586,7 @@
                                                       jlong pName) {
   OM_uint32 minor, major;
   gss_name_t nameHdl;
-  gss_buffer_desc outNameBuf;
+  gss_buffer_desc outNameBuf = GSS_C_EMPTY_BUFFER;
   gss_OID outNameType;
   jstring jname;
   jobject jtype;
@@ -588,17 +641,20 @@
 /*
  * Class:     sun_security_jgss_wrapper_GSSLibStub
  * Method:    acquireCred
- * Signature: (JII)J
+ * Signature: (JLjava/lang/String;[II)J
  */
 JNIEXPORT jlong JNICALL
 Java_sun_security_jgss_wrapper_GSSLibStub_acquireCred(JNIEnv *env,
                                                       jobject jobj,
                                                       jlong pName,
+                                                      jstring jPassword,
+                                                      jarray jCredStore,
                                                       jint reqTime,
                                                       jint usage)
 {
   OM_uint32 minor, major;
   gss_OID mech;
+  gss_OID_set_desc singleton;
   gss_OID_set mechs;
   gss_cred_usage_t credUsage;
   gss_name_t nameHdl;
@@ -608,7 +664,7 @@
   TRACE0("[GSSLibStub_acquireCred]");
 
   mech = (gss_OID) jlong_to_ptr((*env)->GetLongField(env, jobj, FID_GSSLibStub_pMech));
-  mechs = newGSSOIDSet(mech);
+  mechs = makeGSSOIDSet(&singleton, mech);
   credUsage = (gss_cred_usage_t) usage;
   nameHdl = (gss_name_t) jlong_to_ptr(pName);
 
@@ -616,11 +672,52 @@
 
   /* gss_acquire_cred(...) => GSS_S_BAD_MECH, GSS_S_BAD_NAMETYPE,
      GSS_S_BAD_NAME, GSS_S_CREDENTIALS_EXPIRED, GSS_S_NO_CRED */
-  major =
-    (*ftab->acquireCred)(&minor, nameHdl, reqTime, mechs,
-                     credUsage, &credHdl, NULL, NULL);
-  /* release intermediate buffers */
-  deleteGSSOIDSet(mechs);
+  if (jPassword == NULL && jCredStore == NULL) {
+    major = (*ftab->acquireCred)(&minor, nameHdl, reqTime, mechs, credUsage,
+                                 &credHdl, NULL, NULL);
+  } else if (jPassword != NULL) {
+    gss_buffer_desc password;
+
+    if (ftab->acquireCredWithPassword == NULL) {
+      const char *msg = "GSSLibStub_acquireCred with password not supported "
+          "by GSS provider";
+
+      TRACE0(msg);
+      checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, msg);
+      return ptr_to_jlong(NULL);
+    }
+
+    initGSSBufferString(env, jPassword, &password);
+    if ((*env)->ExceptionCheck(env)) {
+      return jlong_zero;
+    }
+    major = (*ftab->acquireCredWithPassword)(&minor, nameHdl, &password,
+                                             reqTime, mechs, credUsage,
+                                             &credHdl, NULL, NULL);
+    resetGSSBufferString(env, jPassword, &password);
+  } else {
+    gss_key_value_set_desc credStore = {0, 0};
+
+    if (ftab->acquireCredFrom == NULL) {
+      const char *msg = "GSSLibStub_acquireCred from credential store not "
+          "supported by GSS provider";
+
+      TRACE0("[GSSLibStub_acquireCred] acquiring from a specific credential "
+             "store not supported by GSS provider");
+      checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0,
+                  "[GSSLibStub_acquireCred]");
+      return ptr_to_jlong(NULL);
+    }
+
+    initGSSCredStore(env, jCredStore, &credStore);
+    if ((*env)->ExceptionCheck(env)) {
+      return jlong_zero;
+    }
+    major = (*ftab->acquireCredFrom)(&minor, nameHdl, reqTime, mechs,
+                                     credUsage, &credStore, &credHdl,
+                                     NULL, NULL);
+    resetGSSCredStore(env, jCredStore, &credStore);
+  }
 
   TRACE1("[GSSLibStub_acquireCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
 
@@ -633,6 +730,64 @@
 
 /*
  * Class:     sun_security_jgss_wrapper_GSSLibStub
+ * Method:    storeCred
+ * Signature: (JILorg/ietf/jgss/Oid;ZZ[)J
+ */
+JNIEXPORT jlong JNICALL
+Java_sun_security_jgss_wrapper_GSSLibStub_storeCred(JNIEnv *env,
+                                                    jobject jobj,
+                                                    jlong pCred,
+                                                    jint usage,
+                                                    jobject jmech,
+                                                    jboolean overwrite,
+                                                    jboolean defaultCred,
+                                                    jarray jCredStore)
+{
+  OM_uint32 minor, major;
+  gss_key_value_set_desc credStore;
+  gss_cred_usage_t credUsage;
+  gss_cred_id_t credHdl;
+  gss_OID mech;
+
+  TRACE0("[GSSLibStub_storeCred]");
+
+  credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
+  credUsage = (gss_cred_usage_t) usage;
+
+  mech = newGSSOID(env, jmech);
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+
+  TRACE2("[GSSLibStub_storeCred] pCred=%ld, usage=%d", (long)pCred, usage);
+
+  if (ftab->storeCredInto == NULL) {
+    TRACE0("[GSSLibStub_storeCred] GSSLibStub_storeCred not supported by "
+           "GSS provider");
+    checkStatus(env, jobj, GSS_S_UNAVAILABLE, minor=0, "[GSSLibStub_storeCred]");
+    return ptr_to_jlong(NULL);
+  }
+
+  initGSSCredStore(env, jCredStore, &credStore);
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+  major = (*ftab->storeCredInto)(&minor, credHdl, credUsage, mech,
+                                 overwrite, defaultCred, &credStore,
+                                 NULL, NULL);
+  resetGSSCredStore(env, jCredStore, &credStore);
+
+  TRACE1("[GSSLibStub_storeCred] pCred=%" PRIuPTR "", (uintptr_t) credHdl);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_storeCred]");
+  if ((*env)->ExceptionCheck(env)) {
+    return jlong_zero;
+  }
+  return ptr_to_jlong(credHdl);
+}
+
+/*
+ * Class:     sun_security_jgss_wrapper_GSSLibStub
  * Method:    releaseCred
  * Signature: (J)J
  */
@@ -792,7 +947,7 @@
   TRACE0("[GSSLibStub_importContext]");
 
   contextHdl = GSS_C_NO_CONTEXT;
-  initGSSBuffer(env, jctxtToken, &ctxtToken);
+  initGSSBuffer(env, jctxtToken, &ctxtToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -804,7 +959,7 @@
   TRACE1("[GSSLibStub_importContext] pContext=%" PRIuPTR "", (uintptr_t) contextHdl);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&ctxtToken);
+  resetGSSBuffer(env, jctxtToken, &ctxtToken);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_importContext]");
   /* return immediately if an exception has occurred */
@@ -834,7 +989,7 @@
   } else {
     /* mech mismatch - clean up then return null */
     major = (*ftab->deleteSecContext)(&minor, &contextHdl, GSS_C_NO_BUFFER);
-    checkStatus(env, jobj, major, minor,
+    checkStatus(env, jobj, GSS_S_FAILURE, minor,
         "[GSSLibStub_importContext] cleanup");
     return NULL;
   }
@@ -854,7 +1009,7 @@
                                                       jbyteArray jinToken,
                                                       jobject jcontextSpi)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_cred_id_t credHdl ;
   gss_ctx_id_t contextHdl, contextHdlSave;
   gss_name_t targetName;
@@ -863,12 +1018,9 @@
   OM_uint32 time, aTime;
   gss_channel_bindings_t cb;
   gss_buffer_desc inToken;
-  gss_buffer_desc outToken;
-  jbyteArray jresult;
-/* UNCOMMENT after SEAM bug#6287358 is backported to S10
+  gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
   gss_OID aMech;
   jobject jMech;
-*/
 
   TRACE0("[GSSLibStub_initContext]");
 
@@ -886,9 +1038,9 @@
     return NULL;
   }
 
-  initGSSBuffer(env, jinToken, &inToken);
+  initGSSBuffer(env, jinToken, &inToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
-    deleteGSSCB(cb);
+    deleteGSSCB(env, cb);
     return NULL;
   }
 
@@ -902,7 +1054,7 @@
      GSS_S_BAD_NAMETYPE, GSS_S_BAD_NAME(!), GSS_S_BAD_MECH */
   major = (*ftab->initSecContext)(&minor, credHdl,
                                  &contextHdl, targetName, mech,
-                                 flags, time, cb, &inToken, NULL /*aMech*/,
+                                 flags, time, cb, &inToken, &aMech,
                                  &outToken, &aFlags, &aTime);
 
   TRACE2("[GSSLibStub_initContext] after: pContext=%" PRIuPTR ", outToken len=%ld",
@@ -931,30 +1083,28 @@
                               FID_NativeGSSContext_isEstablished,
                               JNI_TRUE);
 
-/* UNCOMMENT after SEAM bug#6287358 is backported to S10
-      jMech = getJavaOID(env, aMech);
-      (*env)->SetObjectField(env, jcontextSpi,
-                             FID_NativeGSSContext_actualMech, jMech);
-*/
+      jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);
+      if (!(*env)->ExceptionCheck(env)) {
+        (*env)->SetObjectField(env, jcontextSpi,
+                               FID_NativeGSSContext_actualMech, jMech);
+      }
     } else if (major & GSS_S_CONTINUE_NEEDED) {
       TRACE0("[GSSLibStub_initContext] context not established");
-      major -= GSS_S_CONTINUE_NEEDED;
+      major &= ~GSS_S_CONTINUE_NEEDED;
     }
   }
 
   /* release intermediate buffers before checking status */
-  deleteGSSCB(cb);
-  resetGSSBuffer(&inToken);
-  jresult = getJavaBuffer(env, &outToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
+  deleteGSSCB(env, cb);
+  resetGSSBuffer(env, jinToken, &inToken);
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_initContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outToken);
     return NULL;
   }
-  return jresult;
+  /* Map outToken to byteArray result and release */
+  return getJavaBuffer(env, &outToken, JNI_TRUE);
 }
 
 /*
@@ -970,23 +1120,23 @@
                                                         jbyteArray jinToken,
                                                         jobject jcontextSpi)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   OM_uint32 minor2, major2;
   gss_ctx_id_t contextHdl, contextHdlSave;
   gss_cred_id_t credHdl;
   gss_buffer_desc inToken;
   gss_channel_bindings_t cb;
-  gss_name_t srcName;
-  gss_buffer_desc outToken;
+  gss_name_t srcName = GSS_C_NO_NAME;
+  gss_buffer_desc outToken = GSS_C_EMPTY_BUFFER;
   gss_OID aMech;
   OM_uint32 aFlags;
   OM_uint32 aTime;
-  gss_cred_id_t delCred;
+  gss_cred_id_t delCred = GSS_C_NO_CREDENTIAL;
   jobject jsrcName = NULL;
   jobject jdelCred;
-  jobject jMech;
+  jobject jMech = NULL;
   jboolean setTarget;
-  gss_name_t targetName;
+  gss_name_t targetName = GSS_C_NO_NAME;
   jobject jtargetName;
 
   TRACE0("[GSSLibStub_acceptContext]");
@@ -994,17 +1144,15 @@
   contextHdl = contextHdlSave = (gss_ctx_id_t)jlong_to_ptr(
     (*env)->GetLongField(env, jcontextSpi, FID_NativeGSSContext_pContext));
   credHdl = (gss_cred_id_t) jlong_to_ptr(pCred);
-  initGSSBuffer(env, jinToken, &inToken);
+  initGSSBuffer(env, jinToken, &inToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
   cb = newGSSCB(env, jcb);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&inToken);
+    resetGSSBuffer(env, jinToken, &inToken);
     return NULL;
   }
-  srcName = targetName = GSS_C_NO_NAME;
-  delCred = GSS_C_NO_CREDENTIAL;
   setTarget = (credHdl == GSS_C_NO_CREDENTIAL);
   aFlags = 0;
 
@@ -1022,8 +1170,8 @@
                            &aFlags, &aTime, &delCred);
   /* release intermediate buffers before checking status */
 
-  deleteGSSCB(cb);
-  resetGSSBuffer(&inToken);
+  deleteGSSCB(env, cb);
+  resetGSSBuffer(env, jinToken, &inToken);
 
   TRACE3("[GSSLibStub_acceptContext] after: pCred=%" PRIuPTR ", pContext=%" PRIuPTR ", pDelegCred=%" PRIuPTR "",
         (uintptr_t)credHdl, (uintptr_t)contextHdl, (uintptr_t) delCred);
@@ -1039,9 +1187,19 @@
 
   if (GSS_ERROR(major) == GSS_S_COMPLETE) {
     /* update member values if needed */
-    // WORKAROUND for a Heimdal bug
+
+    jMech = (aMech == GSS_C_NO_OID) ? NULL : getJavaOID(env, aMech);
+    if (!(*env)->ExceptionCheck(env)) {
+      (*env)->SetObjectField(env, jcontextSpi,
+                             FID_NativeGSSContext_actualMech, jMech);
+    }
+    if ((*env)->ExceptionCheck(env)) {
+      goto error;
+    }
+
+    /* WORKAROUND for an old Heimdal bug */
     if (delCred == GSS_C_NO_CREDENTIAL) {
-        aFlags &= 0xfffffffe;
+        aFlags &= ~GSS_C_DELEG_FLAG;
     }
     (*env)->SetIntField(env, jcontextSpi, FID_NativeGSSContext_flags, aFlags);
     TRACE1("[GSSLibStub_acceptContext] set flags=0x%x", aFlags);
@@ -1058,13 +1216,14 @@
 
       jtargetName = (*env)->NewObject(env, CLS_GSSNameElement,
                                 MID_GSSNameElement_ctor,
-                                ptr_to_jlong(targetName), jobj);
+                                ptr_to_jlong(targetName), jMech, jobj);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
 
       TRACE1("[GSSLibStub_acceptContext] set targetName=%" PRIuPTR "",
               (uintptr_t)targetName);
+      targetName = GSS_C_NO_NAME;
 
       (*env)->SetObjectField(env, jcontextSpi, FID_NativeGSSContext_targetName,
                              jtargetName);
@@ -1075,12 +1234,13 @@
     if (srcName != GSS_C_NO_NAME) {
       jsrcName = (*env)->NewObject(env, CLS_GSSNameElement,
                                    MID_GSSNameElement_ctor,
-                                   ptr_to_jlong(srcName), jobj);
+                                   ptr_to_jlong(srcName), jMech, jobj);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
 
       TRACE1("[GSSLibStub_acceptContext] set srcName=%" PRIuPTR "", (uintptr_t)srcName);
+      srcName = GSS_C_NO_NAME;
 
       (*env)->SetObjectField(env, jcontextSpi, FID_NativeGSSContext_srcName,
                              jsrcName);
@@ -1096,12 +1256,6 @@
       (*env)->SetBooleanField(env, jcontextSpi,
                               FID_NativeGSSContext_isEstablished,
                               JNI_TRUE);
-      jMech = getJavaOID(env, aMech);
-      if ((*env)->ExceptionCheck(env)) {
-        goto error;
-      }
-      (*env)->SetObjectField(env, jcontextSpi,
-                             FID_NativeGSSContext_actualMech, jMech);
       if ((*env)->ExceptionCheck(env)) {
         goto error;
       }
@@ -1112,11 +1266,12 @@
         if ((*env)->ExceptionCheck(env)) {
           goto error;
         }
+        TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",
+                (uintptr_t) delCred);
+        delCred = GSS_C_NO_CREDENTIAL;
         (*env)->SetObjectField(env, jcontextSpi,
                                FID_NativeGSSContext_delegatedCred,
                                jdelCred);
-        TRACE1("[GSSLibStub_acceptContext] set delegatedCred=%" PRIuPTR "",
-                (uintptr_t) delCred);
 
         if ((*env)->ExceptionCheck(env)) {
           goto error;
@@ -1129,10 +1284,18 @@
         (*env)->SetIntField(env, jcontextSpi, FID_NativeGSSContext_lifetime,
                             getJavaTime(aTime));
       }
-      major -= GSS_S_CONTINUE_NEEDED;
+      major &= ~GSS_S_CONTINUE_NEEDED;
     }
   }
-  return getJavaBuffer(env, &outToken);
+
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_acceptContext]");
+  if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &outToken);
+    return NULL;
+  }
+
+  /* Map outToken to byteArray result and release */
+  return getJavaBuffer(env, &outToken, JNI_TRUE);
 
 error:
   (*ftab->releaseBuffer)(&minor, &outToken);
@@ -1158,12 +1321,14 @@
                                                          jobject jobj,
                                                          jlong pContext)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
-  gss_name_t srcName, targetName;
-  OM_uint32 time;
-  OM_uint32 flags;
-  int isInitiator, isEstablished;
+  gss_name_t srcName = GSS_C_NO_NAME;
+  gss_name_t targetName = GSS_C_NO_NAME;
+  OM_uint32 time = 0;
+  OM_uint32 flags = 0;
+  int isInitiator = 0;
+  int isEstablished = 0;
   jlong result[6];
   jlongArray jresult;
 
@@ -1171,10 +1336,6 @@
 
   TRACE1("[GSSLibStub_inquireContext] %" PRIuPTR "", (uintptr_t)contextHdl);
 
-  srcName = targetName = GSS_C_NO_NAME;
-  time = 0;
-  flags = isInitiator = isEstablished = 0;
-
   /* gss_inquire_context(...) => GSS_S_NO_CONTEXT(!) */
   major = (*ftab->inquireContext)(&minor, contextHdl, &srcName,
                               &targetName, &time, NULL, &flags,
@@ -1185,6 +1346,8 @@
 
   checkStatus(env, jobj, major, minor, "[GSSLibStub_inquireContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseName)(&dummy, &srcName);
+    (void) (*ftab->releaseName)(&dummy, &targetName);
     return NULL;
   }
   result[0] = ptr_to_jlong(srcName);
@@ -1195,11 +1358,12 @@
   result[5] = (jlong) getJavaTime(time);
 
   jresult = (*env)->NewLongArray(env, 6);
-  if (jresult == NULL) {
-    return NULL;
+  if (jresult != NULL) {
+    (*env)->SetLongArrayRegion(env, jresult, 0, 6, result);
   }
-  (*env)->SetLongArrayRegion(env, jresult, 0, 6, result);
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseName)(&dummy, &srcName);
+    (void) (*ftab->releaseName)(&dummy, &targetName);
     return NULL;
   }
   return jresult;
@@ -1245,7 +1409,7 @@
   jobject jobj, jlong pContext, jboolean isSrc)
 {
   OM_uint32 minor, major;
-  gss_name_t nameHdl;
+  gss_name_t nameHdl = GSS_C_NO_NAME;
   gss_ctx_id_t contextHdl;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
@@ -1253,7 +1417,6 @@
   TRACE2("[GSSLibStub_getContextName] %" PRIuPTR ", isSrc=%d",
           (uintptr_t)contextHdl, isSrc);
 
-  nameHdl = GSS_C_NO_NAME;
   if (isSrc == JNI_TRUE) {
     major = (*ftab->inquireContext)(&minor, contextHdl, &nameHdl, NULL,
                                 NULL, NULL, NULL,  NULL, NULL);
@@ -1351,6 +1514,7 @@
   gss_ctx_id_t contextHdl;
   OM_uint32 outSize, maxInSize;
   gss_qop_t qop;
+  jint result;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1374,7 +1538,14 @@
   if ((*env)->ExceptionCheck(env)) {
     return 0;
   }
-  return (jint) maxInSize;
+
+  /* Right-shift maxInSize until it fits into jint */
+  result = (jint)maxInSize;
+  while (result < 0 || maxInSize != (OM_uint32)result) {
+    result = (jint)(maxInSize >>= 1);
+  }
+
+  return result;
 }
 
 /*
@@ -1387,10 +1558,9 @@
                                                         jobject jobj,
                                                         jlong pContext)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
-  gss_buffer_desc interProcToken;
-  jbyteArray jresult;
+  gss_buffer_desc interProcToken = GSS_C_EMPTY_BUFFER;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1406,17 +1576,14 @@
   major =
     (*ftab->exportSecContext)(&minor, &contextHdl, &interProcToken);
 
-  /* release intermediate buffers */
-  jresult = getJavaBuffer(env, &interProcToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
   checkStatus(env, jobj, major, minor, "[GSSLibStub_exportContext]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &interProcToken);
     return NULL;
   }
 
-  return jresult;
+  /* Map interProcToken to byteArray result and release */
+  return getJavaBuffer(env, &interProcToken, JNI_TRUE);
 }
 
 /*
@@ -1429,12 +1596,11 @@
                                                  jlong pContext, jint jqop,
                                                  jbyteArray jmsg)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
   gss_qop_t qop;
   gss_buffer_desc msg;
-  gss_buffer_desc msgToken;
-  jbyteArray jresult;
+  gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;
 
   contextHdl = (gss_ctx_id_t) jlong_to_ptr(pContext);
 
@@ -1446,28 +1612,25 @@
     return NULL;
   }
   qop = (gss_qop_t) jqop;
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
 
   /* gss_get_mic(...) => GSS_S_CONTEXT_EXPIRED, GSS_S_NO_CONTEXT(!),
      GSS_S_BAD_QOP */
-  major =
-    (*ftab->getMic)(&minor, contextHdl, qop, &msg, &msgToken);
+  major = (*ftab->getMic)(&minor, contextHdl, qop, &msg, &msgToken);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
-  jresult = getJavaBuffer(env, &msgToken);
-  if ((*env)->ExceptionCheck(env)) {
-    return NULL;
-  }
+  resetGSSBuffer(env, jmsg, &msg);
   checkStatus(env, jobj, major, minor, "[GSSLibStub_getMic]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
     return NULL;
   }
 
-  return jresult;
+  /* Map msgToken to byteArray result and release */
+  return getJavaBuffer(env, &msgToken, JNI_TRUE);
 }
 
 /*
@@ -1503,12 +1666,12 @@
   qop = (gss_qop_t) (*env)->CallIntMethod(env, jprop, MID_MessageProp_getQOP);
   if ((*env)->ExceptionCheck(env)) { return; }
 
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) { return; }
 
-  initGSSBuffer(env, jmsgToken, &msgToken);
+  initGSSBuffer(env, jmsgToken, &msgToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
-    resetGSSBuffer(&msg);
+    resetGSSBuffer(env, jmsg, &msg);
     return;
   }
 
@@ -1519,9 +1682,14 @@
     (*ftab->verifyMic)(&minor, contextHdl, &msg, &msgToken, &qop);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
-  resetGSSBuffer(&msgToken);
+  resetGSSBuffer(env, jmsg, &msg);
+  resetGSSBuffer(env, jmsgToken, &msgToken);
 
+  /*
+   * We don't throw on supplementary status codes here, instead we pass only
+   * GSS_ERROR(major) to checkStatus() and set the supplementary status in the
+   * message properties.
+   */
   checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_verifyMic]");
   if ((*env)->ExceptionCheck(env)) {
     return;
@@ -1534,9 +1702,6 @@
 
   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
                        minor);
-  if ((*env)->ExceptionCheck(env)) {
-    return;
-  }
 }
 
 /*
@@ -1551,11 +1716,11 @@
                                                jbyteArray jmsg,
                                                jobject jprop)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   jboolean confFlag;
   gss_qop_t qop;
   gss_buffer_desc msg;
-  gss_buffer_desc msgToken;
+  gss_buffer_desc msgToken = GSS_C_EMPTY_BUFFER;
   int confState;
   gss_ctx_id_t contextHdl;
   jbyteArray jresult;
@@ -1582,7 +1747,7 @@
     return NULL;
   }
 
-  initGSSBuffer(env, jmsg, &msg);
+  initGSSBuffer(env, jmsg, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1593,13 +1758,16 @@
                    &msgToken);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msg);
-  jresult = getJavaBuffer(env, &msgToken);
+  resetGSSBuffer(env, jmsg, &msg);
+  checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
+
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msgToken);
     return NULL;
   }
 
-  checkStatus(env, jobj, major, minor, "[GSSLibStub_wrap]");
+  /* Map msgToken to byteArray result and release */
+  jresult = getJavaBuffer(env, &msgToken, JNI_TRUE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1607,7 +1775,8 @@
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
                          (confState? JNI_TRUE:JNI_FALSE));
   if ((*env)->ExceptionCheck(env)) {
-    return NULL;
+    (*env)->DeleteLocalRef(env, jresult);
+    jresult = NULL;
   }
   return jresult;
 }
@@ -1624,10 +1793,10 @@
                                                  jbyteArray jmsgToken,
                                                  jobject jprop)
 {
-  OM_uint32 minor, major;
+  OM_uint32 minor, major, dummy;
   gss_ctx_id_t contextHdl;
   gss_buffer_desc msgToken;
-  gss_buffer_desc msg;
+  gss_buffer_desc msg = GSS_C_EMPTY_BUFFER;
   int confState;
   gss_qop_t qop;
   jbyteArray jresult;
@@ -1642,7 +1811,7 @@
     return NULL;
   }
 
-  initGSSBuffer(env, jmsgToken, &msgToken);
+  initGSSBuffer(env, jmsgToken, &msgToken, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1656,13 +1825,24 @@
     (*ftab->unwrap)(&minor, contextHdl, &msgToken, &msg, &confState, &qop);
 
   /* release intermediate buffers */
-  resetGSSBuffer(&msgToken);
-  jresult = getJavaBuffer(env, &msg);
+  resetGSSBuffer(env, jmsgToken, &msgToken);
+
+  /*
+   * We don't throw on supplementary status codes here, instead we pass only
+   * GSS_ERROR(major) to checkStatus() and set the supplementary status in the
+   * message properties.
+   */
+  checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");
   if ((*env)->ExceptionCheck(env)) {
+    (void) (*ftab->releaseBuffer)(&dummy, &msg);
     return NULL;
   }
 
-  checkStatus(env, jobj, GSS_ERROR(major), minor, "[GSSLibStub_unwrap]");
+  /*
+   * Map msg to byteArray result and release, zero length msg maps to empty
+   * byte array, not null.
+   */
+  jresult = getJavaBuffer(env, &msg, JNI_FALSE);
   if ((*env)->ExceptionCheck(env)) {
     return NULL;
   }
@@ -1671,15 +1851,18 @@
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setPrivacy,
                          (confState != 0));
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
   (*env)->CallVoidMethod(env, jprop, MID_MessageProp_setQOP, qop);
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
   setSupplementaryInfo(env, jobj, jprop, GSS_SUPPLEMENTARY_INFO(major),
                          minor);
   if ((*env)->ExceptionCheck(env)) {
+    (*env)->DeleteLocalRef(env, jresult);
     return NULL;
   }
 
