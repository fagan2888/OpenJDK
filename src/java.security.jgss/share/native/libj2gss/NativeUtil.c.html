<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>ws New src/java.security.jgss/share/native/libj2gss/NativeUtil.c</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include "NativeUtil.h"
  27 #include "NativeFunc.h"
  28 #include "jlong.h"
  29 #include &lt;jni.h&gt;
  30 #include "jni_util.h"
  31 
  32 const int JAVA_DUPLICATE_TOKEN_CODE = 19; /* DUPLICATE_TOKEN */
  33 const int JAVA_OLD_TOKEN_CODE = 20; /* OLD_TOKEN */
  34 const int JAVA_UNSEQ_TOKEN_CODE = 21; /* UNSEQ_TOKEN */
  35 const int JAVA_GAP_TOKEN_CODE = 22; /* GAP_TOKEN */
  36 const int JAVA_ERROR_CODE[] = {
  37   2,  /* BAD_MECH */
  38   3,  /* BAD_NAME */
  39   4,  /* BAD_NAMETYPE */
  40   1,  /* BAD_BINDINGS */
  41   5,  /* BAD_STATUS */
  42   6,  /* BAD_MIC */
  43   13, /* NO_CRED */
  44   12, /* NO_CONTEXT */
  45   10, /* DEFECTIVE_TOKEN */
  46   9,  /* DEFECTIVE_CREDENTIAL */
  47   8,  /* CREDENTIAL_EXPIRED */
  48   7,  /* CONTEXT_EXPIRED */
  49   11, /* FAILURE */
  50   14, /* BAD_QOP */
  51   15, /* UNAUTHORIZED */
  52   16, /* UNAVAILABLE */
  53   17, /* DUPLICATE_ELEMENT */
  54   18, /* NAME_NOT_MN */
  55 };
  56 const char SPNEGO_BYTES[] = {
  57  0x2b, 0x06, 0x01, 0x05, 0x05, 0x02
  58 };
  59 
  60 jclass CLS_Object;
  61 jclass CLS_String;
  62 jclass CLS_Oid;
  63 jclass CLS_GSSException;
  64 jclass CLS_GSSNameElement;
  65 jclass CLS_GSSCredElement;
  66 jclass CLS_NativeGSSContext;
  67 jclass CLS_SunNativeProvider;
  68 jmethodID MID_String_ctor;
  69 jmethodID MID_Oid_ctor1;
  70 jmethodID MID_Oid_getDER;
  71 jmethodID MID_MessageProp_getPrivacy;
  72 jmethodID MID_MessageProp_getQOP;
  73 jmethodID MID_MessageProp_setPrivacy;
  74 jmethodID MID_MessageProp_setQOP;
  75 jmethodID MID_MessageProp_setSupplementaryStates;
  76 jmethodID MID_GSSException_ctor3;
  77 jmethodID MID_ChannelBinding_getInitiatorAddr;
  78 jmethodID MID_ChannelBinding_getAcceptorAddr;
  79 jmethodID MID_ChannelBinding_getAppData;
  80 jmethodID MID_InetAddress_getAddr;
  81 jmethodID MID_GSSNameElement_ctor;
  82 jmethodID MID_GSSCredElement_ctor;
  83 jmethodID MID_NativeGSSContext_ctor;
  84 jfieldID FID_GSSLibStub_pMech;
  85 jfieldID FID_NativeGSSContext_pContext;
  86 jfieldID FID_NativeGSSContext_srcName;
  87 jfieldID FID_NativeGSSContext_targetName;
  88 jfieldID FID_NativeGSSContext_isInitiator;
  89 jfieldID FID_NativeGSSContext_isEstablished;
  90 jfieldID FID_NativeGSSContext_delegatedCred;
  91 jfieldID FID_NativeGSSContext_flags;
  92 jfieldID FID_NativeGSSContext_lifetime;
  93 jfieldID FID_NativeGSSContext_actualMech;
  94 
  95 int JGSS_DEBUG;
  96 
  97 JNIEXPORT jint JNICALL
  98 DEF_JNI_OnLoad(JavaVM *jvm, void *reserved) {
  99   JNIEnv *env;
 100   jclass cls;
 101 
 102   if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_2)) {
 103     return JNI_EVERSION; /* JNI version not supported */
 104   }
 105   /* Retrieve and store the classes in global ref */
 106   cls = (*env)-&gt;FindClass(env, "java/lang/Object");
 107   if (cls == NULL) {
 108     printf("Couldn't find Object class\n");
 109     return JNI_ERR;
 110   }
 111   CLS_Object = (*env)-&gt;NewGlobalRef(env, cls);
 112   if (CLS_Object == NULL) {
 113     return JNI_ERR;
 114   }
 115   cls = (*env)-&gt;FindClass(env, "java/lang/String");
 116   if (cls == NULL) {
 117     printf("Couldn't find String class\n");
 118     return JNI_ERR;
 119   }
 120   CLS_String = (*env)-&gt;NewGlobalRef(env, cls);
 121   if (CLS_String == NULL) {
 122     return JNI_ERR;
 123   }
 124   cls = (*env)-&gt;FindClass(env, "org/ietf/jgss/Oid");
 125   if (cls == NULL) {
 126     printf("Couldn't find org.ietf.jgss.Oid class\n");
 127     return JNI_ERR;
 128   }
 129   CLS_Oid = (*env)-&gt;NewGlobalRef(env, cls);
 130   if (CLS_Oid == NULL) {
 131     return JNI_ERR;
 132   }
 133   cls = (*env)-&gt;FindClass(env, "org/ietf/jgss/GSSException");
 134   if (cls == NULL) {
 135     printf("Couldn't find org.ietf.jgss.GSSException class\n");
 136     return JNI_ERR;
 137   }
 138   CLS_GSSException = (*env)-&gt;NewGlobalRef(env, cls);
 139   if (CLS_GSSException == NULL) {
 140     return JNI_ERR;
 141   }
 142   cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/GSSNameElement");
 143   if (cls == NULL) {
 144     printf("Couldn't find sun.security.jgss.wrapper.GSSNameElement class\n");
 145     return JNI_ERR;
 146   }
 147   CLS_GSSNameElement = (*env)-&gt;NewGlobalRef(env, cls);
 148   if (CLS_GSSNameElement == NULL) {
 149     return JNI_ERR;
 150   }
 151   cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/GSSCredElement");
 152   if (cls == NULL) {
 153     printf("Couldn't find sun.security.jgss.wrapper.GSSCredElement class\n");
 154     return JNI_ERR;
 155   }
 156   CLS_GSSCredElement = (*env)-&gt;NewGlobalRef(env, cls);
 157   if (CLS_GSSCredElement == NULL) {
 158     return JNI_ERR;
 159   }
 160   cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/NativeGSSContext");
 161   if (cls == NULL) {
 162     printf("Couldn't find sun.security.jgss.wrapper.NativeGSSContext class\n");
 163     return JNI_ERR;
 164   }
 165   CLS_NativeGSSContext = (*env)-&gt;NewGlobalRef(env, cls);
 166   if (CLS_NativeGSSContext == NULL) {
 167     return JNI_ERR;
 168   }
 169   cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/SunNativeProvider");
 170   if (cls == NULL) {
 171     printf("Couldn't find sun.security.jgss.wrapper.SunNativeProvider class\n");
 172     return JNI_ERR;
 173   }
 174   CLS_SunNativeProvider = (*env)-&gt;NewGlobalRef(env, cls);
 175   if (CLS_SunNativeProvider == NULL) {
 176     return JNI_ERR;
 177   }
 178   /* Compute and cache the method ID */
 179   MID_String_ctor = (*env)-&gt;GetMethodID(env, CLS_String,
 180                                         "&lt;init&gt;", "([B)V");
 181   if (MID_String_ctor == NULL) {
 182     printf("Couldn't find String(byte[]) constructor\n");
 183     return JNI_ERR;
 184   }
 185   MID_Oid_ctor1 =
 186     (*env)-&gt;GetMethodID(env, CLS_Oid, "&lt;init&gt;", "([B)V");
 187   if (MID_Oid_ctor1 == NULL) {
 188     printf("Couldn't find Oid(byte[]) constructor\n");
 189     return JNI_ERR;
 190   }
 191   MID_Oid_getDER = (*env)-&gt;GetMethodID(env, CLS_Oid, "getDER", "()[B");
 192   if (MID_Oid_getDER == NULL) {
 193     printf("Couldn't find Oid.getDER() method\n");
 194     return JNI_ERR;
 195   }
 196   cls = (*env)-&gt;FindClass(env, "org/ietf/jgss/MessageProp");
 197   if (cls == NULL) {
 198     printf("Couldn't find org.ietf.jgss.MessageProp class\n");
 199     return JNI_ERR;
 200   }
 201   MID_MessageProp_getPrivacy =
 202     (*env)-&gt;GetMethodID(env, cls, "getPrivacy", "()Z");
 203   if (MID_MessageProp_getPrivacy == NULL) {
 204     printf("Couldn't find MessageProp.getPrivacy() method\n");
 205     return JNI_ERR;
 206   }
 207   MID_MessageProp_getQOP = (*env)-&gt;GetMethodID(env, cls, "getQOP", "()I");
 208   if (MID_MessageProp_getQOP == NULL) {
 209     printf("Couldn't find MessageProp.getQOP() method\n");
 210     return JNI_ERR;
 211   }
 212   MID_MessageProp_setPrivacy =
 213     (*env)-&gt;GetMethodID(env, cls, "setPrivacy", "(Z)V");
 214   if (MID_MessageProp_setPrivacy == NULL) {
 215     printf("Couldn't find MessageProp.setPrivacy(boolean) method\n");
 216     return JNI_ERR;
 217   }
 218   MID_MessageProp_setQOP = (*env)-&gt;GetMethodID(env, cls, "setQOP", "(I)V");
 219   if (MID_MessageProp_setQOP == NULL) {
 220     printf("Couldn't find MessageProp.setQOP(int) method\n");
 221     return JNI_ERR;
 222   }
 223   MID_MessageProp_setSupplementaryStates =
 224     (*env)-&gt;GetMethodID(env, cls, "setSupplementaryStates",
 225                         "(ZZZZILjava/lang/String;)V");
 226   if (MID_MessageProp_setSupplementaryStates == NULL) {
 227     printf("Couldn't find MessageProp.setSupplementaryStates(...) method\n");
 228     return JNI_ERR;
 229   }
 230   MID_GSSException_ctor3 = (*env)-&gt;GetMethodID
 231     (env, CLS_GSSException, "&lt;init&gt;", "(IILjava/lang/String;)V");
 232   if (MID_GSSException_ctor3 == NULL) {
 233     printf("Couldn't find GSSException(int, int, String) constructor\n");
 234     return JNI_ERR;
 235   }
 236   cls = (*env)-&gt;FindClass(env, "org/ietf/jgss/ChannelBinding");
 237   if (cls == NULL) {
 238     printf("Couldn't find org.ietf.jgss.ChannelBinding class\n");
 239     return JNI_ERR;
 240   }
 241   MID_ChannelBinding_getInitiatorAddr =
 242     (*env)-&gt;GetMethodID(env, cls, "getInitiatorAddress",
 243                         "()Ljava/net/InetAddress;");
 244   if (MID_ChannelBinding_getInitiatorAddr == NULL) {
 245     printf("Couldn't find ChannelBinding.getInitiatorAddress() method\n");
 246     return JNI_ERR;
 247   }
 248   MID_ChannelBinding_getAcceptorAddr =
 249     (*env)-&gt;GetMethodID(env, cls, "getAcceptorAddress",
 250                         "()Ljava/net/InetAddress;");
 251   if (MID_ChannelBinding_getAcceptorAddr == NULL) {
 252     printf("Couldn't find ChannelBinding.getAcceptorAddress() method\n");
 253     return JNI_ERR;
 254   }
 255   MID_ChannelBinding_getAppData =
 256     (*env)-&gt;GetMethodID(env, cls, "getApplicationData", "()[B");
 257   if (MID_ChannelBinding_getAppData == NULL) {
 258     printf("Couldn't find ChannelBinding.getApplicationData() method\n");
 259     return JNI_ERR;
 260   }
 261   cls = (*env)-&gt;FindClass(env, "java/net/InetAddress");
 262   if (cls == NULL) {
 263     printf("Couldn't find java.net.InetAddress class\n");
 264     return JNI_ERR;
 265   }
 266   MID_InetAddress_getAddr = (*env)-&gt;GetMethodID(env, cls, "getAddress",
 267                                                 "()[B");
 268   if (MID_InetAddress_getAddr == NULL) {
 269     printf("Couldn't find InetAddress.getAddress() method\n");
 270     return JNI_ERR;
 271   }
 272   MID_GSSNameElement_ctor =
 273     (*env)-&gt;GetMethodID(env, CLS_GSSNameElement,
 274                         "&lt;init&gt;", "(JLorg/ietf/jgss/Oid;Lsun/security/jgss/wrapper/GSSLibStub;)V");
 275   if (MID_GSSNameElement_ctor == NULL) {
 276     printf("Couldn't find GSSNameElement(long, Oid, GSSLibStub) constructor\n");
 277     return JNI_ERR;
 278   }
 279   MID_GSSCredElement_ctor =
 280     (*env)-&gt;GetMethodID(env, CLS_GSSCredElement, "&lt;init&gt;",
 281         "(JLsun/security/jgss/wrapper/GSSNameElement;Lorg/ietf/jgss/Oid;)V");
 282   if (MID_GSSCredElement_ctor == NULL) {
 283     printf("Couldn't find GSSCredElement(long, GSSLibStub) constructor\n");
 284     return JNI_ERR;
 285   }
 286   MID_NativeGSSContext_ctor =
 287     (*env)-&gt;GetMethodID(env, CLS_NativeGSSContext, "&lt;init&gt;",
 288                         "(JLsun/security/jgss/wrapper/GSSLibStub;)V");
 289   if (MID_NativeGSSContext_ctor == NULL) {
 290     printf("Couldn't find NativeGSSContext(long, GSSLibStub) constructor\n");
 291     return JNI_ERR;
 292   }
 293   /* Compute and cache the field ID */
 294   cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/GSSLibStub");
 295   if (cls == NULL) {
 296     printf("Couldn't find sun.security.jgss.wrapper.GSSLibStub class\n");
 297     return JNI_ERR;
 298   }
 299   FID_GSSLibStub_pMech =
 300     (*env)-&gt;GetFieldID(env, cls, "pMech", "J");
 301   if (FID_GSSLibStub_pMech == NULL) {
 302     printf("Couldn't find GSSLibStub.pMech field\n");
 303     return JNI_ERR;
 304   }
 305   FID_NativeGSSContext_pContext =
 306     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "pContext", "J");
 307   if (FID_NativeGSSContext_pContext == NULL) {
 308     printf("Couldn't find NativeGSSContext.pContext field\n");
 309     return JNI_ERR;
 310   }
 311   FID_NativeGSSContext_srcName =
 312     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "srcName",
 313                        "Lsun/security/jgss/wrapper/GSSNameElement;");
 314   if (FID_NativeGSSContext_srcName == NULL) {
 315     printf("Couldn't find NativeGSSContext.srcName field\n");
 316    return JNI_ERR;
 317   }
 318   FID_NativeGSSContext_targetName =
 319     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "targetName",
 320                        "Lsun/security/jgss/wrapper/GSSNameElement;");
 321   if (FID_NativeGSSContext_targetName == NULL) {
 322     printf("Couldn't find NativeGSSContext.targetName field\n");
 323     return JNI_ERR;
 324   }
 325   FID_NativeGSSContext_isInitiator =
 326     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "isInitiator", "Z");
 327   if (FID_NativeGSSContext_isInitiator == NULL) {
 328     printf("Couldn't find NativeGSSContext.isInitiator field\n");
 329     return JNI_ERR;
 330   }
 331   FID_NativeGSSContext_isEstablished =
 332     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "isEstablished", "Z");
 333   if (FID_NativeGSSContext_isEstablished == NULL) {
 334     printf("Couldn't find NativeGSSContext.isEstablished field\n");
 335     return JNI_ERR;
 336   }
 337   FID_NativeGSSContext_delegatedCred =
 338     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "delegatedCred",
 339                        "Lsun/security/jgss/wrapper/GSSCredElement;");
 340   if (FID_NativeGSSContext_delegatedCred == NULL) {
 341     printf("Couldn't find NativeGSSContext.delegatedCred field\n");
 342     return JNI_ERR;
 343   }
 344   FID_NativeGSSContext_flags =
 345     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "flags", "I");
 346   if (FID_NativeGSSContext_flags == NULL) {
 347     printf("Couldn't find NativeGSSContext.flags field\n");
 348     return JNI_ERR;
 349   }
 350   FID_NativeGSSContext_lifetime =
 351     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "lifetime", "I");
 352   if (FID_NativeGSSContext_lifetime == NULL) {
 353     printf("Couldn't find NativeGSSContext.lifetime field\n");
 354     return JNI_ERR;
 355   }
 356   FID_NativeGSSContext_actualMech =
 357     (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "actualMech",
 358                        "Lorg/ietf/jgss/Oid;");
 359   if (FID_NativeGSSContext_actualMech == NULL) {
 360     printf("Couldn't find NativeGSSContext.actualMech field\n");
 361     return JNI_ERR;
 362   }
 363   return JNI_VERSION_1_2;
 364 }
 365 
 366 JNIEXPORT void JNICALL
 367 DEF_JNI_OnUnload(JavaVM *jvm, void *reserved) {
 368   JNIEnv *env;
 369 
 370   if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_2)) {
 371     return;
 372   }
 373   /* Delete the global refs */
 374   (*env)-&gt;DeleteGlobalRef(env, CLS_Object);
 375   (*env)-&gt;DeleteGlobalRef(env, CLS_String);
 376   (*env)-&gt;DeleteGlobalRef(env, CLS_Oid);
 377   (*env)-&gt;DeleteGlobalRef(env, CLS_GSSException);
 378   (*env)-&gt;DeleteGlobalRef(env, CLS_GSSNameElement);
 379   (*env)-&gt;DeleteGlobalRef(env, CLS_GSSCredElement);
 380   (*env)-&gt;DeleteGlobalRef(env, CLS_SunNativeProvider);
 381   return;
 382 }
 383 
 384 const OM_uint32 JAVA_MAX = GSS_C_INDEFINITE/2;
 385 
 386 /*
 387  * Utility routine for converting the C unsigned integer time
 388  * to Java signed integer time.
 389  */
 390 jint getJavaTime(OM_uint32 ctime) {
 391   jint result;
 392 
 393   /* special handle values equals or more than JAVA_MAX */
 394   if (ctime == GSS_C_INDEFINITE) {
 395     result = JAVA_MAX;
 396   } else if (ctime &gt;= JAVA_MAX) {
 397     result = JAVA_MAX-1;
 398   } else {
 399     result = ctime;
 400   }
 401   return result;
 402 }
 403 /*
 404  * Utility routine for converting the Java signed integer time
 405  * to C unsigned integer time.
 406  */
 407 OM_uint32 getGSSTime(jint jtime) {
 408   OM_uint32 result;
 409 
 410   /* special handle values equal to JAVA_MAX */
 411   if (jtime == (jint)JAVA_MAX) {
 412     result = GSS_C_INDEFINITE;
 413   } else {
 414     result = jtime;
 415   }
 416   return result;
 417 }
 418 /*
 419  * Utility routine for mapping the C error code to the
 420  * Java one. The routine errors really should have
 421  * shared the same values but unfortunately don't.
 422  */
 423 jint getJavaErrorCode(int cNonCallingErr) {
 424   int cRoutineErr, cSuppStatus;
 425   /* map the routine errors */
 426   cRoutineErr = GSS_ROUTINE_ERROR(cNonCallingErr) &gt;&gt; 16;
 427   if (cRoutineErr != GSS_S_COMPLETE) {
 428     return JAVA_ERROR_CODE[cRoutineErr-1];
 429   }
 430   /* map the supplementary infos */
 431   cSuppStatus = GSS_SUPPLEMENTARY_INFO(cNonCallingErr);
 432   if (cSuppStatus &amp; GSS_S_DUPLICATE_TOKEN) {
 433     return JAVA_DUPLICATE_TOKEN_CODE;
 434   } else if (cSuppStatus &amp; GSS_S_OLD_TOKEN) {
 435     return JAVA_OLD_TOKEN_CODE;
 436   } else if (cSuppStatus &amp; GSS_S_UNSEQ_TOKEN) {
 437     return JAVA_UNSEQ_TOKEN_CODE;
 438   } else if (cSuppStatus &amp; GSS_S_GAP_TOKEN) {
 439     return JAVA_GAP_TOKEN_CODE;
 440   }
 441   return GSS_S_COMPLETE;
 442 }
 443 
 444 
 445 /* Throws a Java Exception by name */
 446 void throwByName(JNIEnv *env, const char *name, const char *msg) {
 447     jclass cls = (*env)-&gt;FindClass(env, name);
 448 
 449     if (cls != NULL) {
 450         (*env)-&gt;ThrowNew(env, cls, msg);
 451     }
 452 }
 453 
 454 void throwOutOfMemoryError(JNIEnv *env, const char *message) {
 455     throwByName(env, "java/lang/OutOfMemoryError", message);
 456 }
 457 
 458 static jsize
 459 safe_jsize(size_t n)
 460 {
 461     jsize res = (jsize)n;
 462 
 463     return (res &gt;= 0 &amp;&amp; (size_t)res == n) ? res : -1;
 464 }
 465 
 466 /*
 467  * Utility routine for creating a java.lang.String object
 468  * using the specified gss_buffer_t structure. The specified
 469  * gss_buffer_t structure is always released.
 470  */
 471 jstring getJavaString(JNIEnv *env, gss_buffer_t bytes) {
 472   jstring result = NULL;
 473   OM_uint32 minor;
 474   jsize len;
 475   jbyteArray jbytes;
 476 
 477   if (bytes == NULL) {
 478     return NULL;
 479   }
 480 
 481   /* constructs the String object with new String(byte[]) */
 482   if ((len = safe_jsize(bytes-&gt;length)) &lt; 0) {
 483     (*ftab-&gt;releaseBuffer)(&amp;minor, bytes);
 484     return NULL;
 485   }
 486   jbytes = (*env)-&gt;NewByteArray(env, len);
 487   if (jbytes == NULL) {
 488     (*ftab-&gt;releaseBuffer)(&amp;minor, bytes);
 489     return NULL;
 490   }
 491 
 492   (*env)-&gt;SetByteArrayRegion(env, jbytes, 0, len, (jbyte *) bytes-&gt;value);
 493   if ((*env)-&gt;ExceptionCheck(env) == JNI_FALSE) {
 494     result = (*env)-&gt;NewObject(env, CLS_String, MID_String_ctor,
 495                                jbytes);
 496   }
 497 
 498   (*env)-&gt;DeleteLocalRef(env, jbytes);
 499   (*ftab-&gt;releaseBuffer)(&amp;minor, bytes);
 500   return result;
 501 }
 502 /*
 503  * Utility routine for generate message for the specified minor
 504  * status code.
 505  */
 506 jstring getMinorMessage(JNIEnv *env, jobject jstub, OM_uint32 statusValue) {
 507   OM_uint32 messageContext, minor, major;
 508   gss_buffer_desc statusString;
 509   gss_OID mech;
 510 
 511   messageContext = 0;
 512   if (jstub != NULL) {
 513     mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jstub, FID_GSSLibStub_pMech));
 514   } else {
 515     mech = GSS_C_NO_OID;
 516   }
 517 
 518   /* gss_display_status(...) =&gt; GSS_S_BAD_MECH, GSS_S_BAD_STATUS */
 519   // TBD: check messageContext value and repeat the call if necessary
 520   major = (*ftab-&gt;displayStatus)(&amp;minor, statusValue, GSS_C_MECH_CODE, mech,
 521                                  &amp;messageContext, &amp;statusString);
 522 
 523   return getJavaString(env, &amp;statusString);
 524 }
 525 
 526 /*
 527  * Utility routine checking the specified major and minor
 528  * status codes. GSSExceptions will be thrown if they are
 529  * not GSS_S_COMPLETE (i.e. 0).
 530  */
 531 void checkStatus(JNIEnv *env, jobject jstub, OM_uint32 major,
 532                  OM_uint32 minor, const char *methodName) {
 533   int callingErr, routineErr, supplementaryInfo;
 534   jint jmajor, jminor;
 535   char* msg;
 536   jstring jmsg;
 537   jthrowable gssEx;
 538 
 539   if (major == GSS_S_COMPLETE) return;
 540 
 541   callingErr = GSS_CALLING_ERROR(major);
 542   routineErr = GSS_ROUTINE_ERROR(major);
 543   supplementaryInfo = GSS_SUPPLEMENTARY_INFO(major);
 544 
 545   TRACE3("%s Status major/minor = %x/%d", methodName, major, minor);
 546   TRACE3("c/r/s = %d/%d/%d ", callingErr&gt;&gt;24, routineErr&gt;&gt;16,
 547           supplementaryInfo);
 548 
 549   jmajor = getJavaErrorCode(routineErr | supplementaryInfo);
 550   jminor = minor;
 551   if (jmajor != GSS_S_COMPLETE) {
 552     jmsg = NULL;
 553     if (minor != 0) {
 554       jmsg = getMinorMessage(env, jstub, minor);
 555       if ((*env)-&gt;ExceptionCheck(env)) {
 556         return;
 557       }
 558     }
 559 
 560     gssEx = (*env)-&gt;NewObject(env, CLS_GSSException,
 561                               MID_GSSException_ctor3,
 562                               jmajor, jminor, jmsg);
 563     if (gssEx != NULL) {
 564       (*env)-&gt;Throw(env, gssEx);
 565     }
 566   } else {
 567     /* Error in calling the GSS api */
 568     if (callingErr == GSS_S_CALL_INACCESSIBLE_READ) {
 569       msg = "A required input parameter cannot be read";
 570     } else if (callingErr == GSS_S_CALL_INACCESSIBLE_WRITE) {
 571       msg = "A required output parameter cannot be write";
 572     } else {
 573       msg = "A parameter was malformed";
 574     }
 575     jmajor = 13; /* use GSSException.FAILURE for now */
 576     jmsg = (*env)-&gt;NewStringUTF(env, msg);
 577     if (jmsg == NULL) {
 578       return;
 579     }
 580     gssEx = (*env)-&gt;NewObject(env, CLS_GSSException,
 581                               MID_GSSException_ctor3,
 582                               jmajor, jminor, jmsg);
 583     if (gssEx != NULL) {
 584       (*env)-&gt;Throw(env, gssEx);
 585     }
 586   }
 587 }
 588 
 589 /*
 590  * Utility routine for initializing gss_buffer_t structure
 591  * with the byte[] in the specified jbyteArray object.
 592  * NOTE: must call resetGSSBuffer() to free up the resources
 593  */
 594 void initGSSBuffer(JNIEnv *env, jbyteArray jbytes,
 595                      gss_buffer_t cbytes, jboolean wantCopy)
 596 {
 597   jboolean isCopy;
 598   jint len;
 599   void* value;
 600 
 601   cbytes-&gt;length = 0;
 602   cbytes-&gt;value = NULL;
 603 
 604   if (jbytes == NULL ||
 605       (len = (*env)-&gt;GetArrayLength(env, jbytes)) == 0)
 606     return;
 607 
 608   cbytes-&gt;length = len;
 609 
 610   if (wantCopy == JNI_FALSE) {
 611     cbytes-&gt;value = (*env)-&gt;GetByteArrayElements(env, jbytes, &amp;isCopy);
 612     if (cbytes-&gt;value == NULL) {
 613       throwOutOfMemoryError(env, NULL);
 614     }
 615     return;
 616   }
 617 
 618   value = malloc(len);
 619   if (value == NULL) {
 620     throwOutOfMemoryError(env, NULL);
 621     return;
 622   }
 623 
 624   (*env)-&gt;GetByteArrayRegion(env, jbytes, 0, len, value);
 625   if ((*env)-&gt;ExceptionCheck(env)) {
 626     free(value);
 627     return;
 628   }
 629   cbytes-&gt;value = value;
 630 }
 631 
 632 /*
 633  * Utility routine for freeing the buffer obtained via initGSSBuffer().
 634  * If jbytes is null this is a malloced copy.
 635  */
 636 void resetGSSBuffer(JNIEnv *env, jbyteArray jbytes, gss_buffer_t cbytes)
 637 {
 638   if (cbytes-&gt;value == NULL)
 639     return;
 640   if (jbytes != NULL) {
 641     (*env)-&gt;ReleaseByteArrayElements(env, jbytes, cbytes-&gt;value, JNI_ABORT);
 642   } else if (cbytes-&gt;length &gt; 0) {
 643     free(cbytes-&gt;value);
 644     cbytes-&gt;value = NULL;
 645     cbytes-&gt;length = 0;
 646   }
 647 }
 648 
 649 /*
 650  * Utility routine for initializing gss_buffer_t structure
 651  * with a String.
 652  * NOTE: need to call resetGSSBufferString(...) to free up
 653  * the resources.
 654  */
 655 void initGSSBufferString(JNIEnv* env, jstring jstr, gss_buffer_t buf)
 656 {
 657   const char *s;
 658 
 659   buf-&gt;length = 0;
 660   buf-&gt;value = NULL;
 661   if (jstr != NULL) {
 662     s = (*env)-&gt;GetStringUTFChars(env, jstr, NULL);
 663     if (s == NULL) {
 664       throwOutOfMemoryError(env, NULL);
 665     } else {
 666       buf-&gt;length = strlen(s);
 667       buf-&gt;value = (char *)s; /* Drop const */
 668     }
 669   }
 670 }
 671 
 672 /*
 673  * Utility routine for unpinning/releasing the String
 674  * associated with the specified jstring object.
 675  * NOTE: used in conjunction with initGSSBufferString(...).
 676  */
 677 void resetGSSBufferString(JNIEnv *env, jstring jstr, gss_buffer_t buf)
 678 {
 679   if (jstr != NULL &amp;&amp; buf-&gt;value != NULL)
 680     (*env)-&gt;ReleaseStringUTFChars(env, jstr, buf-&gt;value);
 681 }
 682 
 683 void initGSSCredStore(JNIEnv *env, jarray jstore,
 684                       gss_key_value_set_desc *store) {
 685   jsize nelements = 0;
 686   jsize n, i, k;
 687 
 688   store-&gt;count = 0;
 689   store-&gt;elements = NULL;
 690   if (jstore == NULL) {
 691     return;
 692   }
 693   n = (*env)-&gt;GetArrayLength(env, jstore);
 694   for (i = 0; i &lt; n; i += 2) {
 695     jobject jkey = (*env)-&gt;GetObjectArrayElement(env, jstore, i);
 696     jobject jval = (*env)-&gt;GetObjectArrayElement(env, jstore, i + 1);
 697     
 698     if (!jkey || !jval) {
 699       break;
 700     }
 701     if (!(*env)-&gt;IsInstanceOf(env, jkey, CLS_String) ||
 702         !(*env)-&gt;IsInstanceOf(env, jval, CLS_String)) {
 703       throwByName(env, "java/lang/IllegalArgumentException",
 704                   "invalid GSS credential store element type; must be String");
 705       store-&gt;count = 0;
 706       return;
 707     }
 708     store-&gt;count += 1;
 709     nelements += 2;
 710   }
 711   if (nelements &lt; 0 || nelements &gt; INT32_MAX) {
 712     throwOutOfMemoryError(env,NULL);
 713     store-&gt;count = 0;
 714     return;
 715   }
 716   store-&gt;elements = calloc(store-&gt;count, sizeof(store-&gt;elements[0]));
 717   if (store-&gt;elements == NULL) {
 718     throwOutOfMemoryError(env,NULL);
 719     store-&gt;count = 0;
 720     return;
 721   }
 722   for (i = 0, k = 0; i &lt; nelements; i += 2, k++) {
 723     jobject jkey = (*env)-&gt;GetObjectArrayElement(env, jstore, i);
 724     jobject jval = (*env)-&gt;GetObjectArrayElement(env, jstore, i + 1);
 725     store-&gt;elements[k].key = (*env)-&gt;GetStringUTFChars(env, jkey, NULL);
 726     store-&gt;elements[k].value = (*env)-&gt;GetStringUTFChars(env, jval, NULL);
 727     TRACE2("[GSSLibStub initGSSCredStore] element %ld key %s",
 728            (long)k, store-&gt;elements[k].key);
 729     TRACE2("[GSSLibStub initGSSCredStore] element %ld value %s",
 730            (long)k, store-&gt;elements[k].value);
 731   }
 732 }
 733 
 734 void resetGSSCredStore(JNIEnv *env,
 735                        jarray jstore,
 736                        gss_key_value_set_desc *store) {
 737   jobject jstr;
 738   jsize i;
 739 
 740   for (i = 0; i &lt; (jsize)store-&gt;count; i++) {
 741     jstr = (*env)-&gt;GetObjectArrayElement(env, jstore, i);
 742     if (!(i &amp; 0x01)) {
 743       (*env)-&gt;ReleaseStringUTFChars(env, jstr, store-&gt;elements[i].key);
 744     } else {
 745       (*env)-&gt;ReleaseStringUTFChars(env, jstr, store-&gt;elements[i].value);
 746     }
 747   }
 748   free(store-&gt;elements);
 749   store-&gt;elements = NULL;
 750   store-&gt;count = 0;
 751 }
 752 
 753 
 754 /*
 755  * Utility routine for creating a jbyteArray object using
 756  * the byte[] value in specified gss_buffer_t structure.
 757  * NOTE: the specified gss_buffer_t structure is always
 758  * released.
 759  */
 760 jbyteArray getJavaBuffer(JNIEnv *env, gss_buffer_t cbytes, jboolean isToken) {
 761   jbyteArray result = NULL;
 762   OM_uint32 dummy;
 763 
 764   /*
 765    * Zero length tokens map to NULL outputs, but otherwise to a zero-length
 766    * Java byte array.
 767    */
 768   if (cbytes != GSS_C_NO_BUFFER &amp;&amp;
 769       (isToken == JNI_FALSE || cbytes-&gt;length &gt; 0)) {
 770     jsize len = safe_jsize(cbytes-&gt;length);
 771 
 772     if (len &gt;= 0) {
 773       result = (*env)-&gt;NewByteArray(env, len);
 774     }
 775     if (result != NULL) {
 776       (*env)-&gt;SetByteArrayRegion(env, result, 0, len,
 777                                  cbytes-&gt;value);
 778       if ((*env)-&gt;ExceptionCheck(env)) {
 779         (*env)-&gt;DeleteLocalRef(env, result);
 780         result = NULL;
 781       }
 782     }
 783   }
 784   (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, cbytes);
 785   return result;
 786 }
 787 
 788 /*
 789  * Utility routine for creating a non-mech gss_OID using
 790  * the specified org.ietf.jgss.Oid object.
 791  * NOTE: must call deleteGSSOID(...) to free up the gss_OID.
 792  */
 793 gss_OID newGSSOID(JNIEnv *env, jobject jOid) {
 794   jbyteArray jbytes;
 795   gss_OID cOid;
 796   if (jOid != NULL) {
 797     jbytes = (*env)-&gt;CallObjectMethod(env, jOid, MID_Oid_getDER);
 798     if ((*env)-&gt;ExceptionCheck(env)) {
 799       return GSS_C_NO_OID;
 800     }
 801     cOid = malloc(sizeof(struct gss_OID_desc_struct));
 802     if (cOid == NULL) {
 803       throwOutOfMemoryError(env,NULL);
 804       return GSS_C_NO_OID;
 805     }
 806     cOid-&gt;length = (*env)-&gt;GetArrayLength(env, jbytes) - 2;
 807     cOid-&gt;elements = malloc(cOid-&gt;length);
 808     if (cOid-&gt;elements == NULL) {
 809       throwOutOfMemoryError(env,NULL);
 810       goto cleanup;
 811     }
 812     (*env)-&gt;GetByteArrayRegion(env, jbytes, 2, cOid-&gt;length,
 813                                cOid-&gt;elements);
 814     if ((*env)-&gt;ExceptionCheck(env)) {
 815       goto cleanup;
 816     }
 817     return cOid;
 818   } else {
 819     return GSS_C_NO_OID;
 820   }
 821   cleanup:
 822     (*env)-&gt;DeleteLocalRef(env, jbytes);
 823     free(cOid-&gt;elements);
 824     free(cOid);
 825     return GSS_C_NO_OID;
 826 }
 827 
 828 /*
 829  * Utility routine for releasing the specified gss_OID
 830  * structure.
 831  * NOTE: used in conjunction with newGSSOID(...).
 832  */
 833 void deleteGSSOID(gss_OID oid) {
 834   if (oid != GSS_C_NO_OID) {
 835     free(oid-&gt;elements);
 836     free(oid);
 837   }
 838 }
 839 
 840 /*
 841  * Utility routine for creating a org.ietf.jgss.Oid
 842  * object using the specified gss_OID structure.
 843  */
 844 jobject getJavaOID(JNIEnv *env, gss_OID cOid) {
 845   int cLen;
 846   char oidHdr[2];
 847   jbyteArray jbytes;
 848   jobject result = NULL;
 849 
 850   if ((cOid == NULL) || (cOid == GSS_C_NO_OID)) {
 851     return NULL;
 852   }
 853   cLen = cOid-&gt;length;
 854   oidHdr[0] = 6;
 855   oidHdr[1] = cLen;
 856   jbytes = (*env)-&gt;NewByteArray(env, cLen+2);
 857   if (jbytes == NULL) {
 858     return NULL;
 859   }
 860   if (!(*env)-&gt;ExceptionCheck(env)) {
 861     (*env)-&gt;SetByteArrayRegion(env, jbytes, 0, 2, (jbyte *) oidHdr);
 862   }
 863   if (!(*env)-&gt;ExceptionCheck(env)) {
 864     (*env)-&gt;SetByteArrayRegion(env, jbytes, 2, cLen, (jbyte *) cOid-&gt;elements);
 865   }
 866   if (!(*env)-&gt;ExceptionCheck(env)) {
 867     result = (*env)-&gt;NewObject(env, CLS_Oid, MID_Oid_ctor1, jbytes);
 868   }
 869   (*env)-&gt;DeleteLocalRef(env, jbytes);
 870   return result;
 871 }
 872 /*
 873  * Utility routine for filling in a 1-element gss_OID_set structure using the
 874  * specified gss_OID (storage owned by caller).  However, with SPNEGO we return
 875  * a static set containing all the available mechanisms.
 876  */
 877 gss_OID_set makeGSSOIDSet(gss_OID_set mechs, gss_OID oid) {
 878   if (oid-&gt;length != 6 || memcmp(oid-&gt;elements, SPNEGO_BYTES, 6) != 0) {
 879       mechs-&gt;count = 1;
 880       mechs-&gt;elements = oid;
 881       return mechs;
 882   }
 883   /* Use all mechs for SPNEGO in order to work with various native GSS impls */
 884   return (ftab-&gt;mechs);
 885 }
 886 /*
 887  * Utility routine for creating a org.ietf.jgss.Oid[]
 888  * using the specified gss_OID_set structure.
 889  */
 890 jobjectArray getJavaOIDArray(JNIEnv *env, gss_OID_set cOidSet) {
 891   jsize numOfOids = 0;
 892   jobjectArray jOidSet;
 893   jobject jOid;
 894   jsize i;
 895 
 896   if (cOidSet != NULL &amp;&amp; cOidSet != GSS_C_NO_OID_SET) {
 897     numOfOids = safe_jsize(cOidSet-&gt;count);
 898     if (numOfOids &lt; 0) {
 899       return NULL;
 900     }
 901     jOidSet = (*env)-&gt;NewObjectArray(env, numOfOids, CLS_Oid, NULL);
 902     if ((*env)-&gt;ExceptionCheck(env)) {
 903       return NULL;
 904     }
 905     for (i = 0; i &lt; numOfOids; i++) {
 906       jOid = getJavaOID(env, &amp;(cOidSet-&gt;elements[i]));
 907       if ((*env)-&gt;ExceptionCheck(env)) {
 908         return NULL;
 909       }
 910       (*env)-&gt;SetObjectArrayElement(env, jOidSet, i, jOid);
 911       if ((*env)-&gt;ExceptionCheck(env)) {
 912         return NULL;
 913       }
 914       (*env)-&gt;DeleteLocalRef(env, jOid);
 915     }
 916     return jOidSet;
 917   }
 918   return NULL;
 919 }
 920 
 921 int sameMech(gss_OID mech, gss_OID mech2) {
 922   int result = JNI_FALSE; // default to not equal
 923 
 924   if (mech-&gt;length == mech2-&gt;length) {
 925     result = (memcmp(mech-&gt;elements, mech2-&gt;elements, mech-&gt;length) == 0);
 926   }
 927   return result;
 928 }
</pre></body></html>
