<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>ws Wdiff src/java.security.jgss/share/native/libj2gss/NativeUtil.c</title>

    <meta http-equiv="cache-control" content="no-cache" />

    <style type='text/css' media='screen'>
      pre	{ margin: 2px; }

      body	{ background-color: #eeeeee; }

      hr	{ border: none 0; border-top: 1px solid #aaa; height: 1px; }

      .subtracted { color: brown }
      .added	{ color: blue }

      .elided	{ border: 1px solid #444; cursor: pointer; margin: 1px }

      table.hidebar { border: 1px solid #ff9900; background-color: #eee;
      		  text-align: center; border-collapse: collapse; }

      .hidebar td.active-down { border: 1px solid #ff9900;
		border-right: 1px solid #ccc; cursor: s-resize }

      .hidebar td.active-down:hover { background-color: #ffcc99; }

      .hidebar td.active-up { border: 1px solid #ff9900; cursor: n-resize;
		border-left: 1px solid #ccc; }

      .hidebar td.active-up:hover { background-color: #ffcc99; }

      .hidebar td.elided-label { font-style: italic; width: 12em; }

      .cmdbox	{ position: fixed; top: 0; right: 0;
	          border-left: solid 1px #444;
	          border-bottom: solid 1px #444;
      		  background-color: #ccc; text-align: center }

      .cmdbox td { background-color: #eee; border: 1px #444 outset;
		   cursor: pointer; padding: 3px 4px; }
      .cmdbox td:hover { background-color: #ffcc99;
 		outline: thin solid #ff9900; }

      a:hover { background-color: #ffcc99; }

      a.print { font-size: x-small; }
    </style>

    <style type='text/css' media='print'>
	pre { font-family: courier, monospace; font-size: 0.8em; }
	.cmdbox { display: none; }
        a.print { display: none; }
	.hidebar td.active-down { display: none; }
	.hidebar td.active-up { display: none; }
        .hidebar td.elided-label { font-style: italic; font-size: small; }
	table.hidebar { border: none; border-bottom: 1px dotted #000000; }
	span.added { font-weight: bold;
	         background-color: #eee; width: 100%; display: block; }
	span.subtracted { font-style: italic;
		 background-color: #eee; width: 100%; display: block; }
	.elided { display: none; }
        hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
    </style>

    <script type="text/javascript">
      function show_n_hide_dir(id_to_show, id_to_hide, dir) {
	      var elt_to_show = document.getElementById(id_to_show);
	      var elt_to_hide = document.getElementById(id_to_hide);
	      // When we're opening up, we need to make the bottoms of the
	      // elements appear to be the same.  So our invariant should be
	      // elt.offsetBottom - window.scrollY.
	      var preinvar = elt_to_hide.offsetHeight - window.scrollY;
	      elt_to_show.style.setProperty('display', '', '');
	      elt_to_hide.style.setProperty('display', 'none', '');
	      if (dir == 'up') {
		      var postinvar = elt_to_show.offsetHeight - window.scrollY;
		      window.scrollBy(0, postinvar - preinvar);
	      }
      }

      function handle_click(e) {
	      var eh = e.target;
	      var es = document.getElementById("hb-" + e.target.id);
	      eh.style.setProperty('display', 'none', '');
	      es.style.setProperty('display', '', '');
	      /* Scroll so new element is at cursor. */
	      window.scroll(0, es.offsetTop + (es.offsetHeight / 2)
	          - e.clientY);
      }

      function stripsearch(str) {
	q = str.indexOf("?");
	if (q != -1)
	  str = str.substr(0, q);
	return (str);
      }

      function split() {
        page = stripsearch(location.href);
	halfway = window.scrollY + window.innerHeight / 2 - 5;
	document.write('<frameset rows="50%,*">' +
	  '<frame src="' + page + "?" + window.scrollY + '" />' +
	  '<frame src="' + page + "?" + halfway + '" />' +
	  '</frameset>');
	document.close();
      }

      function closeframe() {
	page = stripsearch(location.href);

	otherf = window.parent.frames[0];
	if (otherf == window)
	  otherf = window.parent.frames[1];

	parent.location.replace(page + "?" + otherf.scrollY);
      }
    </script>
  </head>
  <body id='SUNWwebrev'>
    <a class="print" href="javascript:print()">Print this page</a>
    <pre>
Add JGSS JNI bindings for gss cred store functions
Add createCredential() with password
Also avoid memory allocation in newGSSOIDSet() renamed to makeGSSOIDset()
which now takes a singleton set argument and either assigns the requested
OID or with SPNEGO returns a static list of all the supported mechs. With
this we no longer need deleteGSSOIDSet().
Add actual mechanism to native GSSNameElement state
Revert initGSSBuffer to JDK7 non-copy behaviour
Implement String to gss_buffer_t import
Fix error handling in GSSLibStub
Also improve object size handling in NativeUtil.
</pre>
<hr />
    <table class='cmdbox'>
      <tr>
        <td onclick='split()'>Split</td>
	<td id='close' onclick='closeframe()'>Close</td>
      </tr>
      <tr><td colspan="2" onclick='open_or_close_all(1)'>Expand all</td></tr>
      <tr><td colspan="2" onclick='open_or_close_all(0)'>Collapse all</td></tr>
    </table>

    <script type='text/javascript'>
      if (window == top)
        document.getElementById('close').style.setProperty('display', 'none', '');
    </script>
<pre><span class='subtracted'>          --- old/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
</span><span class='added'>          +++ new/src/java.security.jgss/share/native/libj2gss/NativeUtil.c
</span></pre>
<pre id='elided1' class='elided' style='display: none'>   1    1  /*
   2    2   * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
   3    3   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4    4   *
   5    5   * This code is free software; you can redistribute it and/or modify it
   6    6   * under the terms of the GNU General Public License version 2 only, as
   7    7   * published by the Free Software Foundation.  Oracle designates this
   8    8   * particular file as subject to the "Classpath" exception as provided
   9    9   * by Oracle in the LICENSE file that accompanied this code.
  10   10   *
  11   11   * This code is distributed in the hope that it will be useful, but WITHOUT
  12   12   * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13   13   * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14   14   * version 2 for more details (a copy is included in the LICENSE file that
  15   15   * accompanied this code).
  16   16   *
  17   17   * You should have received a copy of the GNU General Public License version
  18   18   * 2 along with this work; if not, write to the Free Software Foundation,
  19   19   * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20   20   *
  21   21   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22   22   * or visit www.oracle.com if you need additional information or have any
  23   23   * questions.
  24   24   */
  25   25  
  26   26  #include "NativeUtil.h"
  27   27  #include "NativeFunc.h"
  28   28  #include "jlong.h"
  29   29  #include &lt;jni.h&gt;
  30   30  #include "jni_util.h"
  31   31  
  32   32  const int JAVA_DUPLICATE_TOKEN_CODE = 19; /* DUPLICATE_TOKEN */
  33   33  const int JAVA_OLD_TOKEN_CODE = 20; /* OLD_TOKEN */
  34   34  const int JAVA_UNSEQ_TOKEN_CODE = 21; /* UNSEQ_TOKEN */
  35   35  const int JAVA_GAP_TOKEN_CODE = 22; /* GAP_TOKEN */
  36   36  const int JAVA_ERROR_CODE[] = {
  37   37    2,  /* BAD_MECH */
  38   38    3,  /* BAD_NAME */
  39   39    4,  /* BAD_NAMETYPE */
  40   40    1,  /* BAD_BINDINGS */
  41   41    5,  /* BAD_STATUS */
  42   42    6,  /* BAD_MIC */
  43   43    13, /* NO_CRED */
  44   44    12, /* NO_CONTEXT */
  45   45    10, /* DEFECTIVE_TOKEN */
  46   46    9,  /* DEFECTIVE_CREDENTIAL */
  47   47    8,  /* CREDENTIAL_EXPIRED */
  48   48    7,  /* CONTEXT_EXPIRED */
  49   49    11, /* FAILURE */
  50   50    14, /* BAD_QOP */
  51   51    15, /* UNAUTHORIZED */
  52   52    16, /* UNAVAILABLE */
  53   53    17, /* DUPLICATE_ELEMENT */
  54   54    18, /* NAME_NOT_MN */
  55   55  };
  56   56  const char SPNEGO_BYTES[] = {
  57   57   0x2b, 0x06, 0x01, 0x05, 0x05, 0x02
  58   58  };
  59   59  
  60   60  jclass CLS_Object;
  61   61  jclass CLS_String;
  62   62  jclass CLS_Oid;
  63   63  jclass CLS_GSSException;
  64   64  jclass CLS_GSSNameElement;
  65   65  jclass CLS_GSSCredElement;
  66   66  jclass CLS_NativeGSSContext;
  67   67  jclass CLS_SunNativeProvider;
  68   68  jmethodID MID_String_ctor;
  69   69  jmethodID MID_Oid_ctor1;
  70   70  jmethodID MID_Oid_getDER;
  71   71  jmethodID MID_MessageProp_getPrivacy;
  72   72  jmethodID MID_MessageProp_getQOP;
  73   73  jmethodID MID_MessageProp_setPrivacy;
  74   74  jmethodID MID_MessageProp_setQOP;
  75   75  jmethodID MID_MessageProp_setSupplementaryStates;
  76   76  jmethodID MID_GSSException_ctor3;
  77   77  jmethodID MID_ChannelBinding_getInitiatorAddr;
  78   78  jmethodID MID_ChannelBinding_getAcceptorAddr;
  79   79  jmethodID MID_ChannelBinding_getAppData;
  80   80  jmethodID MID_InetAddress_getAddr;
  81   81  jmethodID MID_GSSNameElement_ctor;
  82   82  jmethodID MID_GSSCredElement_ctor;
  83   83  jmethodID MID_NativeGSSContext_ctor;
  84   84  jfieldID FID_GSSLibStub_pMech;
  85   85  jfieldID FID_NativeGSSContext_pContext;
  86   86  jfieldID FID_NativeGSSContext_srcName;
  87   87  jfieldID FID_NativeGSSContext_targetName;
  88   88  jfieldID FID_NativeGSSContext_isInitiator;
  89   89  jfieldID FID_NativeGSSContext_isEstablished;
  90   90  jfieldID FID_NativeGSSContext_delegatedCred;
  91   91  jfieldID FID_NativeGSSContext_flags;
  92   92  jfieldID FID_NativeGSSContext_lifetime;
  93   93  jfieldID FID_NativeGSSContext_actualMech;
  94   94  
  95   95  int JGSS_DEBUG;
  96   96  
  97   97  JNIEXPORT jint JNICALL
  98   98  DEF_JNI_OnLoad(JavaVM *jvm, void *reserved) {
  99   99    JNIEnv *env;
 100  100    jclass cls;
 101  101  
 102  102    if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_2)) {
 103  103      return JNI_EVERSION; /* JNI version not supported */
 104  104    }
 105  105    /* Retrieve and store the classes in global ref */
 106  106    cls = (*env)-&gt;FindClass(env, "java/lang/Object");
 107  107    if (cls == NULL) {
 108  108      printf("Couldn't find Object class\n");
 109  109      return JNI_ERR;
 110  110    }
 111  111    CLS_Object = (*env)-&gt;NewGlobalRef(env, cls);
 112  112    if (CLS_Object == NULL) {
 113  113      return JNI_ERR;
 114  114    }
 115  115    cls = (*env)-&gt;FindClass(env, "java/lang/String");
 116  116    if (cls == NULL) {
 117  117      printf("Couldn't find String class\n");
 118  118      return JNI_ERR;
 119  119    }
 120  120    CLS_String = (*env)-&gt;NewGlobalRef(env, cls);
 121  121    if (CLS_String == NULL) {
 122  122      return JNI_ERR;
 123  123    }
 124  124    cls = (*env)-&gt;FindClass(env, "org/ietf/jgss/Oid");
 125  125    if (cls == NULL) {
 126  126      printf("Couldn't find org.ietf.jgss.Oid class\n");
 127  127      return JNI_ERR;
 128  128    }
 129  129    CLS_Oid = (*env)-&gt;NewGlobalRef(env, cls);
 130  130    if (CLS_Oid == NULL) {
 131  131      return JNI_ERR;
 132  132    }
 133  133    cls = (*env)-&gt;FindClass(env, "org/ietf/jgss/GSSException");
 134  134    if (cls == NULL) {
 135  135      printf("Couldn't find org.ietf.jgss.GSSException class\n");
 136  136      return JNI_ERR;
 137  137    }
 138  138    CLS_GSSException = (*env)-&gt;NewGlobalRef(env, cls);
 139  139    if (CLS_GSSException == NULL) {
 140  140      return JNI_ERR;
 141  141    }
 142  142    cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/GSSNameElement");
 143  143    if (cls == NULL) {
 144  144      printf("Couldn't find sun.security.jgss.wrapper.GSSNameElement class\n");
 145  145      return JNI_ERR;
 146  146    }
 147  147    CLS_GSSNameElement = (*env)-&gt;NewGlobalRef(env, cls);
 148  148    if (CLS_GSSNameElement == NULL) {
 149  149      return JNI_ERR;
 150  150    }
 151  151    cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/GSSCredElement");
 152  152    if (cls == NULL) {
 153  153      printf("Couldn't find sun.security.jgss.wrapper.GSSCredElement class\n");
 154  154      return JNI_ERR;
 155  155    }
 156  156    CLS_GSSCredElement = (*env)-&gt;NewGlobalRef(env, cls);
 157  157    if (CLS_GSSCredElement == NULL) {
 158  158      return JNI_ERR;
 159  159    }
 160  160    cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/NativeGSSContext");
 161  161    if (cls == NULL) {
 162  162      printf("Couldn't find sun.security.jgss.wrapper.NativeGSSContext class\n");
 163  163      return JNI_ERR;
 164  164    }
 165  165    CLS_NativeGSSContext = (*env)-&gt;NewGlobalRef(env, cls);
 166  166    if (CLS_NativeGSSContext == NULL) {
 167  167      return JNI_ERR;
 168  168    }
 169  169    cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/SunNativeProvider");
 170  170    if (cls == NULL) {
 171  171      printf("Couldn't find sun.security.jgss.wrapper.SunNativeProvider class\n");
 172  172      return JNI_ERR;
 173  173    }
 174  174    CLS_SunNativeProvider = (*env)-&gt;NewGlobalRef(env, cls);
 175  175    if (CLS_SunNativeProvider == NULL) {
 176  176      return JNI_ERR;
 177  177    }
 178  178    /* Compute and cache the method ID */
 179  179    MID_String_ctor = (*env)-&gt;GetMethodID(env, CLS_String,
 180  180                                          "&lt;init&gt;", "([B)V");
 181  181    if (MID_String_ctor == NULL) {
 182  182      printf("Couldn't find String(byte[]) constructor\n");
 183  183      return JNI_ERR;
 184  184    }
 185  185    MID_Oid_ctor1 =
 186  186      (*env)-&gt;GetMethodID(env, CLS_Oid, "&lt;init&gt;", "([B)V");
 187  187    if (MID_Oid_ctor1 == NULL) {
 188  188      printf("Couldn't find Oid(byte[]) constructor\n");
 189  189      return JNI_ERR;
 190  190    }
 191  191    MID_Oid_getDER = (*env)-&gt;GetMethodID(env, CLS_Oid, "getDER", "()[B");
 192  192    if (MID_Oid_getDER == NULL) {
 193  193      printf("Couldn't find Oid.getDER() method\n");
 194  194      return JNI_ERR;
 195  195    }
 196  196    cls = (*env)-&gt;FindClass(env, "org/ietf/jgss/MessageProp");
 197  197    if (cls == NULL) {
 198  198      printf("Couldn't find org.ietf.jgss.MessageProp class\n");
 199  199      return JNI_ERR;
 200  200    }
 201  201    MID_MessageProp_getPrivacy =
 202  202      (*env)-&gt;GetMethodID(env, cls, "getPrivacy", "()Z");
 203  203    if (MID_MessageProp_getPrivacy == NULL) {
 204  204      printf("Couldn't find MessageProp.getPrivacy() method\n");
 205  205      return JNI_ERR;
 206  206    }
 207  207    MID_MessageProp_getQOP = (*env)-&gt;GetMethodID(env, cls, "getQOP", "()I");
 208  208    if (MID_MessageProp_getQOP == NULL) {
 209  209      printf("Couldn't find MessageProp.getQOP() method\n");
 210  210      return JNI_ERR;
 211  211    }
 212  212    MID_MessageProp_setPrivacy =
 213  213      (*env)-&gt;GetMethodID(env, cls, "setPrivacy", "(Z)V");
 214  214    if (MID_MessageProp_setPrivacy == NULL) {
 215  215      printf("Couldn't find MessageProp.setPrivacy(boolean) method\n");
 216  216      return JNI_ERR;
 217  217    }
 218  218    MID_MessageProp_setQOP = (*env)-&gt;GetMethodID(env, cls, "setQOP", "(I)V");
 219  219    if (MID_MessageProp_setQOP == NULL) {
 220  220      printf("Couldn't find MessageProp.setQOP(int) method\n");
 221  221      return JNI_ERR;
 222  222    }
 223  223    MID_MessageProp_setSupplementaryStates =
 224  224      (*env)-&gt;GetMethodID(env, cls, "setSupplementaryStates",
 225  225                          "(ZZZZILjava/lang/String;)V");
 226  226    if (MID_MessageProp_setSupplementaryStates == NULL) {
 227  227      printf("Couldn't find MessageProp.setSupplementaryStates(...) method\n");
 228  228      return JNI_ERR;
 229  229    }
 230  230    MID_GSSException_ctor3 = (*env)-&gt;GetMethodID
 231  231      (env, CLS_GSSException, "&lt;init&gt;", "(IILjava/lang/String;)V");
 232  232    if (MID_GSSException_ctor3 == NULL) {
 233  233      printf("Couldn't find GSSException(int, int, String) constructor\n");
 234  234      return JNI_ERR;
 235  235    }
 236  236    cls = (*env)-&gt;FindClass(env, "org/ietf/jgss/ChannelBinding");
 237  237    if (cls == NULL) {
 238  238      printf("Couldn't find org.ietf.jgss.ChannelBinding class\n");
 239  239      return JNI_ERR;
 240  240    }
 241  241    MID_ChannelBinding_getInitiatorAddr =
 242  242      (*env)-&gt;GetMethodID(env, cls, "getInitiatorAddress",
 243  243                          "()Ljava/net/InetAddress;");
 244  244    if (MID_ChannelBinding_getInitiatorAddr == NULL) {
 245  245      printf("Couldn't find ChannelBinding.getInitiatorAddress() method\n");
 246  246      return JNI_ERR;
 247  247    }
 248  248    MID_ChannelBinding_getAcceptorAddr =
 249  249      (*env)-&gt;GetMethodID(env, cls, "getAcceptorAddress",
 250  250                          "()Ljava/net/InetAddress;");
 251  251    if (MID_ChannelBinding_getAcceptorAddr == NULL) {
 252  252      printf("Couldn't find ChannelBinding.getAcceptorAddress() method\n");
 253  253      return JNI_ERR;
 254  254    }
 255  255    MID_ChannelBinding_getAppData =
 256  256      (*env)-&gt;GetMethodID(env, cls, "getApplicationData", "()[B");
 257  257    if (MID_ChannelBinding_getAppData == NULL) {
 258  258      printf("Couldn't find ChannelBinding.getApplicationData() method\n");
 259  259      return JNI_ERR;
 260  260    }
 261  261    cls = (*env)-&gt;FindClass(env, "java/net/InetAddress");
 262  262    if (cls == NULL) {
 263  263      printf("Couldn't find java.net.InetAddress class\n");
</pre>
<table id='hb-elided1' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided1", "hb-elided1", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">263 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided1", "hb-elided1", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre> 264  264      return JNI_ERR;
 265  265    }
 266  266    MID_InetAddress_getAddr = (*env)-&gt;GetMethodID(env, cls, "getAddress",
 267  267                                                  "()[B");
 268  268    if (MID_InetAddress_getAddr == NULL) {
 269  269      printf("Couldn't find InetAddress.getAddress() method\n");
 270  270      return JNI_ERR;
 271  271    }
 272  272    MID_GSSNameElement_ctor =
 273  273      (*env)-&gt;GetMethodID(env, CLS_GSSNameElement,
<span class='subtracted'> 274      -                        "&lt;init&gt;", "(JLsun/security/jgss/wrapper/GSSLibStub;)V");
</span><span class='added'>      274 +                        "&lt;init&gt;", "(JLorg/ietf/jgss/Oid;Lsun/security/jgss/wrapper/GSSLibStub;)V");
</span> 275  275    if (MID_GSSNameElement_ctor == NULL) {
<span class='subtracted'> 276      -    printf("Couldn't find GSSNameElement(long, GSSLibStub) constructor\n");
</span><span class='added'>      276 +    printf("Couldn't find GSSNameElement(long, Oid, GSSLibStub) constructor\n");
</span> 277  277      return JNI_ERR;
 278  278    }
 279  279    MID_GSSCredElement_ctor =
 280  280      (*env)-&gt;GetMethodID(env, CLS_GSSCredElement, "&lt;init&gt;",
 281  281          "(JLsun/security/jgss/wrapper/GSSNameElement;Lorg/ietf/jgss/Oid;)V");
 282  282    if (MID_GSSCredElement_ctor == NULL) {
 283  283      printf("Couldn't find GSSCredElement(long, GSSLibStub) constructor\n");
 284  284      return JNI_ERR;
 285  285    }
 286  286    MID_NativeGSSContext_ctor =
</pre>
<pre id='elided2' class='elided' style='display: none'> 287  287      (*env)-&gt;GetMethodID(env, CLS_NativeGSSContext, "&lt;init&gt;",
 288  288                          "(JLsun/security/jgss/wrapper/GSSLibStub;)V");
 289  289    if (MID_NativeGSSContext_ctor == NULL) {
 290  290      printf("Couldn't find NativeGSSContext(long, GSSLibStub) constructor\n");
 291  291      return JNI_ERR;
 292  292    }
 293  293    /* Compute and cache the field ID */
 294  294    cls = (*env)-&gt;FindClass(env, "sun/security/jgss/wrapper/GSSLibStub");
 295  295    if (cls == NULL) {
 296  296      printf("Couldn't find sun.security.jgss.wrapper.GSSLibStub class\n");
 297  297      return JNI_ERR;
 298  298    }
 299  299    FID_GSSLibStub_pMech =
 300  300      (*env)-&gt;GetFieldID(env, cls, "pMech", "J");
 301  301    if (FID_GSSLibStub_pMech == NULL) {
 302  302      printf("Couldn't find GSSLibStub.pMech field\n");
 303  303      return JNI_ERR;
 304  304    }
 305  305    FID_NativeGSSContext_pContext =
 306  306      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "pContext", "J");
 307  307    if (FID_NativeGSSContext_pContext == NULL) {
 308  308      printf("Couldn't find NativeGSSContext.pContext field\n");
 309  309      return JNI_ERR;
 310  310    }
 311  311    FID_NativeGSSContext_srcName =
 312  312      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "srcName",
 313  313                         "Lsun/security/jgss/wrapper/GSSNameElement;");
 314  314    if (FID_NativeGSSContext_srcName == NULL) {
 315  315      printf("Couldn't find NativeGSSContext.srcName field\n");
 316  316     return JNI_ERR;
 317  317    }
 318  318    FID_NativeGSSContext_targetName =
 319  319      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "targetName",
 320  320                         "Lsun/security/jgss/wrapper/GSSNameElement;");
 321  321    if (FID_NativeGSSContext_targetName == NULL) {
 322  322      printf("Couldn't find NativeGSSContext.targetName field\n");
 323  323      return JNI_ERR;
 324  324    }
 325  325    FID_NativeGSSContext_isInitiator =
 326  326      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "isInitiator", "Z");
 327  327    if (FID_NativeGSSContext_isInitiator == NULL) {
 328  328      printf("Couldn't find NativeGSSContext.isInitiator field\n");
 329  329      return JNI_ERR;
 330  330    }
 331  331    FID_NativeGSSContext_isEstablished =
 332  332      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "isEstablished", "Z");
 333  333    if (FID_NativeGSSContext_isEstablished == NULL) {
 334  334      printf("Couldn't find NativeGSSContext.isEstablished field\n");
 335  335      return JNI_ERR;
 336  336    }
 337  337    FID_NativeGSSContext_delegatedCred =
 338  338      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "delegatedCred",
 339  339                         "Lsun/security/jgss/wrapper/GSSCredElement;");
 340  340    if (FID_NativeGSSContext_delegatedCred == NULL) {
 341  341      printf("Couldn't find NativeGSSContext.delegatedCred field\n");
 342  342      return JNI_ERR;
 343  343    }
 344  344    FID_NativeGSSContext_flags =
 345  345      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "flags", "I");
 346  346    if (FID_NativeGSSContext_flags == NULL) {
 347  347      printf("Couldn't find NativeGSSContext.flags field\n");
 348  348      return JNI_ERR;
 349  349    }
 350  350    FID_NativeGSSContext_lifetime =
 351  351      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "lifetime", "I");
 352  352    if (FID_NativeGSSContext_lifetime == NULL) {
 353  353      printf("Couldn't find NativeGSSContext.lifetime field\n");
 354  354      return JNI_ERR;
 355  355    }
 356  356    FID_NativeGSSContext_actualMech =
 357  357      (*env)-&gt;GetFieldID(env, CLS_NativeGSSContext, "actualMech",
 358  358                         "Lorg/ietf/jgss/Oid;");
 359  359    if (FID_NativeGSSContext_actualMech == NULL) {
 360  360      printf("Couldn't find NativeGSSContext.actualMech field\n");
 361  361      return JNI_ERR;
 362  362    }
 363  363    return JNI_VERSION_1_2;
 364  364  }
 365  365  
 366  366  JNIEXPORT void JNICALL
 367  367  DEF_JNI_OnUnload(JavaVM *jvm, void *reserved) {
 368  368    JNIEnv *env;
 369  369  
 370  370    if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_2)) {
 371  371      return;
 372  372    }
 373  373    /* Delete the global refs */
 374  374    (*env)-&gt;DeleteGlobalRef(env, CLS_Object);
 375  375    (*env)-&gt;DeleteGlobalRef(env, CLS_String);
 376  376    (*env)-&gt;DeleteGlobalRef(env, CLS_Oid);
 377  377    (*env)-&gt;DeleteGlobalRef(env, CLS_GSSException);
 378  378    (*env)-&gt;DeleteGlobalRef(env, CLS_GSSNameElement);
 379  379    (*env)-&gt;DeleteGlobalRef(env, CLS_GSSCredElement);
 380  380    (*env)-&gt;DeleteGlobalRef(env, CLS_SunNativeProvider);
 381  381    return;
 382  382  }
 383  383  
 384  384  const OM_uint32 JAVA_MAX = GSS_C_INDEFINITE/2;
 385  385  
 386  386  /*
 387  387   * Utility routine for converting the C unsigned integer time
 388  388   * to Java signed integer time.
 389  389   */
 390  390  jint getJavaTime(OM_uint32 ctime) {
 391  391    jint result;
 392  392  
 393  393    /* special handle values equals or more than JAVA_MAX */
 394  394    if (ctime == GSS_C_INDEFINITE) {
 395  395      result = JAVA_MAX;
 396  396    } else if (ctime &gt;= JAVA_MAX) {
 397  397      result = JAVA_MAX-1;
 398  398    } else {
 399  399      result = ctime;
 400  400    }
 401  401    return result;
 402  402  }
 403  403  /*
 404  404   * Utility routine for converting the Java signed integer time
 405  405   * to C unsigned integer time.
 406  406   */
 407  407  OM_uint32 getGSSTime(jint jtime) {
 408  408    OM_uint32 result;
 409  409  
 410  410    /* special handle values equal to JAVA_MAX */
 411  411    if (jtime == (jint)JAVA_MAX) {
 412  412      result = GSS_C_INDEFINITE;
 413  413    } else {
 414  414      result = jtime;
 415  415    }
 416  416    return result;
 417  417  }
 418  418  /*
 419  419   * Utility routine for mapping the C error code to the
 420  420   * Java one. The routine errors really should have
 421  421   * shared the same values but unfortunately don't.
 422  422   */
 423  423  jint getJavaErrorCode(int cNonCallingErr) {
 424  424    int cRoutineErr, cSuppStatus;
 425  425    /* map the routine errors */
 426  426    cRoutineErr = GSS_ROUTINE_ERROR(cNonCallingErr) &gt;&gt; 16;
 427  427    if (cRoutineErr != GSS_S_COMPLETE) {
 428  428      return JAVA_ERROR_CODE[cRoutineErr-1];
 429  429    }
 430  430    /* map the supplementary infos */
 431  431    cSuppStatus = GSS_SUPPLEMENTARY_INFO(cNonCallingErr);
 432  432    if (cSuppStatus &amp; GSS_S_DUPLICATE_TOKEN) {
 433  433      return JAVA_DUPLICATE_TOKEN_CODE;
 434  434    } else if (cSuppStatus &amp; GSS_S_OLD_TOKEN) {
 435  435      return JAVA_OLD_TOKEN_CODE;
 436  436    } else if (cSuppStatus &amp; GSS_S_UNSEQ_TOKEN) {
 437  437      return JAVA_UNSEQ_TOKEN_CODE;
 438  438    } else if (cSuppStatus &amp; GSS_S_GAP_TOKEN) {
 439  439      return JAVA_GAP_TOKEN_CODE;
 440  440    }
 441  441    return GSS_S_COMPLETE;
 442  442  }
 443  443  
 444  444  
 445  445  /* Throws a Java Exception by name */
 446  446  void throwByName(JNIEnv *env, const char *name, const char *msg) {
 447  447      jclass cls = (*env)-&gt;FindClass(env, name);
</pre>
<table id='hb-elided2' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided2", "hb-elided2", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">161 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided2", "hb-elided2", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre> 448  448  
 449  449      if (cls != NULL) {
 450  450          (*env)-&gt;ThrowNew(env, cls, msg);
 451  451      }
 452  452  }
 453  453  
 454  454  void throwOutOfMemoryError(JNIEnv *env, const char *message) {
 455  455      throwByName(env, "java/lang/OutOfMemoryError", message);
 456  456  }
 457  457  
<span class='added'>      458 +static jsize
      459 +safe_jsize(size_t n)
      460 +{
      461 +    jsize res = (jsize)n;
      462 +
      463 +    return (res &gt;= 0 &amp;&amp; (size_t)res == n) ? res : -1;
      464 +}
      465 +
</span> 458  466  /*
 459  467   * Utility routine for creating a java.lang.String object
 460  468   * using the specified gss_buffer_t structure. The specified
 461  469   * gss_buffer_t structure is always released.
 462  470   */
 463  471  jstring getJavaString(JNIEnv *env, gss_buffer_t bytes) {
 464  472    jstring result = NULL;
 465  473    OM_uint32 minor;
<span class='subtracted'> 466      -  int len;
</span><span class='added'>      474 +  jsize len;
</span> 467  475    jbyteArray jbytes;
 468  476  
<span class='subtracted'> 469      -  if (bytes != NULL) {
 470      -    /* constructs the String object with new String(byte[])
 471      -       NOTE: do NOT include the trailing NULL */
 472      -    len = (int) bytes-&gt;length;
 473      -    jbytes = (*env)-&gt;NewByteArray(env, len);
 474      -    if (jbytes == NULL) {
 475      -      goto finish;
 476      -    }
</span><span class='added'>      477 +  if (bytes == NULL) {
      478 +    return NULL;
      479 +  }
</span> 477  480  
<span class='subtracted'> 478      -    (*env)-&gt;SetByteArrayRegion(env, jbytes, 0, len, (jbyte *) bytes-&gt;value);
 479      -    if ((*env)-&gt;ExceptionCheck(env)) {
 480      -      goto finish;
 481      -    }
</span><span class='added'>      481 +  /* constructs the String object with new String(byte[]) */
      482 +  if ((len = safe_jsize(bytes-&gt;length)) &lt; 0) {
      483 +    (*ftab-&gt;releaseBuffer)(&amp;minor, bytes);
      484 +    return NULL;
      485 +  }
      486 +  jbytes = (*env)-&gt;NewByteArray(env, len);
      487 +  if (jbytes == NULL) {
      488 +    (*ftab-&gt;releaseBuffer)(&amp;minor, bytes);
      489 +    return NULL;
      490 +  }
</span> 482  491  
<span class='added'>      492 +  (*env)-&gt;SetByteArrayRegion(env, jbytes, 0, len, (jbyte *) bytes-&gt;value);
      493 +  if ((*env)-&gt;ExceptionCheck(env) == JNI_FALSE) {
</span> 483  494      result = (*env)-&gt;NewObject(env, CLS_String, MID_String_ctor,
 484  495                                 jbytes);
<span class='subtracted'> 485      -  finish:
 486      -    (*env)-&gt;DeleteLocalRef(env, jbytes);
 487      -    (*ftab-&gt;releaseBuffer)(&amp;minor, bytes);
 488      -    return result;
 489      -  } /* else fall through */
 490      -  return NULL;
</span><span class='added'>      496 +  }
      497 +
      498 +  (*env)-&gt;DeleteLocalRef(env, jbytes);
      499 +  (*ftab-&gt;releaseBuffer)(&amp;minor, bytes);
      500 +  return result;
</span> 491  501  }
 492  502  /*
 493  503   * Utility routine for generate message for the specified minor
 494  504   * status code.
 495  505   */
 496  506  jstring getMinorMessage(JNIEnv *env, jobject jstub, OM_uint32 statusValue) {
 497  507    OM_uint32 messageContext, minor, major;
 498  508    gss_buffer_desc statusString;
 499  509    gss_OID mech;
 500  510  
</pre>
<pre id='elided3' class='elided' style='display: none'> 501  511    messageContext = 0;
 502  512    if (jstub != NULL) {
 503  513      mech = (gss_OID) jlong_to_ptr((*env)-&gt;GetLongField(env, jstub, FID_GSSLibStub_pMech));
 504  514    } else {
 505  515      mech = GSS_C_NO_OID;
 506  516    }
 507  517  
 508  518    /* gss_display_status(...) =&gt; GSS_S_BAD_MECH, GSS_S_BAD_STATUS */
 509  519    // TBD: check messageContext value and repeat the call if necessary
 510  520    major = (*ftab-&gt;displayStatus)(&amp;minor, statusValue, GSS_C_MECH_CODE, mech,
 511  521                                   &amp;messageContext, &amp;statusString);
</pre>
<table id='hb-elided3' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided3", "hb-elided3", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">11 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided3", "hb-elided3", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre> 512  522  
 513  523    return getJavaString(env, &amp;statusString);
 514  524  }
 515  525  
 516  526  /*
 517  527   * Utility routine checking the specified major and minor
 518  528   * status codes. GSSExceptions will be thrown if they are
 519  529   * not GSS_S_COMPLETE (i.e. 0).
 520  530   */
 521  531  void checkStatus(JNIEnv *env, jobject jstub, OM_uint32 major,
<span class='subtracted'> 522      -                 OM_uint32 minor, char* methodName) {
</span><span class='added'>      532 +                 OM_uint32 minor, const char *methodName) {
</span> 523  533    int callingErr, routineErr, supplementaryInfo;
 524  534    jint jmajor, jminor;
 525  535    char* msg;
 526  536    jstring jmsg;
 527  537    jthrowable gssEx;
 528  538  
 529  539    if (major == GSS_S_COMPLETE) return;
 530  540  
 531  541    callingErr = GSS_CALLING_ERROR(major);
 532  542    routineErr = GSS_ROUTINE_ERROR(major);
</pre>
<pre id='elided4' class='elided' style='display: none'> 533  543    supplementaryInfo = GSS_SUPPLEMENTARY_INFO(major);
 534  544  
 535  545    TRACE3("%s Status major/minor = %x/%d", methodName, major, minor);
 536  546    TRACE3("c/r/s = %d/%d/%d ", callingErr&gt;&gt;24, routineErr&gt;&gt;16,
 537  547            supplementaryInfo);
 538  548  
 539  549    jmajor = getJavaErrorCode(routineErr | supplementaryInfo);
 540  550    jminor = minor;
 541  551    if (jmajor != GSS_S_COMPLETE) {
 542  552      jmsg = NULL;
 543  553      if (minor != 0) {
 544  554        jmsg = getMinorMessage(env, jstub, minor);
 545  555        if ((*env)-&gt;ExceptionCheck(env)) {
 546  556          return;
 547  557        }
 548  558      }
 549  559  
 550  560      gssEx = (*env)-&gt;NewObject(env, CLS_GSSException,
 551  561                                MID_GSSException_ctor3,
 552  562                                jmajor, jminor, jmsg);
 553  563      if (gssEx != NULL) {
 554  564        (*env)-&gt;Throw(env, gssEx);
 555  565      }
 556  566    } else {
 557  567      /* Error in calling the GSS api */
 558  568      if (callingErr == GSS_S_CALL_INACCESSIBLE_READ) {
 559  569        msg = "A required input parameter cannot be read";
 560  570      } else if (callingErr == GSS_S_CALL_INACCESSIBLE_WRITE) {
 561  571        msg = "A required output parameter cannot be write";
 562  572      } else {
 563  573        msg = "A parameter was malformed";
 564  574      }
 565  575      jmajor = 13; /* use GSSException.FAILURE for now */
 566  576      jmsg = (*env)-&gt;NewStringUTF(env, msg);
 567  577      if (jmsg == NULL) {
 568  578        return;
 569  579      }
 570  580      gssEx = (*env)-&gt;NewObject(env, CLS_GSSException,
 571  581                                MID_GSSException_ctor3,
 572  582                                jmajor, jminor, jmsg);
</pre>
<table id='hb-elided4' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided4", "hb-elided4", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">40 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided4", "hb-elided4", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre> 573  583      if (gssEx != NULL) {
 574  584        (*env)-&gt;Throw(env, gssEx);
 575  585      }
 576  586    }
 577  587  }
 578  588  
 579  589  /*
 580  590   * Utility routine for initializing gss_buffer_t structure
 581  591   * with the byte[] in the specified jbyteArray object.
 582  592   * NOTE: must call resetGSSBuffer() to free up the resources
<span class='subtracted'> 583      - * inside the gss_buffer_t structure.
</span> 584  593   */
 585  594  void initGSSBuffer(JNIEnv *env, jbyteArray jbytes,
<span class='subtracted'> 586      -                     gss_buffer_t cbytes) {
 587      -
 588      -  int len;
</span><span class='added'>      595 +                     gss_buffer_t cbytes, jboolean wantCopy)
      596 +{
      597 +  jboolean isCopy;
      598 +  jint len;
</span> 589  599    void* value;
 590  600  
<span class='subtracted'> 591      -  if (jbytes != NULL) {
 592      -    len = (*env)-&gt;GetArrayLength(env, jbytes);
 593      -    value = malloc(len);
 594      -    if (value == NULL) {
</span><span class='added'>      601 +  cbytes-&gt;length = 0;
      602 +  cbytes-&gt;value = NULL;
      603 +
      604 +  if (jbytes == NULL ||
      605 +      (len = (*env)-&gt;GetArrayLength(env, jbytes)) == 0)
      606 +    return;
      607 +
      608 +  cbytes-&gt;length = len;
      609 +
      610 +  if (wantCopy == JNI_FALSE) {
      611 +    cbytes-&gt;value = (*env)-&gt;GetByteArrayElements(env, jbytes, &amp;isCopy);
      612 +    if (cbytes-&gt;value == NULL) {
</span> 595  613        throwOutOfMemoryError(env, NULL);
<span class='subtracted'> 596      -      return;
 597      -    } else {
 598      -      (*env)-&gt;GetByteArrayRegion(env, jbytes, 0, len, value);
 599      -      if ((*env)-&gt;ExceptionCheck(env)) {
 600      -        free(value);
 601      -        return;
 602      -      } else {
 603      -        cbytes-&gt;length = len;
 604      -        cbytes-&gt;value = value;
 605      -      }
</span> 606  614      }
<span class='subtracted'> 607      -  } else {
 608      -    cbytes-&gt;length = 0;
 609      -    cbytes-&gt;value = NULL;
</span><span class='added'>      615 +    return;
      616 +  }
      617 +
      618 +  value = malloc(len);
      619 +  if (value == NULL) {
      620 +    throwOutOfMemoryError(env, NULL);
      621 +    return;
</span> 610  622    }
<span class='added'>      623 +
      624 +  (*env)-&gt;GetByteArrayRegion(env, jbytes, 0, len, value);
      625 +  if ((*env)-&gt;ExceptionCheck(env)) {
      626 +    free(value);
      627 +    return;
      628 +  }
      629 +  cbytes-&gt;value = value;
</span> 611  630  }
 612  631  
 613  632  /*
<span class='subtracted'> 614      - * Utility routine for freeing the bytes malloc'ed
 615      - * in initGSSBuffer() method.
 616      - * NOTE: used in conjunction with initGSSBuffer(...).
</span><span class='added'>      633 + * Utility routine for freeing the buffer obtained via initGSSBuffer().
      634 + * If jbytes is null this is a malloced copy.
</span> 617  635   */
<span class='subtracted'> 618      -void resetGSSBuffer(gss_buffer_t cbytes) {
 619      -  if ((cbytes != NULL) &amp;&amp; (cbytes != GSS_C_NO_BUFFER)) {
</span><span class='added'>      636 +void resetGSSBuffer(JNIEnv *env, jbyteArray jbytes, gss_buffer_t cbytes)
      637 +{
      638 +  if (cbytes-&gt;value == NULL)
      639 +    return;
      640 +  if (jbytes != NULL) {
      641 +    (*env)-&gt;ReleaseByteArrayElements(env, jbytes, cbytes-&gt;value, JNI_ABORT);
      642 +  } else if (cbytes-&gt;length &gt; 0) {
</span> 620  643      free(cbytes-&gt;value);
<span class='subtracted'> 621      -    cbytes-&gt;length = 0;
</span> 622  644      cbytes-&gt;value = NULL;
<span class='added'>      645 +    cbytes-&gt;length = 0;
      646 +  }
      647 +}
      648 +
      649 +/*
      650 + * Utility routine for initializing gss_buffer_t structure
      651 + * with a String.
      652 + * NOTE: need to call resetGSSBufferString(...) to free up
      653 + * the resources.
      654 + */
      655 +void initGSSBufferString(JNIEnv* env, jstring jstr, gss_buffer_t buf)
      656 +{
      657 +  const char *s;
      658 +
      659 +  buf-&gt;length = 0;
      660 +  buf-&gt;value = NULL;
      661 +  if (jstr != NULL) {
      662 +    s = (*env)-&gt;GetStringUTFChars(env, jstr, NULL);
      663 +    if (s == NULL) {
      664 +      throwOutOfMemoryError(env, NULL);
      665 +    } else {
      666 +      buf-&gt;length = strlen(s);
      667 +      buf-&gt;value = (char *)s; /* Drop const */
      668 +    }
      669 +  }
      670 +}
      671 +
      672 +/*
      673 + * Utility routine for unpinning/releasing the String
      674 + * associated with the specified jstring object.
      675 + * NOTE: used in conjunction with initGSSBufferString(...).
      676 + */
      677 +void resetGSSBufferString(JNIEnv *env, jstring jstr, gss_buffer_t buf)
      678 +{
      679 +  if (jstr != NULL &amp;&amp; buf-&gt;value != NULL)
      680 +    (*env)-&gt;ReleaseStringUTFChars(env, jstr, buf-&gt;value);
      681 +}
      682 +
      683 +void initGSSCredStore(JNIEnv *env, jarray jstore,
      684 +                      gss_key_value_set_desc *store) {
      685 +  jsize nelements = 0;
      686 +  jsize n, i, k;
      687 +
      688 +  store-&gt;count = 0;
      689 +  store-&gt;elements = NULL;
      690 +  if (jstore == NULL) {
      691 +    return;
      692 +  }
      693 +  n = (*env)-&gt;GetArrayLength(env, jstore);
      694 +  for (i = 0; i &lt; n; i += 2) {
      695 +    jobject jkey = (*env)-&gt;GetObjectArrayElement(env, jstore, i);
      696 +    jobject jval = (*env)-&gt;GetObjectArrayElement(env, jstore, i + 1);
      697 +    
      698 +    if (!jkey || !jval) {
      699 +      break;
      700 +    }
      701 +    if (!(*env)-&gt;IsInstanceOf(env, jkey, CLS_String) ||
      702 +        !(*env)-&gt;IsInstanceOf(env, jval, CLS_String)) {
      703 +      throwByName(env, "java/lang/IllegalArgumentException",
      704 +                  "invalid GSS credential store element type; must be String");
      705 +      store-&gt;count = 0;
      706 +      return;
      707 +    }
      708 +    store-&gt;count += 1;
      709 +    nelements += 2;
      710 +  }
      711 +  if (nelements &lt; 0 || nelements &gt; INT32_MAX) {
      712 +    throwOutOfMemoryError(env,NULL);
      713 +    store-&gt;count = 0;
      714 +    return;
      715 +  }
      716 +  store-&gt;elements = calloc(store-&gt;count, sizeof(store-&gt;elements[0]));
      717 +  if (store-&gt;elements == NULL) {
      718 +    throwOutOfMemoryError(env,NULL);
      719 +    store-&gt;count = 0;
      720 +    return;
      721 +  }
      722 +  for (i = 0, k = 0; i &lt; nelements; i += 2, k++) {
      723 +    jobject jkey = (*env)-&gt;GetObjectArrayElement(env, jstore, i);
      724 +    jobject jval = (*env)-&gt;GetObjectArrayElement(env, jstore, i + 1);
      725 +    store-&gt;elements[k].key = (*env)-&gt;GetStringUTFChars(env, jkey, NULL);
      726 +    store-&gt;elements[k].value = (*env)-&gt;GetStringUTFChars(env, jval, NULL);
      727 +    TRACE2("[GSSLibStub initGSSCredStore] element %ld key %s",
      728 +           (long)k, store-&gt;elements[k].key);
      729 +    TRACE2("[GSSLibStub initGSSCredStore] element %ld value %s",
      730 +           (long)k, store-&gt;elements[k].value);
</span> 623  731    }
 624  732  }
 625  733  
<span class='added'>      734 +void resetGSSCredStore(JNIEnv *env,
      735 +                       jarray jstore,
      736 +                       gss_key_value_set_desc *store) {
      737 +  jobject jstr;
      738 +  jsize i;
      739 +
      740 +  for (i = 0; i &lt; (jsize)store-&gt;count; i++) {
      741 +    jstr = (*env)-&gt;GetObjectArrayElement(env, jstore, i);
      742 +    if (!(i &amp; 0x01)) {
      743 +      (*env)-&gt;ReleaseStringUTFChars(env, jstr, store-&gt;elements[i].key);
      744 +    } else {
      745 +      (*env)-&gt;ReleaseStringUTFChars(env, jstr, store-&gt;elements[i].value);
      746 +    }
      747 +  }
      748 +  free(store-&gt;elements);
      749 +  store-&gt;elements = NULL;
      750 +  store-&gt;count = 0;
      751 +}
      752 +
      753 +
</span> 626  754  /*
 627  755   * Utility routine for creating a jbyteArray object using
 628  756   * the byte[] value in specified gss_buffer_t structure.
 629  757   * NOTE: the specified gss_buffer_t structure is always
 630  758   * released.
 631  759   */
<span class='subtracted'> 632      -jbyteArray getJavaBuffer(JNIEnv *env, gss_buffer_t cbytes) {
</span><span class='added'>      760 +jbyteArray getJavaBuffer(JNIEnv *env, gss_buffer_t cbytes, jboolean isToken) {
</span> 633  761    jbyteArray result = NULL;
<span class='subtracted'> 634      -  OM_uint32 minor; // don't care, just so it compiles
</span><span class='added'>      762 +  OM_uint32 dummy;
</span> 635  763  
<span class='subtracted'> 636      -  if (cbytes != NULL) {
 637      -    if ((cbytes != GSS_C_NO_BUFFER) &amp;&amp; (cbytes-&gt;length != 0)) {
 638      -      result = (*env)-&gt;NewByteArray(env, (int) cbytes-&gt;length);
 639      -      if (result == NULL) {
 640      -        goto finish;
 641      -      }
 642      -      (*env)-&gt;SetByteArrayRegion(env, result, 0, (int) cbytes-&gt;length,
</span><span class='added'>      764 +  /*
      765 +   * Zero length tokens map to NULL outputs, but otherwise to a zero-length
      766 +   * Java byte array.
      767 +   */
      768 +  if (cbytes != GSS_C_NO_BUFFER &amp;&amp;
      769 +      (isToken == JNI_FALSE || cbytes-&gt;length &gt; 0)) {
      770 +    jsize len = safe_jsize(cbytes-&gt;length);
      771 +
      772 +    if (len &gt;= 0) {
      773 +      result = (*env)-&gt;NewByteArray(env, len);
      774 +    }
      775 +    if (result != NULL) {
      776 +      (*env)-&gt;SetByteArrayRegion(env, result, 0, len,
</span> 643  777                                   cbytes-&gt;value);
 644  778        if ((*env)-&gt;ExceptionCheck(env)) {
<span class='added'>      779 +        (*env)-&gt;DeleteLocalRef(env, result);
</span> 645  780          result = NULL;
 646  781        }
 647  782      }
<span class='subtracted'> 648      -  finish:
 649      -    (*ftab-&gt;releaseBuffer)(&amp;minor, cbytes);
 650      -    return result;
</span> 651  783    }
<span class='subtracted'> 652      -  return NULL;
</span><span class='added'>      784 +  (void) (*ftab-&gt;releaseBuffer)(&amp;dummy, cbytes);
      785 +  return result;
</span> 653  786  }
 654  787  
 655  788  /*
 656  789   * Utility routine for creating a non-mech gss_OID using
 657  790   * the specified org.ietf.jgss.Oid object.
 658  791   * NOTE: must call deleteGSSOID(...) to free up the gss_OID.
 659  792   */
 660  793  gss_OID newGSSOID(JNIEnv *env, jobject jOid) {
 661  794    jbyteArray jbytes;
 662  795    gss_OID cOid;
</pre>
<pre id='elided5' class='elided' style='display: none'> 663  796    if (jOid != NULL) {
 664  797      jbytes = (*env)-&gt;CallObjectMethod(env, jOid, MID_Oid_getDER);
 665  798      if ((*env)-&gt;ExceptionCheck(env)) {
 666  799        return GSS_C_NO_OID;
 667  800      }
 668  801      cOid = malloc(sizeof(struct gss_OID_desc_struct));
 669  802      if (cOid == NULL) {
 670  803        throwOutOfMemoryError(env,NULL);
 671  804        return GSS_C_NO_OID;
 672  805      }
 673  806      cOid-&gt;length = (*env)-&gt;GetArrayLength(env, jbytes) - 2;
 674  807      cOid-&gt;elements = malloc(cOid-&gt;length);
 675  808      if (cOid-&gt;elements == NULL) {
 676  809        throwOutOfMemoryError(env,NULL);
 677  810        goto cleanup;
 678  811      }
 679  812      (*env)-&gt;GetByteArrayRegion(env, jbytes, 2, cOid-&gt;length,
 680  813                                 cOid-&gt;elements);
 681  814      if ((*env)-&gt;ExceptionCheck(env)) {
 682  815        goto cleanup;
 683  816      }
 684  817      return cOid;
 685  818    } else {
 686  819      return GSS_C_NO_OID;
 687  820    }
 688  821    cleanup:
 689  822      (*env)-&gt;DeleteLocalRef(env, jbytes);
 690  823      free(cOid-&gt;elements);
 691  824      free(cOid);
 692  825      return GSS_C_NO_OID;
 693  826  }
 694  827  
 695  828  /*
 696  829   * Utility routine for releasing the specified gss_OID
 697  830   * structure.
 698  831   * NOTE: used in conjunction with newGSSOID(...).
 699  832   */
 700  833  void deleteGSSOID(gss_OID oid) {
 701  834    if (oid != GSS_C_NO_OID) {
 702  835      free(oid-&gt;elements);
 703  836      free(oid);
 704  837    }
 705  838  }
 706  839  
 707  840  /*
 708  841   * Utility routine for creating a org.ietf.jgss.Oid
 709  842   * object using the specified gss_OID structure.
 710  843   */
 711  844  jobject getJavaOID(JNIEnv *env, gss_OID cOid) {
 712  845    int cLen;
 713  846    char oidHdr[2];
 714  847    jbyteArray jbytes;
 715  848    jobject result = NULL;
 716  849  
 717  850    if ((cOid == NULL) || (cOid == GSS_C_NO_OID)) {
 718  851      return NULL;
 719  852    }
 720  853    cLen = cOid-&gt;length;
 721  854    oidHdr[0] = 6;
 722  855    oidHdr[1] = cLen;
 723  856    jbytes = (*env)-&gt;NewByteArray(env, cLen+2);
 724  857    if (jbytes == NULL) {
 725  858      return NULL;
 726  859    }
 727  860    if (!(*env)-&gt;ExceptionCheck(env)) {
 728  861      (*env)-&gt;SetByteArrayRegion(env, jbytes, 0, 2, (jbyte *) oidHdr);
 729  862    }
</pre>
<table id='hb-elided5' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided5", "hb-elided5", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">67 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided5", "hb-elided5", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre> 730  863    if (!(*env)-&gt;ExceptionCheck(env)) {
 731  864      (*env)-&gt;SetByteArrayRegion(env, jbytes, 2, cLen, (jbyte *) cOid-&gt;elements);
 732  865    }
 733  866    if (!(*env)-&gt;ExceptionCheck(env)) {
 734  867      result = (*env)-&gt;NewObject(env, CLS_Oid, MID_Oid_ctor1, jbytes);
 735  868    }
 736  869    (*env)-&gt;DeleteLocalRef(env, jbytes);
 737  870    return result;
 738  871  }
 739  872  /*
<span class='subtracted'> 740      - * Utility routine for creating a gss_OID_set structure
 741      - * using the specified gss_OID.
 742      - * NOTE: need to call deleteGSSOIDSet(...) afterwards
 743      - * to release the created gss_OID_set structure.
 744      - */
 745      -gss_OID_set newGSSOIDSet(gss_OID oid) {
 746      -  gss_OID_set oidSet;
 747      -  OM_uint32 minor; // don't care; just so it compiles
 748      -
 749      -  if (oid-&gt;length != 6 ||
 750      -      memcmp(oid-&gt;elements, SPNEGO_BYTES, 6) != 0) {
 751      -      (*ftab-&gt;createEmptyOidSet)(&amp;minor, &amp;oidSet);
 752      -      (*ftab-&gt;addOidSetMember)(&amp;minor, oid, &amp;oidSet);
 753      -      return oidSet;
 754      -  } else {
 755      -      // Use all mechs for SPNEGO in order to work with
 756      -      // various native GSS impls
 757      -      return (ftab-&gt;mechs);
 758      -  }
 759      -}
 760      -/*
 761      - * Utility routine for releasing a gss_OID_set structure.
 762      - * NOTE: used in conjunction with newGSSOIDSet(...).
 763      - */
 764      -void deleteGSSOIDSet(gss_OID_set oidSet) {
 765      -  OM_uint32 minor; /* don't care; just so it compiles */
 766      -
 767      -  if ((oidSet != ftab-&gt;mechs) &amp;&amp;
 768      -      (oidSet != NULL) &amp;&amp; (oidSet != GSS_C_NO_OID_SET)) {
 769      -    (*ftab-&gt;releaseOidSet)(&amp;minor, &amp;oidSet);
</span><span class='added'>      873 + * Utility routine for filling in a 1-element gss_OID_set structure using the
      874 + * specified gss_OID (storage owned by caller).  However, with SPNEGO we return
      875 + * a static set containing all the available mechanisms.
      876 + */
      877 +gss_OID_set makeGSSOIDSet(gss_OID_set mechs, gss_OID oid) {
      878 +  if (oid-&gt;length != 6 || memcmp(oid-&gt;elements, SPNEGO_BYTES, 6) != 0) {
      879 +      mechs-&gt;count = 1;
      880 +      mechs-&gt;elements = oid;
      881 +      return mechs;
</span> 770  882    }
<span class='added'>      883 +  /* Use all mechs for SPNEGO in order to work with various native GSS impls */
      884 +  return (ftab-&gt;mechs);
</span> 771  885  }
 772  886  /*
 773  887   * Utility routine for creating a org.ietf.jgss.Oid[]
 774  888   * using the specified gss_OID_set structure.
 775  889   */
 776  890  jobjectArray getJavaOIDArray(JNIEnv *env, gss_OID_set cOidSet) {
<span class='subtracted'> 777      -  int numOfOids = 0;
</span><span class='added'>      891 +  jsize numOfOids = 0;
</span> 778  892    jobjectArray jOidSet;
 779  893    jobject jOid;
<span class='subtracted'> 780      -  int i;
</span><span class='added'>      894 +  jsize i;
</span> 781  895  
 782  896    if (cOidSet != NULL &amp;&amp; cOidSet != GSS_C_NO_OID_SET) {
<span class='subtracted'> 783      -    numOfOids = (int) cOidSet-&gt;count;
</span><span class='added'>      897 +    numOfOids = safe_jsize(cOidSet-&gt;count);
      898 +    if (numOfOids &lt; 0) {
      899 +      return NULL;
      900 +    }
</span> 784  901      jOidSet = (*env)-&gt;NewObjectArray(env, numOfOids, CLS_Oid, NULL);
 785  902      if ((*env)-&gt;ExceptionCheck(env)) {
 786  903        return NULL;
 787  904      }
 788  905      for (i = 0; i &lt; numOfOids; i++) {
 789  906        jOid = getJavaOID(env, &amp;(cOidSet-&gt;elements[i]));
 790  907        if ((*env)-&gt;ExceptionCheck(env)) {
 791  908          return NULL;
 792  909        }
 793  910        (*env)-&gt;SetObjectArrayElement(env, jOidSet, i, jOid);
</pre>
<pre id='elided6' class='elided' style='display: none'> 794  911        if ((*env)-&gt;ExceptionCheck(env)) {
 795  912          return NULL;
 796  913        }
 797  914        (*env)-&gt;DeleteLocalRef(env, jOid);
 798  915      }
 799  916      return jOidSet;
 800  917    }
 801  918    return NULL;
 802  919  }
 803  920  
 804  921  int sameMech(gss_OID mech, gss_OID mech2) {
 805  922    int result = JNI_FALSE; // default to not equal
 806  923  
 807  924    if (mech-&gt;length == mech2-&gt;length) {
 808  925      result = (memcmp(mech-&gt;elements, mech2-&gt;elements, mech-&gt;length) == 0);
 809  926    }
 810  927    return result;
 811  928  }
</pre>
<table id='hb-elided6' class='hidebar'>
  <tr>
    <td class='active-down'
      onclick='show_n_hide_dir("elided6", "hb-elided6", "down")'>
      &darr;&nbsp;open down&nbsp;&darr;</td>
    <td class="elided-label">18 lines elided</td>
    <td class='active-up'
      onclick='show_n_hide_dir("elided6", "hb-elided6", "up")'>
      &uarr;&nbsp;open up&nbsp;&uarr;</td>
  </tr>
</table>
<pre id='linerefpre'><span id='lineref'>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></pre>
    <br clear="all" />
    <br />

    <script type="text/javascript">
      /* Assign event handlers and widths. */
      var w = document.getElementById('lineref').offsetWidth;
      for (var i = 1; i <= 6; ++i) {
	      var e = document.getElementById("elided" + i);
	      e.onclick = handle_click;
              e.style.setProperty('width', w + "px", '');

	      e = document.getElementById("hb-elided" + i);
              e.style.setProperty('width', w + "px", '');
      }

      /* Hide our line size reference. */
      document.getElementById('linerefpre').style.setProperty('display',
          'none', '');

      /* Scroll as indicated. */
      str = location.search;
      s = str.substring(1, str.length);
      if (s > 0)
        window.scroll(0, s);

      function open_or_close_all(open) {
	      for (var i = 1; i <= 6; ++i) {
		      var e = document.getElementById("hb-elided" + i);
		      e.style.setProperty("display", open ? "none" : "", "");

		      e = document.getElementById("elided" + i);
		      e.style.setProperty("display", open ? "" : "none", "");
	      }
      }
    </script>
  </body>
</html>
