<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache"></meta>
<meta http-equiv="Content-Type" content="text/xhtml;charset=utf-8"></meta>
<meta http-equiv="Pragma" content="no-cache"></meta>
<meta http-equiv="Expires" content="-1"></meta>
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
span.chmod {
    font-size: 0.7em;
    color: #db7800;
}
a.print { font-size: x-small; }
a:hover { background-color: #ffcc99; }
</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>Krb5LoginModule cleanup
Add commentary about native in Krb5LoginModule</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 package com.sun.security.auth.module;
  28 
  29 import java.io.*;
<a name="1" id="anc1"></a>
  30 import java.text.MessageFormat;
  31 import java.util.*;
  32 
  33 import javax.security.auth.*;
  34 import javax.security.auth.kerberos.KerberosTicket;
  35 import javax.security.auth.kerberos.KerberosPrincipal;
  36 import javax.security.auth.kerberos.KerberosKey;
  37 import javax.security.auth.kerberos.KeyTab;
  38 import javax.security.auth.callback.*;
  39 import javax.security.auth.login.*;
  40 import javax.security.auth.spi.*;
  41 
  42 import sun.security.krb5.*;
  43 import sun.security.jgss.krb5.Krb5Util;
  44 import sun.security.krb5.Credentials;
  45 import sun.security.util.HexDumpEncoder;
  46 import static sun.security.util.ResourcesMgr.getAuthResourceString;
  47 
  48 /**
  49  * This {@code LoginModule} authenticates users using
  50  * Kerberos protocols.
  51  *
  52  * &lt;p&gt; The configuration entry for {@code Krb5LoginModule} has
  53  * several options that control the authentication process and
  54  * additions to the {@code Subject}'s private credential
  55  * set. Irrespective of these options, the {@code Subject}'s
  56  * principal set and private credentials set are updated only when
  57  * {@code commit} is called.
  58  * When {@code commit} is called, the {@code KerberosPrincipal}
  59  * is added to the {@code Subject}'s principal set (unless the
  60  * {@code principal} is specified as "*"). If {@code isInitiator}
  61  * is true, the {@code KerberosTicket} is
  62  * added to the {@code Subject}'s private credentials.
  63  *
  64  * &lt;p&gt; If the configuration entry for {@code KerberosLoginModule}
  65  * has the option {@code storeKey} set to true, then
  66  * {@code KerberosKey} or {@code KeyTab} will also be added to the
  67  * subject's private credentials. {@code KerberosKey}, the principal's
  68  * key(s) will be derived from user's password, and {@code KeyTab} is
  69  * the keytab used when {@code useKeyTab} is set to true. The
  70  * {@code KeyTab} object is restricted to be used by the specified
  71  * principal unless the principal value is "*".
  72  *
  73  * &lt;p&gt; This {@code LoginModule} recognizes the {@code doNotPrompt}
  74  * option. If set to true the user will not be prompted for the password.
  75  *
  76  * &lt;p&gt; The user can  specify the location of the ticket cache by using
  77  * the option {@code ticketCache} in the configuration entry.
  78  *
  79  * &lt;p&gt;The user can specify the keytab location by using
  80  * the option {@code keyTab}
  81  * in the configuration entry.
  82  *
  83  * &lt;p&gt; The principal name can be specified in the configuration entry
  84  * by using the option {@code principal}. The principal name
  85  * can either be a simple user name, a service name such as
  86  * {@code host/mission.eng.sun.com}, or "*". The principal can also
  87  * be set using the system property {@systemProperty sun.security.krb5.principal}.
  88  * This property is checked during login. If this property is not set, then
  89  * the principal name from the configuration is used. In the
  90  * case where the principal property is not set and the principal
  91  * entry also does not exist, the user is prompted for the name.
  92  * When this property of entry is set, and {@code useTicketCache}
  93  * is set to true, only TGT belonging to this principal is used.
  94  *
  95  * &lt;p&gt; The following is a list of configuration options supported
  96  * for {@code Krb5LoginModule}:
  97  * &lt;blockquote&gt;&lt;dl&gt;
  98  * &lt;dt&gt;{@code refreshKrb5Config}:&lt;/dt&gt;
  99  * &lt;dd&gt; Set this to true, if you want the configuration
 100  * to be refreshed before the {@code login} method is called.&lt;/dd&gt;
 101  * &lt;dt&gt;{@code useTicketCache}:&lt;/dt&gt;
 102  * &lt;dd&gt;Set this to true, if you want the
 103  * TGT to be obtained from the ticket cache. Set this option
 104  * to false if you do not want this module to use the ticket cache.
 105  * (Default is False).
 106  * This module will search for the ticket
 107  * cache in the following locations: On Solaris and Linux
 108  * it will look for the ticket cache in /tmp/krb5cc_{@code uid}
 109  * where the uid is numeric user identifier. If the ticket cache is
 110  * not available in the above location, or if we are on a
 111  * Windows platform, it will look for the cache as
 112  * {user.home}{file.separator}krb5cc_{user.name}.
 113  * You can override the ticket cache location by using
 114  * {@code ticketCache}.
 115  * For Windows, if a ticket cannot be retrieved from the file ticket cache,
 116  * it will use Local Security Authority (LSA) API to get the TGT.
 117  * &lt;dt&gt;{@code ticketCache}:&lt;/dt&gt;
 118  * &lt;dd&gt;Set this to the name of the ticket
 119  * cache that  contains user's TGT.
 120  * If this is set,  {@code useTicketCache}
 121  * must also be set to true; Otherwise a configuration error will
 122  * be returned.&lt;/dd&gt;
 123  * &lt;dt&gt;{@code renewTGT}:&lt;/dt&gt;
 124  * &lt;dd&gt;Set this to true, if you want to renew the TGT when it's more than
 125  * half-way expired (the time until expiration is less than the time
 126  * since start time). If this is set, {@code useTicketCache} must also be
 127  * set to true; otherwise a configuration error will be returned.&lt;/dd&gt;
 128  * &lt;dt&gt;{@code doNotPrompt}:&lt;/dt&gt;
 129  * &lt;dd&gt;Set this to true if you do not want to be
 130  * prompted for the password
 131  * if credentials can not be obtained from the cache, the keytab,
 132  * or through shared state.(Default is false)
 133  * If set to true, credential must be obtained through cache, keytab,
 134  * or shared state. Otherwise, authentication will fail.&lt;/dd&gt;
 135  * &lt;dt&gt;{@code useKeyTab}:&lt;/dt&gt;
 136  * &lt;dd&gt;Set this to true if you
 137  * want the module to get the principal's key from the
 138  * the keytab.(default value is False)
 139  * If {@code keytab} is not set then
 140  * the module will locate the keytab from the
 141  * Kerberos configuration file.
 142  * If it is not specified in the Kerberos configuration file
 143  * then it will look for the file
 144  * {@code {user.home}{file.separator}}krb5.keytab.&lt;/dd&gt;
 145  * &lt;dt&gt;{@code keyTab}:&lt;/dt&gt;
 146  * &lt;dd&gt;Set this to the file name of the
 147  * keytab to get principal's secret key.&lt;/dd&gt;
 148  * &lt;dt&gt;{@code storeKey}:&lt;/dt&gt;
 149  * &lt;dd&gt;Set this to true to if you want the keytab or the
 150  * principal's key to be stored in the Subject's private credentials.
 151  * For {@code isInitiator} being false, if {@code principal}
 152  * is "*", the {@link KeyTab} stored can be used by anyone, otherwise,
 153  * it's restricted to be used by the specified principal only.&lt;/dd&gt;
 154  * &lt;dt&gt;{@code principal}:&lt;/dt&gt;
 155  * &lt;dd&gt;The name of the principal that should
 156  * be used. The principal can be a simple username such as
 157  * "{@code testuser}" or a service name such as
 158  * "{@code host/testhost.eng.sun.com}". You can use the
 159  * {@code principal}  option to set the principal when there are
 160  * credentials for multiple principals in the
 161  * {@code keyTab} or when you want a specific ticket cache only.
 162  * The principal can also be set using the system property
 163  * {@code sun.security.krb5.principal}. In addition, if this
 164  * system property is defined, then it will be used. If this property
 165  * is not set, then the principal name from the configuration will be
 166  * used.
 167  * The principal name can be set to "*" when {@code isInitiator} is false.
 168  * In this case, the acceptor is not bound to a single principal. It can
 169  * act as any principal an initiator requests if keys for that principal
 170  * can be found. When {@code isInitiator} is true, the principal name
 171  * cannot be set to "*".
 172  * &lt;/dd&gt;
 173  * &lt;dt&gt;{@code isInitiator}:&lt;/dt&gt;
 174  * &lt;dd&gt;Set this to true, if initiator. Set this to false, if acceptor only.
 175  * (Default is true).
 176  * Note: Do not set this value to false for initiators.&lt;/dd&gt;
 177  * &lt;/dl&gt;&lt;/blockquote&gt;
 178  *
 179  * &lt;p&gt; This {@code LoginModule} also recognizes the following additional
 180  * {@code Configuration}
 181  * options that enable you to share username and passwords across different
 182  * authentication modules:
 183  * &lt;blockquote&gt;&lt;dl&gt;
 184  *
 185  *    &lt;dt&gt;{@code useFirstPass}:&lt;/dt&gt;
 186  *                   &lt;dd&gt;if, true, this LoginModule retrieves the
 187  *                   username and password from the module's shared state,
 188  *                   using "javax.security.auth.login.name" and
 189  *                   "javax.security.auth.login.password" as the respective
 190  *                   keys. The retrieved values are used for authentication.
 191  *                   If authentication fails, no attempt for a retry
 192  *                   is made, and the failure is reported back to the
 193  *                   calling application.&lt;/dd&gt;
 194  *
 195  *    &lt;dt&gt;{@code tryFirstPass}:&lt;/dt&gt;
 196  *                   &lt;dd&gt;if, true, this LoginModule retrieves the
 197  *                   the username and password from the module's shared
 198  *                   state using "javax.security.auth.login.name" and
 199  *                   "javax.security.auth.login.password" as the respective
 200  *                   keys.  The retrieved values are used for
 201  *                   authentication.
 202  *                   If authentication fails, the module uses the
 203  *                   CallbackHandler to retrieve a new username
 204  *                   and password, and another attempt to authenticate
 205  *                   is made. If the authentication fails,
 206  *                   the failure is reported back to the calling application&lt;/dd&gt;
 207  *
 208  *    &lt;dt&gt;{@code storePass}:&lt;/dt&gt;
 209  *                   &lt;dd&gt;if, true, this LoginModule stores the username and
 210  *                   password obtained from the CallbackHandler in the
 211  *                   modules shared state, using
 212  *                   "javax.security.auth.login.name" and
 213  *                   "javax.security.auth.login.password" as the respective
 214  *                   keys.  This is not performed if existing values already
 215  *                   exist for the username and password in the shared
 216  *                   state, or if authentication fails.&lt;/dd&gt;
 217  *
 218  *    &lt;dt&gt;{@code clearPass}:&lt;/dt&gt;
 219  *                   &lt;dd&gt;if, true, this LoginModule clears the
 220  *                   username and password stored in the module's shared
 221  *                   state  after both phases of authentication
 222  *                   (login and commit) have completed.&lt;/dd&gt;
 223  * &lt;/dl&gt;&lt;/blockquote&gt;
 224  * &lt;p&gt;If the principal system property or key is already provided, the value of
 225  * "javax.security.auth.login.name" in the shared state is ignored.
 226  * &lt;p&gt;When multiple mechanisms to retrieve a ticket or key is provided, the
 227  * preference order is:
 228  * &lt;ol&gt;
 229  * &lt;li&gt;ticket cache
 230  * &lt;li&gt;keytab
 231  * &lt;li&gt;shared state
 232  * &lt;li&gt;user prompt
 233  * &lt;/ol&gt;
 234  *
 235  * &lt;p&gt;Note that if any step fails, it will fallback to the next step.
 236  * There's only one exception, if the shared state step fails and
 237  * {@code useFirstPass = true}, no user prompt is made.
 238  * &lt;p&gt;Examples of some configuration values for Krb5LoginModule in
 239  * JAAS config file and the results are:
 240  * &lt;blockquote&gt;
 241  * &lt;pre&gt;{@code
 242  * doNotPrompt = true}&lt;/pre&gt;
 243  * This is an illegal combination since none of {@code useTicketCache,
 244  * useKeyTab, useFirstPass} and {@code tryFirstPass}
 245  * is set and the user can not be prompted for the password.
 246  *
 247  * &lt;pre&gt;{@code
 248  * ticketCache = &lt;filename&gt;}&lt;/pre&gt;
 249  * This is an illegal combination since {@code useTicketCache}
 250  * is not set to true and the ticketCache is set. A configuration error
 251  * will occur.
 252  *
 253  * &lt;pre&gt;{@code
 254  * renewTGT = true}&lt;/pre&gt;
 255  * This is an illegal combination since {@code useTicketCache} is
 256  * not set to true and renewTGT is set. A configuration error will occur.
 257  *
 258  * &lt;pre&gt;{@code
 259  * storeKey = true  useTicketCache = true  doNotPrompt = true}&lt;/pre&gt;
 260  * This is an illegal combination since  {@code storeKey} is set to
 261  * true but the key can not be obtained either by prompting the user or from
 262  * the keytab, or from the shared state. A configuration error will occur.
 263  *
 264  * &lt;pre&gt;{@code
 265  * keyTab = &lt;filename&gt;  doNotPrompt = true}&lt;/pre&gt;
 266  * This is an illegal combination since useKeyTab is not set to true and
 267  * the keyTab is set. A configuration error will occur.
 268  *
 269  * &lt;pre&gt;{@code
 270  * debug = true}&lt;/pre&gt;
 271  * Prompt the user for the principal name and the password.
 272  * Use the authentication exchange to get TGT from the KDC and
 273  * populate the {@code Subject} with the principal and TGT.
 274  * Output debug messages.
 275  *
 276  * &lt;pre&gt;{@code
 277  * useTicketCache = true  doNotPrompt = true}&lt;/pre&gt;
 278  * Check the default cache for TGT and populate the {@code Subject}
 279  * with the principal and TGT. If the TGT is not available,
 280  * do not prompt the user, instead fail the authentication.
 281  *
 282  * &lt;pre&gt;{@code
 283  * principal = &lt;name&gt;  useTicketCache = true  doNotPrompt = true}&lt;/pre&gt;
 284  * Get the TGT from the default cache for the principal and populate the
 285  * Subject's principal and private creds set. If ticket cache is
 286  * not available or does not contain the principal's TGT
 287  * authentication will fail.
 288  *
 289  * &lt;pre&gt;{@code
 290  * useTicketCache = true
 291  * ticketCache = &lt;file name&gt;
 292  * useKeyTab = true
 293  * keyTab = &lt;keytab filename&gt;
 294  * principal = &lt;principal name&gt;
 295  * doNotPrompt = true}&lt;/pre&gt;
 296  * Search the cache for the principal's TGT. If it is not available
 297  * use the key in the keytab to perform authentication exchange with the
 298  * KDC and acquire the TGT.
 299  * The Subject will be populated with the principal and the TGT.
 300  * If the key is not available or valid then authentication will fail.
 301  *
 302  * &lt;pre&gt;{@code
 303  * useTicketCache = true  ticketCache = &lt;filename&gt;}&lt;/pre&gt;
 304  * The TGT will be obtained from the cache specified.
 305  * The Kerberos principal name used will be the principal name in
 306  * the Ticket cache. If the TGT is not available in the
 307  * ticket cache the user will be prompted for the principal name
 308  * and the password. The TGT will be obtained using the authentication
 309  * exchange with the KDC.
 310  * The Subject will be populated with the TGT.
 311  *
 312  * &lt;pre&gt;{@code
 313  * useKeyTab = true  keyTab=&lt;keytab filename&gt;  principal = &lt;principal name&gt;  storeKey = true}&lt;/pre&gt;
 314  * The key for the principal will be retrieved from the keytab.
 315  * If the key is not available in the keytab the user will be prompted
 316  * for the principal's password. The Subject will be populated
 317  * with the principal's key either from the keytab or derived from the
 318  * password entered.
 319  *
 320  * &lt;pre&gt;{@code
 321  * useKeyTab = true  keyTab = &lt;keytabname&gt;  storeKey = true  doNotPrompt = false}&lt;/pre&gt;
 322  * The user will be prompted for the service principal name.
 323  * If the principal's
 324  * longterm key is available in the keytab , it will be added to the
 325  * Subject's private credentials. An authentication exchange will be
 326  * attempted with the principal name and the key from the Keytab.
 327  * If successful the TGT will be added to the
 328  * Subject's private credentials set. Otherwise the authentication will fail.
 329  *
 330  * &lt;pre&gt;{@code
 331  * isInitiator = false  useKeyTab = true  keyTab = &lt;keytabname&gt;  storeKey = true  principal = *}&lt;/pre&gt;
 332  * The acceptor will be an unbound acceptor and it can act as any principal
 333  * as long that principal has keys in the keytab.
 334  *
 335  * &lt;pre&gt;{@code
 336  * useTicketCache = true
 337  * ticketCache = &lt;file name&gt;
 338  * useKeyTab = true
 339  * keyTab = &lt;file name&gt;
 340  * storeKey = true
 341  * principal = &lt;principal name&gt;}&lt;/pre&gt;
 342  * The client's TGT will be retrieved from the ticket cache and added to the
 343  * {@code Subject}'s private credentials. If the TGT is not available
 344  * in the ticket cache, or the TGT's client name does not match the principal
 345  * name, Java will use a secret key to obtain the TGT using the authentication
 346  * exchange and added to the Subject's private credentials.
 347  * This secret key will be first retrieved from the keytab. If the key
 348  * is not available, the user will be prompted for the password. In either
 349  * case, the key derived from the password will be added to the
 350  * Subject's private credentials set.
 351  *
 352  * &lt;pre&gt;{@code
 353  * isInitiator = false}&lt;/pre&gt;
 354  * Configured to act as acceptor only, credentials are not acquired
 355  * via AS exchange. For acceptors only, set this value to false.
 356  * For initiators, do not set this value to false.
 357  *
 358  * &lt;pre&gt;{@code
 359  * isInitiator = true}&lt;/pre&gt;
 360  * Configured to act as initiator, credentials are acquired
 361  * via AS exchange. For initiators, set this value to true, or leave this
 362  * option unset, in which case default value (true) will be used.
 363  *
 364  * &lt;/blockquote&gt;
 365  *
 366  * @author Ram Marti
 367  */
 368 
 369 public class Krb5LoginModule implements LoginModule {
 370 
 371     // initial state
 372     private Subject subject;
 373     private CallbackHandler callbackHandler;
 374     private Map&lt;String, Object&gt; sharedState;
 375     private Map&lt;String, ?&gt; options;
 376 
 377     // configurable option
 378     private boolean debug = false;
 379     private boolean storeKey = false;
 380     private boolean doNotPrompt = false;
 381     private boolean useTicketCache = false;
 382     private boolean useKeyTab = false;
 383     private String ticketCacheName = null;
 384     private String keyTabName = null;
 385     private String princName = null;
 386 
 387     private boolean useFirstPass = false;
 388     private boolean tryFirstPass = false;
 389     private boolean storePass = false;
 390     private boolean clearPass = false;
 391     private boolean refreshKrb5Config = false;
 392     private boolean renewTGT = false;
 393 
 394     // specify if initiator.
 395     // perform authentication exchange if initiator
 396     private boolean isInitiator = true;
 397 
 398     // the authentication status
 399     private boolean succeeded = false;
 400     private boolean commitSucceeded = false;
 401     private String username;
 402 
 403     // Encryption keys calculated from password. Assigned when storekey == true
 404     // and useKeyTab == false (or true but not found)
 405     private EncryptionKey[] encKeys = null;
 406 
 407     KeyTab ktab = null;
 408 
 409     private Credentials cred = null;
 410 
 411     private PrincipalName principal = null;
<a name="2" id="anc2"></a><span class="removed"> 412     private KerberosPrincipal kerbClientPrinc = null;</span>
 413     private KerberosTicket kerbTicket = null;
 414     private KerberosKey[] kerbKeys = null;
 415     private StringBuffer krb5PrincName = null;
 416     private boolean unboundServer = false;
 417     private char[] password = null;
 418 
 419     private static final String NAME = "javax.security.auth.login.name";
 420     private static final String PWD = "javax.security.auth.login.password";
 421 
 422     /**
 423      * Initialize this {@code LoginModule}.
 424      *
 425      * @param subject the {@code Subject} to be authenticated.
 426      *
 427      * @param callbackHandler a {@code CallbackHandler} for
 428      *                  communication with the end user (prompting for
 429      *                  usernames and passwords, for example).
 430      *
 431      * @param sharedState shared {@code LoginModule} state.
 432      *
 433      * @param options options specified in the login
 434      *                  {@code Configuration} for this particular
 435      *                  {@code LoginModule}.
 436      */
 437     // Unchecked warning from (Map&lt;String, Object&gt;)sharedState is safe
 438     // since javax.security.auth.login.LoginContext passes a raw HashMap.
 439     // Unchecked warnings from options.get(String) are safe since we are
 440     // passing known keys.
 441     @SuppressWarnings("unchecked")
 442     public void initialize(Subject subject,
 443                            CallbackHandler callbackHandler,
 444                            Map&lt;String, ?&gt; sharedState,
 445                            Map&lt;String, ?&gt; options) {
 446 
 447         this.subject = subject;
 448         this.callbackHandler = callbackHandler;
 449         this.sharedState = (Map&lt;String, Object&gt;)sharedState;
 450         this.options = options;
 451 
 452         // initialize any configured options
 453 
 454         debug = "true".equalsIgnoreCase((String)options.get("debug"));
 455         storeKey = "true".equalsIgnoreCase((String)options.get("storeKey"));
 456         doNotPrompt = "true".equalsIgnoreCase((String)options.get
 457                                               ("doNotPrompt"));
 458         useTicketCache = "true".equalsIgnoreCase((String)options.get
 459                                                  ("useTicketCache"));
 460         useKeyTab = "true".equalsIgnoreCase((String)options.get("useKeyTab"));
 461         ticketCacheName = (String)options.get("ticketCache");
 462         keyTabName = (String)options.get("keyTab");
 463         if (keyTabName != null) {
 464             keyTabName = sun.security.krb5.internal.ktab.KeyTab.normalize(
 465                          keyTabName);
 466         }
 467         princName = (String)options.get("principal");
 468         refreshKrb5Config =
 469             "true".equalsIgnoreCase((String)options.get("refreshKrb5Config"));
 470         renewTGT =
 471             "true".equalsIgnoreCase((String)options.get("renewTGT"));
 472 
 473         // check isInitiator value
 474         String isInitiatorValue = ((String)options.get("isInitiator"));
 475         if (isInitiatorValue == null) {
 476             // use default, if value not set
 477         } else {
 478             isInitiator = "true".equalsIgnoreCase(isInitiatorValue);
 479         }
 480 
 481         tryFirstPass =
 482             "true".equalsIgnoreCase
 483             ((String)options.get("tryFirstPass"));
 484         useFirstPass =
 485             "true".equalsIgnoreCase
 486             ((String)options.get("useFirstPass"));
 487         storePass =
 488             "true".equalsIgnoreCase((String)options.get("storePass"));
 489         clearPass =
 490             "true".equalsIgnoreCase((String)options.get("clearPass"));
 491         if (debug) {
 492             System.out.print("Debug is  " + debug
 493                              + " storeKey " + storeKey
 494                              + " useTicketCache " + useTicketCache
 495                              + " useKeyTab " + useKeyTab
 496                              + " doNotPrompt " + doNotPrompt
 497                              + " ticketCache is " + ticketCacheName
 498                              + " isInitiator " + isInitiator
 499                              + " KeyTab is " + keyTabName
 500                              + " refreshKrb5Config is " + refreshKrb5Config
 501                              + " principal is " + princName
 502                              + " tryFirstPass is " + tryFirstPass
 503                              + " useFirstPass is " + useFirstPass
 504                              + " storePass is " + storePass
 505                              + " clearPass is " + clearPass + "\n");
 506         }
 507     }
 508 
 509 
 510     /**
 511      * Authenticate the user
 512      *
 513      * @return true in all cases since this {@code LoginModule}
 514      *          should not be ignored.
 515      *
 516      * @exception FailedLoginException if the authentication fails.
 517      *
 518      * @exception LoginException if this {@code LoginModule}
 519      *          is unable to perform the authentication.
 520      */
 521     public boolean login() throws LoginException {
 522 
<a name="3" id="anc3"></a>









 523         if (refreshKrb5Config) {
 524             try {
 525                 if (debug) {
 526                     System.out.println("Refreshing Kerberos configuration");
 527                 }
 528                 sun.security.krb5.Config.refresh();
 529             } catch (KrbException ke) {
 530                 LoginException le = new LoginException(ke.getMessage());
 531                 le.initCause(ke);
 532                 throw le;
 533             }
 534         }
<a name="4" id="anc4"></a>











 535         String principalProperty = System.getProperty
 536             ("sun.security.krb5.principal");
 537         if (principalProperty != null) {
 538             krb5PrincName = new StringBuffer(principalProperty);
<a name="5" id="anc5"></a><span class="changed"> 539         } else {</span>
<span class="changed"> 540             if (princName != null) {</span>
 541                 krb5PrincName = new StringBuffer(princName);
 542             }
<a name="6" id="anc6"></a><span class="removed"> 543         }</span>
 544 
<a name="7" id="anc7"></a>
 545         validateConfiguration();
 546 
<a name="8" id="anc8"></a>
 547         if (krb5PrincName != null &amp;&amp; krb5PrincName.toString().equals("*")) {
 548             unboundServer = true;
 549         }
 550 
 551         if (tryFirstPass) {
 552             try {
 553                 attemptAuthentication(true);
 554                 if (debug)
 555                     System.out.println("\t\t[Krb5LoginModule] " +
 556                                        "authentication succeeded");
 557                 succeeded = true;
 558                 cleanState();
 559                 return true;
 560             } catch (LoginException le) {
 561                 // authentication failed -- try again below by prompting
 562                 cleanState();
 563                 if (debug) {
 564                     System.out.println("\t\t[Krb5LoginModule] " +
 565                                        "tryFirstPass failed with:" +
 566                                        le.getMessage());
 567                 }
 568             }
 569         } else if (useFirstPass) {
 570             try {
 571                 attemptAuthentication(true);
 572                 succeeded = true;
 573                 cleanState();
 574                 return true;
 575             } catch (LoginException e) {
 576                 // authentication failed -- clean out state
 577                 if (debug) {
 578                     System.out.println("\t\t[Krb5LoginModule] " +
 579                                        "authentication failed \n" +
 580                                        e.getMessage());
 581                 }
 582                 succeeded = false;
 583                 cleanState();
 584                 throw e;
 585             }
 586         }
 587 
 588         // attempt the authentication by getting the username and pwd
 589         // by prompting or configuration i.e. not from shared state
 590 
 591         try {
 592             attemptAuthentication(false);
 593             succeeded = true;
 594             cleanState();
 595             return true;
 596         } catch (LoginException e) {
 597             // authentication failed -- clean out state
 598             if (debug) {
 599                 System.out.println("\t\t[Krb5LoginModule] " +
 600                                    "authentication failed \n" +
 601                                    e.getMessage());
 602             }
 603             succeeded = false;
 604             cleanState();
 605             throw e;
 606         }
 607     }
 608     /**
 609      * process the configuration options
 610      * Get the TGT either out of
 611      * cache or from the KDC using the password entered
 612      * Check the  permission before getting the TGT
 613      */
 614 
 615     private void attemptAuthentication(boolean getPasswdFromSharedState)
 616         throws LoginException {
 617 
 618         /*
 619          * Check the creds cache to see whether
 620          * we have TGT for this client principal
 621          */
 622         if (krb5PrincName != null) {
 623             try {
 624                 principal = new PrincipalName
 625                     (krb5PrincName.toString(),
 626                      PrincipalName.KRB_NT_PRINCIPAL);
 627             } catch (KrbException e) {
 628                 LoginException le = new LoginException(e.getMessage());
 629                 le.initCause(e);
 630                 throw le;
 631             }
 632         }
 633 
 634         try {
<a name="9" id="anc9"></a>
 635             if (useTicketCache) {
<a name="10" id="anc10"></a><span class="removed"> 636                 // ticketCacheName == null implies the default cache</span>
 637                 if (debug)
<a name="11" id="anc11"></a><span class="changed"> 638                     System.out.println("Acquire TGT from Cache");</span>
<span class="changed"> 639                 cred  = Credentials.acquireTGTFromCache</span>
<span class="changed"> 640                     (principal, ticketCacheName);</span>
<span class="changed"> 641 </span>
 642                 if (cred != null) {
<a name="12" id="anc12"></a><span class="changed"> 643                     if (renewTGT &amp;&amp; isOld(cred)) {</span>
<span class="changed"> 644                         // renew if ticket is old.</span>
<span class="changed"> 645                         Credentials newCred = renewCredentials(cred);</span>
<span class="changed"> 646                         if (newCred != null) {</span>
<span class="changed"> 647                             newCred.setProxy(cred.getProxy());</span>
<span class="changed"> 648                             cred = newCred;</span>
<span class="changed"> 649                         }</span>
<span class="changed"> 650                     }</span>
 651                     if (!isCurrent(cred)) {
<a name="13" id="anc13"></a><span class="removed"> 652                         // credentials have expired</span>
 653                         cred = null;
 654                         if (debug)
<a name="14" id="anc14"></a><span class="changed"> 655                             System.out.println("Credentials are" +</span>
<span class="changed"> 656                                     " no longer valid");</span>
<span class="changed"> 657                     }</span>
<span class="changed"> 658                 }</span>
<span class="changed"> 659 </span>
<span class="changed"> 660                 if (cred != null) {</span>
<span class="changed"> 661                    // get the principal name from the ticket cache</span>
<span class="changed"> 662                    if (principal == null) {</span>
<span class="changed"> 663                         principal = cred.getClient();</span>
<span class="changed"> 664                    }</span>
<span class="changed"> 665                 }</span>
<span class="changed"> 666                 if (debug) {</span>
<span class="changed"> 667                     System.out.println("Principal is " + principal);</span>
<span class="changed"> 668                     if (cred == null) {</span>
<span class="changed"> 669                         System.out.println</span>
<span class="changed"> 670                             ("null credentials from Ticket Cache");</span>
 671                     }
<a name="15" id="anc15"></a>

 672                 }
 673             }
 674 
<a name="16" id="anc16"></a><span class="removed"> 675             // cred = null indicates that we didn't get the creds</span>
<span class="removed"> 676             // from the cache or useTicketCache was false</span>
<span class="removed"> 677 </span>
 678             if (cred == null) {
<a name="17" id="anc17"></a><span class="changed"> 679                 // We need the principal name whether we use keytab</span>
<span class="changed"> 680                 // or AS Exchange</span>
 681                 if (principal == null) {
 682                     promptForName(getPasswdFromSharedState);
 683                     principal = new PrincipalName
 684                         (krb5PrincName.toString(),
 685                          PrincipalName.KRB_NT_PRINCIPAL);
 686                 }
 687 
<a name="18" id="anc18"></a><span class="removed"> 688                 /*</span>
<span class="removed"> 689                  * Before dynamic KeyTab support (6894072), here we check if</span>
<span class="removed"> 690                  * the keytab contains keys for the principal. If no, keytab</span>
<span class="removed"> 691                  * will not be used and password is prompted for.</span>
<span class="removed"> 692                  *</span>
<span class="removed"> 693                  * After 6894072, we normally don't check it, and expect the</span>
<span class="removed"> 694                  * keys can be populated until a real connection is made. The</span>
<span class="removed"> 695                  * check is still done when isInitiator == true, where the keys</span>
<span class="removed"> 696                  * will be used right now.</span>
<span class="removed"> 697                  *</span>
<span class="removed"> 698                  * Probably tricky relations:</span>
<span class="removed"> 699                  *</span>
<span class="removed"> 700                  * useKeyTab is config flag, but when it's true but the ktab</span>
<span class="removed"> 701                  * does not contains keys for principal, we would use password</span>
<span class="removed"> 702                  * and keep the flag unchanged (for reuse?). In this method,</span>
<span class="removed"> 703                  * we use (ktab != null) to check whether keytab is used.</span>
<span class="removed"> 704                  * After this method (and when storeKey == true), we use</span>
<span class="removed"> 705                  * (encKeys == null) to check.</span>
<span class="removed"> 706                  */</span>
 707                 if (useKeyTab) {
<a name="19" id="anc19"></a><span class="changed"> 708                     if (!unboundServer) {</span>
<span class="changed"> 709                         KerberosPrincipal kp =</span>
<span class="changed"> 710                                 new KerberosPrincipal(principal.getName());</span>
<span class="changed"> 711                         ktab = (keyTabName == null)</span>
<span class="changed"> 712                                 ? KeyTab.getInstance(kp)</span>
<span class="changed"> 713                                 : KeyTab.getInstance(kp, new File(keyTabName));</span>
<span class="changed"> 714                     } else {</span>
<span class="changed"> 715                         ktab = (keyTabName == null)</span>
<span class="changed"> 716                                 ? KeyTab.getUnboundInstance()</span>
<span class="changed"> 717                                 : KeyTab.getUnboundInstance(new File(keyTabName));</span>
<span class="changed"> 718                     }</span>
<span class="changed"> 719                     if (isInitiator) {</span>
<span class="changed"> 720                         if (Krb5Util.keysFromJavaxKeyTab(ktab, principal).length</span>
 721                                 == 0) {
 722                             ktab = null;
 723                             if (debug) {
 724                                 System.out.println
 725                                     ("Key for the principal " +
 726                                      principal  +
 727                                      " not available in " +
 728                                      ((keyTabName == null) ?
 729                                       "default key tab" : keyTabName));
 730                             }
 731                         }
 732                     }
<a name="20" id="anc20"></a><span class="removed"> 733                 }</span>
 734 
 735                 KrbAsReqBuilder builder;
 736 
 737                 if (ktab == null) {
 738                     promptForPass(getPasswdFromSharedState);
 739                     builder = new KrbAsReqBuilder(principal, password);
<a name="21" id="anc21"></a><span class="changed"> 740                     if (isInitiator) {</span>
<span class="changed"> 741                         // XXX Even if isInitiator=false, it might be</span>
<span class="changed"> 742                         // better to do an AS-REQ so that keys can be</span>
<span class="changed"> 743                         // updated with PA info</span>





 744                         cred = builder.action().getCreds();
<a name="22" id="anc22"></a><span class="removed"> 745                     }</span>
 746                     if (storeKey) {
 747                         encKeys = builder.getKeys(isInitiator);
 748                         // When encKeys is empty, the login actually fails.
 749                         // For compatibility, exception is thrown in commit().
 750                     }
<a name="23" id="anc23"></a>
 751                 } else {
 752                     builder = new KrbAsReqBuilder(principal, ktab);
 753                     if (isInitiator) {
 754                         cred = builder.action().getCreds();
 755                     }
 756                 }
 757                 builder.destroy();
 758 
 759                 if (debug) {
 760                     System.out.println("principal is " + principal);
 761                     HexDumpEncoder hd = new HexDumpEncoder();
 762                     if (ktab != null) {
 763                         System.out.println("Will use keytab");
 764                     } else if (storeKey) {
 765                         for (int i = 0; i &lt; encKeys.length; i++) {
<a name="24" id="anc24"></a>


 766                             System.out.println("EncryptionKey: keyType=" +
<a name="25" id="anc25"></a><span class="changed"> 767                                 encKeys[i].getEType() +</span>
<span class="changed"> 768                                 " keyBytes (hex dump)=" +</span>
<span class="changed"> 769                                 hd.encodeBuffer(encKeys[i].getBytes()));</span>
 770                         }
 771                     }
 772                 }
 773 
<a name="26" id="anc26"></a><span class="removed"> 774                 // we should hava a non-null cred</span>
 775                 if (isInitiator &amp;&amp; (cred == null)) {
 776                     throw new LoginException
 777                         ("TGT Can not be obtained from the KDC ");
 778                 }
 779 
 780             }
 781         } catch (KrbException e) {
 782             LoginException le = new LoginException(e.getMessage());
 783             le.initCause(e);
 784             throw le;
 785         } catch (IOException ioe) {
 786             LoginException ie = new LoginException(ioe.getMessage());
 787             ie.initCause(ioe);
 788             throw ie;
 789         }
 790     }
 791 
 792     private void promptForName(boolean getPasswdFromSharedState)
 793         throws LoginException {
 794         krb5PrincName = new StringBuffer("");
 795         if (getPasswdFromSharedState) {
 796             // use the name saved by the first module in the stack
 797             username = (String)sharedState.get(NAME);
 798             if (debug) {
 799                 System.out.println
 800                     ("username from shared state is " + username + "\n");
 801             }
 802             if (username == null) {
 803                 System.out.println
 804                     ("username from shared state is null\n");
 805                 throw new LoginException
 806                     ("Username can not be obtained from sharedstate ");
 807             }
 808             if (debug) {
 809                 System.out.println
 810                     ("username from shared state is " + username + "\n");
 811             }
 812             if (username != null &amp;&amp; username.length() &gt; 0) {
 813                 krb5PrincName.insert(0, username);
 814                 return;
 815             }
 816         }
 817 
 818         if (doNotPrompt) {
 819             throw new LoginException
 820                 ("Unable to obtain Principal Name for authentication ");
 821         } else {
 822             if (callbackHandler == null)
 823                 throw new LoginException("No CallbackHandler "
 824                                          + "available "
 825                                          + "to garner authentication "
 826                                          + "information from the user");
 827             try {
 828                 String defUsername = System.getProperty("user.name");
 829 
 830                 Callback[] callbacks = new Callback[1];
 831                 MessageFormat form = new MessageFormat(
 832                                        getAuthResourceString(
 833                                        "Kerberos.username.defUsername."));
 834                 Object[] source =  {defUsername};
 835                 callbacks[0] = new NameCallback(form.format(source));
 836                 callbackHandler.handle(callbacks);
 837                 username = ((NameCallback)callbacks[0]).getName();
 838                 if (username == null || username.length() == 0)
 839                     username = defUsername;
 840                 krb5PrincName.insert(0, username);
 841 
 842             } catch (java.io.IOException ioe) {
 843                 throw new LoginException(ioe.getMessage());
 844             } catch (UnsupportedCallbackException uce) {
 845                 throw new LoginException
 846                     (uce.getMessage()
 847                      +" not available to garner "
 848                      +" authentication information "
 849                      +" from the user");
 850             }
 851         }
 852     }
 853 
 854     private void promptForPass(boolean getPasswdFromSharedState)
 855         throws LoginException {
 856 
 857         if (getPasswdFromSharedState) {
 858             // use the password saved by the first module in the stack
 859             password = (char[])sharedState.get(PWD);
 860             if (password == null) {
 861                 if (debug) {
 862                     System.out.println
 863                         ("Password from shared state is null");
 864                 }
 865                 throw new LoginException
 866                     ("Password can not be obtained from sharedstate ");
 867             }
 868             if (debug) {
 869                 System.out.println
 870                     ("password is " + new String(password));
 871             }
 872             return;
 873         }
 874         if (doNotPrompt) {
 875             throw new LoginException
 876                 ("Unable to obtain password from user\n");
 877         } else {
 878             if (callbackHandler == null)
 879                 throw new LoginException("No CallbackHandler "
 880                                          + "available "
 881                                          + "to garner authentication "
 882                                          + "information from the user");
 883             try {
 884                 Callback[] callbacks = new Callback[1];
 885                 String userName = krb5PrincName.toString();
 886                 MessageFormat form = new MessageFormat(
 887                                          getAuthResourceString(
 888                                          "Kerberos.password.for.username."));
 889                 Object[] source = {userName};
 890                 callbacks[0] = new PasswordCallback(
 891                                                     form.format(source),
 892                                                     false);
 893                 callbackHandler.handle(callbacks);
 894                 char[] tmpPassword = ((PasswordCallback)
 895                                       callbacks[0]).getPassword();
 896                 if (tmpPassword == null) {
 897                     throw new LoginException("No password provided");
 898                 }
 899                 password = new char[tmpPassword.length];
 900                 System.arraycopy(tmpPassword, 0,
 901                                  password, 0, tmpPassword.length);
 902                 ((PasswordCallback)callbacks[0]).clearPassword();
 903 
 904 
 905                 // clear tmpPassword
 906                 for (int i = 0; i &lt; tmpPassword.length; i++)
 907                     tmpPassword[i] = ' ';
 908                 tmpPassword = null;
 909                 if (debug) {
 910                     System.out.println("\t\t[Krb5LoginModule] " +
 911                                        "user entered username: " +
 912                                        krb5PrincName);
 913                     System.out.println();
 914                 }
 915             } catch (java.io.IOException ioe) {
 916                 throw new LoginException(ioe.getMessage());
 917             } catch (UnsupportedCallbackException uce) {
 918                 throw new LoginException(uce.getMessage()
 919                                          +" not available to garner "
 920                                          +" authentication information "
 921                                          + "from the user");
 922             }
 923         }
 924     }
 925 
 926     private void validateConfiguration() throws LoginException {
 927         if (doNotPrompt &amp;&amp; !useTicketCache &amp;&amp; !useKeyTab
 928                 &amp;&amp; !tryFirstPass &amp;&amp; !useFirstPass)
 929             throw new LoginException
 930                 ("Configuration Error"
 931                  + " - either doNotPrompt should be "
 932                  + " false or at least one of useTicketCache, "
 933                  + " useKeyTab, tryFirstPass and useFirstPass"
 934                  + " should be true");
 935         if (ticketCacheName != null &amp;&amp; !useTicketCache)
 936             throw new LoginException
 937                 ("Configuration Error "
 938                  + " - useTicketCache should be set "
 939                  + "to true to use the ticket cache"
 940                  + ticketCacheName);
 941         if (keyTabName != null &amp; !useKeyTab)
 942             throw new LoginException
 943                 ("Configuration Error - useKeyTab should be set to true "
 944                  + "to use the keytab" + keyTabName);
 945         if (storeKey &amp;&amp; doNotPrompt &amp;&amp; !useKeyTab
 946                 &amp;&amp; !tryFirstPass &amp;&amp; !useFirstPass)
 947             throw new LoginException
 948                 ("Configuration Error - either doNotPrompt should be set to "
 949                  + " false or at least one of tryFirstPass, useFirstPass "
 950                  + "or useKeyTab must be set to true for storeKey option");
 951         if (renewTGT &amp;&amp; !useTicketCache)
 952             throw new LoginException
 953                 ("Configuration Error"
 954                  + " - either useTicketCache should be "
 955                  + " true or renewTGT should be false");
 956         if (krb5PrincName != null &amp;&amp; krb5PrincName.toString().equals("*")) {
 957             if (isInitiator) {
 958                 throw new LoginException
 959                     ("Configuration Error"
 960                     + " - principal cannot be * when isInitiator is true");
 961             }
 962         }
 963     }
 964 
<a name="27" id="anc27"></a>






















 965     private static boolean isCurrent(Credentials creds)
 966     {
 967         Date endTime = creds.getEndTime();
 968         if (endTime != null) {
 969             return (System.currentTimeMillis() &lt;= endTime.getTime());
 970         }
 971         return true;
 972     }
 973 
<a name="28" id="anc28"></a><span class="changed"> 974     private static boolean isOld(Credentials creds)</span>
 975     {
<a name="29" id="anc29"></a>


 976         Date endTime = creds.getEndTime();
<a name="30" id="anc30"></a><span class="changed"> 977         if (endTime != null) {</span>
<span class="changed"> 978             Date authTime = creds.getAuthTime();</span>


















 979             long now = System.currentTimeMillis();
<a name="31" id="anc31"></a><span class="changed"> 980             if (authTime != null) {</span>
<span class="changed"> 981                 // pass the mid between auth and end</span>
<span class="changed"> 982                 return now - authTime.getTime() &gt; endTime.getTime() - now;</span>
<span class="changed"> 983             } else {</span>
<span class="changed"> 984                 // will expire in less than 2 hours</span>
 985                 return now &lt;= endTime.getTime() - 1000*3600*2L;
 986             }
<a name="32" id="anc32"></a><span class="removed"> 987         }</span>
<span class="removed"> 988         return false;</span>
<span class="removed"> 989     }</span>
 990 
<a name="33" id="anc33"></a><span class="changed"> 991     private Credentials renewCredentials(Credentials creds)</span>

 992     {
<a name="34" id="anc34"></a><span class="removed"> 993         Credentials lcreds;</span>
<span class="removed"> 994         try {</span>
 995             if (!creds.isRenewable())
<a name="35" id="anc35"></a><span class="removed"> 996                 throw new RefreshFailedException("This ticket" +</span>
<span class="removed"> 997                                 " is not renewable");</span>
<span class="removed"> 998             if (creds.getRenewTill() == null) {</span>
<span class="removed"> 999                 // Renewable ticket without renew-till. Illegal and ignored.</span>
1000                 return creds;
<a name="36" id="anc36"></a><span class="changed">1001             }</span>
1002             if (System.currentTimeMillis() &gt; cred.getRenewTill().getTime())
<a name="37" id="anc37"></a><span class="changed">1003                 throw new RefreshFailedException("This ticket is past "</span>
<span class="changed">1004                                              + "its last renewal time.");</span>
<span class="changed">1005             lcreds = creds.renew();</span>

1006             if (debug)
1007                 System.out.println("Renewed Kerberos Ticket");
1008         } catch (Exception e) {
<a name="38" id="anc38"></a><span class="removed">1009             lcreds = null;</span>
1010             if (debug)
1011                 System.out.println("Ticket could not be renewed : "
1012                                 + e.getMessage());
1013         }
<a name="39" id="anc39"></a><span class="changed">1014         return lcreds;</span>
1015     }
1016 
1017     /**
1018      * This method is called if the LoginContext's
1019      * overall authentication succeeded
1020      * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL
1021      * LoginModules succeeded).
1022      *
1023      * &lt;p&gt; If this LoginModule's own authentication attempt
1024      * succeeded (checked by retrieving the private state saved by the
1025      * {@code login} method), then this method associates a
1026      * {@code Krb5Principal}
1027      * with the {@code Subject} located in the
1028      * {@code LoginModule}. It adds Kerberos Credentials to the
1029      *  the Subject's private credentials set. If this LoginModule's own
1030      * authentication attempted failed, then this method removes
1031      * any state that was originally saved.
1032      *
1033      * @exception LoginException if the commit fails.
1034      *
1035      * @return true if this LoginModule's own login and commit
1036      *          attempts succeeded, or false otherwise.
1037      */
1038 
1039     public boolean commit() throws LoginException {
<a name="40" id="anc40"></a><span class="removed">1040 </span>
1041         /*
1042          * Let us add the Krb5 Creds to the Subject's
1043          * private credentials. The credentials are of type
1044          * KerberosKey or KerberosTicket
1045          */
1046         if (succeeded == false) {
<a name="41" id="anc41"></a>
1047             return false;
<a name="42" id="anc42"></a><span class="changed">1048         } else {</span>
1049 
1050             if (isInitiator &amp;&amp; (cred == null)) {
<a name="43" id="anc43"></a>
1051                 succeeded = false;
1052                 throw new LoginException("Null Client Credential");
1053             }
1054 
1055             if (subject.isReadOnly()) {
1056                 cleanKerberosCred();
<a name="44" id="anc44"></a>
1057                 throw new LoginException("Subject is Readonly");
1058             }
1059 
<a name="45" id="anc45"></a><span class="changed">1060             /*</span>
<span class="changed">1061              * Add the Principal (authenticated identity)</span>
<span class="changed">1062              * to the Subject's principal set and</span>
<span class="changed">1063              * add the credentials (TGT or Service key) to the</span>
<span class="changed">1064              * Subject's private credentials</span>





















1065              */
<a name="46" id="anc46"></a>


1066 
<a name="47" id="anc47"></a><span class="changed">1067             Set&lt;Object&gt; privCredSet =  subject.getPrivateCredentials();</span>
<span class="changed">1068             Set&lt;java.security.Principal&gt; princSet  = subject.getPrincipals();</span>
<span class="changed">1069             kerbClientPrinc = new KerberosPrincipal(principal.getName());</span>
1070 
1071             // create Kerberos Ticket
1072             if (isInitiator) {
1073                 kerbTicket = Krb5Util.credsToTicket(cred);
1074                 if (cred.getProxy() != null) {
1075                     KerberosSecrets.getJavaxSecurityAuthKerberosAccess()
1076                             .kerberosTicketSetProxy(kerbTicket,Krb5Util.credsToTicket(cred.getProxy()));
1077                 }
1078             }
<a name="48" id="anc48"></a>





1079 
<a name="49" id="anc49"></a><span class="changed">1080             if (storeKey &amp;&amp; encKeys != null) {</span>
<span class="changed">1081                 if (encKeys.length == 0) {</span>
<span class="changed">1082                     succeeded = false;</span>
<span class="changed">1083                     throw new LoginException("Null Server Key ");</span>








1084                 }
1085 
<a name="50" id="anc50"></a><span class="changed">1086                 kerbKeys = new KerberosKey[encKeys.length];</span>
















1087                 for (int i = 0; i &lt; encKeys.length; i ++) {
1088                     Integer temp = encKeys[i].getKeyVersionNumber();
<a name="51" id="anc51"></a><span class="changed">1089                     kerbKeys[i] = new KerberosKey(kerbClientPrinc,</span>
1090                                           encKeys[i].getBytes(),
1091                                           encKeys[i].getEType(),
1092                                           (temp == null?
1093                                           0: temp.intValue()));
<a name="52" id="anc52"></a>

1094                 }
<a name="53" id="anc53"></a><span class="removed">1095 </span>
<span class="removed">1096             }</span>
<span class="removed">1097             // Let us add the kerbClientPrinc,kerbTicket and KeyTab/KerbKey (if</span>
<span class="removed">1098             // storeKey is true)</span>
<span class="removed">1099 </span>
<span class="removed">1100             // We won't add "*" as a KerberosPrincipal</span>
<span class="removed">1101             if (!unboundServer &amp;&amp;</span>
<span class="removed">1102                     !princSet.contains(kerbClientPrinc)) {</span>
<span class="removed">1103                 princSet.add(kerbClientPrinc);</span>
<span class="removed">1104             }</span>
<span class="removed">1105 </span>
<span class="removed">1106             // add the TGT</span>
<span class="removed">1107             if (kerbTicket != null) {</span>
<span class="removed">1108                 if (!privCredSet.contains(kerbTicket))</span>
<span class="removed">1109                     privCredSet.add(kerbTicket);</span>
<span class="removed">1110             }</span>
<span class="removed">1111 </span>
<span class="removed">1112             if (storeKey) {</span>
<span class="removed">1113                 if (encKeys == null) {</span>
<span class="removed">1114                     if (ktab != null) {</span>
<span class="removed">1115                         if (!privCredSet.contains(ktab)) {</span>
<span class="removed">1116                             privCredSet.add(ktab);</span>
<span class="removed">1117                         }</span>
<span class="removed">1118                     } else {</span>
<span class="removed">1119                         succeeded = false;</span>
<span class="removed">1120                         throw new LoginException("No key to store");</span>
<span class="removed">1121                     }</span>
<span class="removed">1122                 } else {</span>
<span class="removed">1123                     for (int i = 0; i &lt; kerbKeys.length; i ++) {</span>
<span class="removed">1124                         if (!privCredSet.contains(kerbKeys[i])) {</span>
<span class="removed">1125                             privCredSet.add(kerbKeys[i]);</span>
<span class="removed">1126                         }</span>
<span class="removed">1127                         encKeys[i].destroy();</span>
<span class="removed">1128                         encKeys[i] = null;</span>
<span class="removed">1129                         if (debug) {</span>
<span class="removed">1130                             System.out.println("Added server's key"</span>
<span class="removed">1131                                             + kerbKeys[i]);</span>
<span class="removed">1132                             System.out.println("\t\t[Krb5LoginModule] " +</span>
<span class="removed">1133                                            "added Krb5Principal  " +</span>
<span class="removed">1134                                            kerbClientPrinc.toString()</span>
<span class="removed">1135                                            + " to Subject");</span>
<span class="removed">1136                         }</span>
<span class="removed">1137                     }</span>
<span class="removed">1138                 }</span>
<span class="removed">1139             }</span>
<span class="removed">1140         }</span>
<span class="removed">1141         commitSucceeded = true;</span>
<span class="removed">1142         if (debug)</span>
<span class="removed">1143             System.out.println("Commit Succeeded \n");</span>
<span class="removed">1144         return true;</span>
1145     }
1146 
1147     /**
1148      * This method is called if the LoginContext's
1149      * overall authentication failed.
1150      * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL
1151      * LoginModules did not succeed).
1152      *
1153      * &lt;p&gt; If this LoginModule's own authentication attempt
1154      * succeeded (checked by retrieving the private state saved by the
1155      * {@code login} and {@code commit} methods),
1156      * then this method cleans up any state that was originally saved.
1157      *
1158      * @exception LoginException if the abort fails.
1159      *
1160      * @return false if this LoginModule's own login and/or commit attempts
1161      *          failed, and true otherwise.
1162      */
1163 
1164     public boolean abort() throws LoginException {
1165         if (succeeded == false) {
1166             return false;
1167         } else if (succeeded == true &amp;&amp; commitSucceeded == false) {
1168             // login succeeded but overall authentication failed
1169             succeeded = false;
1170             cleanKerberosCred();
1171         } else {
1172             // overall authentication succeeded and commit succeeded,
1173             // but someone else's commit failed
1174             logout();
1175         }
1176         return true;
1177     }
1178 
1179     /**
1180      * Logout the user.
1181      *
1182      * &lt;p&gt; This method removes the {@code Krb5Principal}
1183      * that was added by the {@code commit} method.
1184      *
1185      * @exception LoginException if the logout fails.
1186      *
1187      * @return true in all cases since this {@code LoginModule}
1188      *          should not be ignored.
1189      */
1190     public boolean logout() throws LoginException {
1191 
1192         if (debug) {
1193             System.out.println("\t\t[Krb5LoginModule]: " +
1194                 "Entering logout");
1195         }
1196 
1197         if (subject.isReadOnly()) {
1198             cleanKerberosCred();
1199             throw new LoginException("Subject is Readonly");
1200         }
1201 
<a name="54" id="anc54"></a><span class="changed">1202         subject.getPrincipals().remove(kerbClientPrinc);</span>
<span class="changed">1203            // Let us remove all Kerberos credentials stored in the Subject</span>





1204         Iterator&lt;Object&gt; it = subject.getPrivateCredentials().iterator();
1205         while (it.hasNext()) {
1206             Object o = it.next();
1207             if (o instanceof KerberosTicket ||
1208                     o instanceof KerberosKey ||
1209                     o instanceof KeyTab) {
1210                 it.remove();
1211             }
1212         }
1213         // clean the kerberos ticket and keys
1214         cleanKerberosCred();
1215 
1216         succeeded = false;
1217         commitSucceeded = false;
1218         if (debug) {
1219             System.out.println("\t\t[Krb5LoginModule]: " +
1220                                "logged out Subject");
1221         }
1222         return true;
1223     }
1224 
1225     /**
1226      * Clean Kerberos credentials
1227      */
1228     private void cleanKerberosCred() throws LoginException {
1229         // Clean the ticket and server key
1230         try {
1231             if (kerbTicket != null)
1232                 kerbTicket.destroy();
1233             if (kerbKeys != null) {
1234                 for (int i = 0; i &lt; kerbKeys.length; i++) {
1235                     kerbKeys[i].destroy();
1236                 }
1237             }
1238         } catch (DestroyFailedException e) {
1239             throw new LoginException
1240                 ("Destroy Failed on Kerberos Private Credentials");
1241         }
<a name="55" id="anc55"></a>



1242         kerbTicket = null;
1243         kerbKeys = null;
<a name="56" id="anc56"></a><span class="removed">1244         kerbClientPrinc = null;</span>
1245     }
1246 
1247     /**
1248      * Clean out the state
1249      */
1250     private void cleanState() {
1251 
1252         // save input as shared state only if
1253         // authentication succeeded
1254         if (succeeded) {
1255             if (storePass &amp;&amp;
1256                 !sharedState.containsKey(NAME) &amp;&amp;
1257                 !sharedState.containsKey(PWD)) {
1258                 sharedState.put(NAME, username);
1259                 sharedState.put(PWD, password);
1260             }
1261         } else {
1262             // remove temp results for the next try
1263             encKeys = null;
1264             ktab = null;
1265             principal = null;
1266         }
1267         username = null;
1268         password = null;
1269         if (krb5PrincName != null &amp;&amp; krb5PrincName.length() != 0)
1270             krb5PrincName.delete(0, krb5PrincName.length());
1271         krb5PrincName = null;
1272         if (clearPass) {
1273             sharedState.remove(NAME);
1274             sharedState.remove(PWD);
1275         }
1276     }
1277 }
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="57" type="hidden"></input></form></body></html>
